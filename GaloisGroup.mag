// implementation of a general galois-group finding algorithm, general in the sense that the algorithms involved are written in a modular fashion so that each piece can be changed independently of the rest, as far as possible

declare verbose PGG_GaloisGroup, 1;

Z := IntegerRing();
Q := RationalField();

function not_implemented(msg, ...)
  error "not implemented: " cat Join([Sprintf("%o", x) : x in msg], " ");  
end function;

function precision_error()
  error "precision error";
end function;

procedure isort_by(~xs, key)
  keys := [key(xs[i]) : i in [1..#xs]];
  Sort(~keys, ~permutation);
  xs := [xs[i^permutation] : i in [1..#xs]];
end procedure;

function sort_by(xs, key)
  isort_by(~xs, key);
  return xs;
end function;

function group_by(xs, key)
  A := AssociativeArray();
  for x in xs do
    k := key(x);
    if IsDefined(A, k) then
      Append(~A[k], x);
    else
      A[k] := [x];
    end if;
  end for;
end function;

function enumerate(xs)
  return [<xs[i], i> : i in [1..#xs] | IsDefined(xs, i)];
end function;

function is_any_coercible(coercers, x)
  for i in [1..#coercers] do
    ok, y := coercers[i](x);
    if ok then
      return true, i, y;
    end if;
  end for;
  return false, _, _;
end function;

function all_coercible(dflts, coercers, xs)
  assert #dflts eq #coercers;
  dflts := [* d : d in dflts *];
  for x in xs do
    ok, i, y := is_any_coercible(coercers, x);
    if ok then
      dflts[i] := y;
    else
      return false, _;
    end if;
  end for;
  return true, dflts;
end function;

function the(xs)
  assert #xs eq 1;
  return [x : x in xs][1];
end function;

// the roots of f as a sequence (no multiplicities)
// f must be squarefree
function roots(f)
  rs := Roots(f : IsSquarefree);
  assert forall{r : r in rs | r[2] eq 1};
  return [r[1] : r in rs];
end function;

// true if f has a root
// f must be squarefree
// also returns a root
function has_root(f)
  rs := roots(f);
  if #rs eq 0 then
    return false, _;
  else
    return true, rs[1];
  end if;
end function;

// the factorization of f as a sequence (no multiplicities)
// f must be squarefree
// also the certificates
function factorization(f : Extensions:=false)
  slope := Ceiling(Max(Slopes(NewtonPolygon(f))));
  d := Degree(f);
  vlc := Valuation(Coefficient(f, d));
  f2 := Parent(f) ! [ShiftValuation(Coefficient(f, i), (d-i)*slope - vlc) : i in [0..d]];
  facs, _, certs := Factorization(f2 : IsSquarefree, Certificates, Extensions:=Extensions);
  assert forall{fac : fac in facs | fac[2] eq 1};
  return [Parent(g)![ShiftValuation(Coefficient(g,i), (i-d)*slope-vlc) : i in [0..d]] where vlc:=Valuation(Coefficient(g,d)) where d:=Degree(g) where g:=fac[1] : fac in facs], certs;
end function;

function extension(f)
  facs, certs := factorization(f : Extensions);
  error if #facs gt 1, "expecting at most 1 factor";
  return certs[1]`Extension;
end function;

// the factorization of f into pieces corresponding to the slopes of its newton polygon as a sequence
function newton_polygon_factorization(f : alg:="Cheat")
  case alg:
  when "Cheat":
    // we cheat and do a full factorization and then aggregate the results
    // this will be very inefficient for some polynomials!
    facs := factorization(f);
    a := AssociativeArray();
    for fac in facs do
      s := the(Slopes(NewtonPolygon(fac)));
      if IsDefined(a, s) then
        Append(~a[s], fac);
      else
        a[s] := [fac];
      end if;
    end for;
    return [&*a[s] : s in Sort([s : s in Keys(a)])];
  else
    assert false;
  end case;
end function;

function multiplicities_to_information(mults)
  mults := [m : m in mults | m ne 0];
  assert forall{m : m in mults | m gt 0};
  assert #mults gt 0;
  if #mults eq 1 then
    return 0.0;
  end if;
  total := &+mults;
  ans := &+[-p*Log(2,p) where p:=m/total : m in mults];
  assert ans gt 0;
  return ans;
end function;

function largest_coefficient(x)
  if IsPrimeField(Parent(x)) then
    return Abs(x);
  else
    return Max([largest_coefficient(c) : c in Eltseq(x)]);
  end if;
end function;

function reduce_coefficients(x, M)
  if IsPrimeField(Parent(x)) then
    return Parent(x) ! ((Z!x) mod M);
  else
    return Parent(x) ! [reduce_coefficients(c, M) : c in Eltseq(x)];
  end if;
end function;

function startswith(x, y)
  if #x ge #y and x[1..#y] eq y then
    return true, x[#y+1..#x];
  else
    return false, _;
  end if;
end function;

procedure seq_idiff(~xs, ys)
  ys := {y : y in ys};
  xs := [xs[i] : i in [1..#xs] | xs[i] notin ys];
end procedure;

// a bound on |f(a_1,...,a_n)| where |a_i| le b.
// f is a RngSLPolElt
function slpol_bound(f, b)
  op := Operator(f);
  f1, f2 := Operands(f);
  case op:
  when "var":
    return b;
  when "const":
    return Abs(f1);
  when "+", "-":
    return slpol_bound(f1, b) + slpol_bound(f2, b);
  when "*":
    return slpol_bound(f1, b) * slpol_bound(f2, b);
  when "^":
    return slpol_bound(f1, b) ^ f2;
  else
    assert false;
  end case;
end function;

function permute_seq(g, xs)
  d := Degree(Parent(g));
  assert d eq #xs;
  return [xs[i^g] : i in [1..d]];
end function;

procedure pop_start(~x, ~xs)
  assert #xs ne 0;
  x := xs[1];
  xs := xs[2..#xs];
end procedure;

function polynomial_with_roots(rs)
  U := Universe(rs);
  R := PolynomialRing(U);
  return &*[R| [-r, 1] : r in rs];
end function;

function left_coset_representatives(G, H)
  assert H subset G;
  cosets, indices := DoubleCosetRepresentatives(G, H, sub<G | 1>);
  return cosets;
end function;

function is_extension_of(L, K)
  if L eq K then
    return true, [K];
  elif IsPrimeField(L) then
    return false, _;
  else
    ok, twr := is_extension_of(BaseField(L), K);
    if ok then
      return true, Append(twr, L);
    else
      return false, _;
    end if;
  end if;
end function;

function tower(L, K)
  ok, twr := is_extension_of(L, K);
  assert ok;
  return twr;
end function;

function is_in_standard_form(L, K)
  t := tower(L, K);
  if #t eq 1 then
    return true, K;
  elif #t eq 2 then
    if RamificationDegree(t[2]) gt 1 then
      return true, K;
    elif InertiaDegree(t[2]) gt 1 then
      return true, L;
    end if;
  elif #t eq 3 then
    U := t[2];
    if RamificationDegree(L) gt 1 and InertiaDegree(U) gt 1 then
      return true, U;
    end if;
  end if;
  return false;
end function;

function valuation_eq(c, n)
  if Valuation(c) gt n then
    return false;
  elif IsWeaklyZero(c) then
    precision_error();
  else
    return Valuation(c) eq n;
  end if;
end function;

function valuation_ge(c, n)
  if Valuation(c) ge n then
    return true;
  elif IsWeaklyZero(c) then
    precision_error();
  else
    return false;
  end if;
end function;

function is_eisenstein(f)
  d := Degree(f);
  return (d ge 0) and valuation_eq(Coefficient(f, d), 0) and valuation_eq(Coefficient(f, 0), 1) and forall{i : i in [1..d-1] | valuation_ge(Coefficient(f, i), 1)};
end function;

function xdiv(x, y)
  ok, z := IsDivisibleBy(x, y);
  assert ok;
  return z;
end function;

// solves S*M=V for S
function solve(M, V)
  return V * M^-1;
  ok, S := IsSolvable(M, V);
  if ok then
    return S;
  else
    return V * M^-1;
  end if;
end function;

// given L/K and a sequence pis of elements of L which are uniformizing elements of subextensions K(pis[#pis])/.../K(pis[1]), return this tower from the bottom up
function tower_from_uniformizers(L, K, pis : alg:="LA")
  timer := PGG_Timer();
  assert Universe(pis) eq L;
  assert not IsPrimeField(L);
  assert BaseField(L) eq K;
  t := [];
  K2 := K;
  L2 := L;
  LtoL2 := map<L -> L2 | x :-> x>;
  f := DefiningPolynomial(L);
  Lpi := L.1;
  Log(timer, "init");
  for i in [1..#pis] do
    pi2 := LtoL2(pis[i]);
    m := MinimalPolynomial(pi2, K2);
    Log(timer, "MinimalPolynomial");
    assert is_eisenstein(m);
    d := Degree(m);
    n := xdiv(Degree(L2, K2), d);
    if d gt 1 then
      K2new := ext<K2 | ChangePrecision(m, Precision(K2))>;
      case alg:
      when "Factorization":
        f2 := factorization(ChangeRing(f, K2new))[1];
      when "LA":
        V := VectorSpace(K2, Degree(L2, K2));
        vmap := map<L2 -> V | x :-> V!Eltseq(x), y :-> L2!Eltseq(y)>;
        L2pi := LtoL2(Lpi);
        vec := vmap(L2pi^n);
        mat := Matrix([vmap(L2pi^i * pi2^j) : j in [0..d-1], i in [0..n-1]]);
        coeffs := Eltseq(solve(mat, vec));
        f2 := Polynomial([K2new| i eq n select 1 else -&+[coeffs[i*d+j+1] * K2new.1^j : j in [0..d-1]] : i in [0..n]]);
      else
        assert false;
      end case;
      assert Degree(f2) eq n;
      assert is_eisenstein(f2);
      L2new := ext<K2new | ChangePrecision(f2, Precision(L2))>;
      LtoL2new := map<L -> L2new | x :-> &+[L2new| L2new.1^(i-1) * cs[i] : i in [1..#cs]] where cs:=Eltseq(x)>;
      // rename for iterating
      K2 := K2new;
      L2 := L2new;
      LtoL2 := LtoL2new;
    end if;
    Append(~t, K2);
    Log(timer, "factorization");
  end for;
  return t;
end function;

function ramification_tower(L, K)
  ok, U := is_in_standard_form(L, K);
  assert ok;
  if L eq K then
    return [K];
  elif L eq U then
    return [K, U];
  elif U eq K then
    timer := PGG_Timer();
    f := DefiningPolynomial(L);
    assert is_eisenstein(f);
    pi := L.1;
    assert IsWeaklyZero(Evaluate(f, pi));
    r := Evaluate(f, PolynomialRing(L) ! [pi, 1]);
    assert IsWeaklyZero(Coefficient(r, 0));
    Log(timer, "ramification polynomial");
    rfacs := newton_polygon_factorization(r);
    Log(timer, "newton_polygon_factorization");
    assert Degree(rfacs[1]) eq 1;
    assert forall{i : i in [1..#rfacs] | IsDivisibleBy(Degree(f), &+[Degree(rfacs[j]) : j in [1..i]])};
    crfacs := [&*rfacs[1..i] : i in [1..#rfacs]];
    cffacs := [Evaluate(crfac, PolynomialRing(L) ! [-pi, 1]) : crfac in crfacs];
    pis := [Coefficient(cffac, 0) : cffac in cffacs];
    Log(timer, "get uniformizers");
    twr := tower_from_uniformizers(L, K, Reverse(pis));
    Log(timer, "tower_from_uniformizers");
    return twr;
  else
    return [K] cat ramification_tower(L, U);
  end if;
end function;

function random_element(E, B)
  if IsPrimeField(E) then
    return E ! Random(B);
  else
    return E ! [random_element(BaseField(E), B) : i in [1..Degree(E)]];
  end if;
end function;

function random_primitive_element(E, F)
  d := Degree(E, F);
  if d eq 1 then
    return E!0, PolynomialRing(F)![0,1];
  end if;
  B := 1;
  while true do
    x := random_element(E, B);
    minpol := MinimalPolynomial(x, F);
    if Degree(minpol) eq d then
      return x, minpol;
    else
      B +:= 1;
    end if;
  end while;
end function;

function zero(K, apr)
  z := (K!1) - (K!1);
  return ShiftValuation(z, apr - AbsolutePrecision(z));
end function;

function change_apr(x, apr)
  if IsWeaklyZero(x) or apr le Valuation(x) then
    return zero(Parent(x), apr);
  else
    return ChangePrecision(x, apr - Valuation(x));
  end if;
end function;

DEFAULT_TSCHIRNHAUS_TRANSFORMATIONS := [PolynomialRing(Z) | [0,1], [0,0,1], [0,-1,1], [0,1,1], [0,0,0,1], [0,1,0,1], [0,-1,0,1], [0,0,1,1], [0,0,-1,1], [0,1,1,1], [0,-1,-1,1]];

function tschirnhaus_transformation(ntries, degree)
  assert ntries gt 0;
  if ntries le #DEFAULT_TSCHIRNHAUS_TRANSFORMATIONS then
    t := DEFAULT_TSCHIRNHAUS_TRANSFORMATIONS[ntries];
    if Degree(t) le degree then
      return t;
    end if;
  end if;
  return PolynomialRing(Z) ! [Random(1,ntries) : i in [1..degree]];
end function;

function dflt(what, d)
  return (what cmpne false) select what else d;
end function;

function dedupe_conjugage_subgroups(G, Hs)
  CG := PGG_ConjugacyClasses(G);
  return [Rep(c) : c in {CG ! H : H in Hs}];
end function;

declare type PGGArgSpec;
declare attributes PGGArgSpec: is_valid;

intrinsic PGG_Parsable(A :: PGGArgSpec, x) -> BoolElt, .
  {Tries to parse x according to A.}
  return A`is_valid(x);
end intrinsic;

intrinsic PGG_Parse(A :: PGGArgSpec, x) -> .
  {Parses x according to A}
  ok, y := PGG_Parsable(A, x);
  error if not ok, "could not parse", x;
  return y;
end intrinsic;

intrinsic PGG_ArgSpec(is_valid :: UserProgram) -> PGGArgSpec
  {The argspec with the given is_valid function.}
  A := New(PGGArgSpec);
  A`is_valid := is_valid;
  return A;
end intrinsic;

intrinsic PGG_ArgSpec_Union(choices :: [PGGArgSpec]) -> PGGArgSpec
  {The argspec for the union of the given choices.}
  return PGG_ArgSpec(function (x)
    for A in choices do
      ok, y := PGG_Parsable(A, x);
      if ok then
        return true, y;
      end if;
    end for;
    return false, _;
  end function);
end intrinsic;

intrinsic PGG_ArgSpec_ISA(C) -> PGGArgSpec
  {The argspec testing if the input has the given category.}
  return PGG_ArgSpec(function (x)
    if ISA(ExtendedType(x), C) then
      return true, x;
    else
      return false, _;
    end if;
  end function);
end intrinsic;

intrinsic PGG_ArgSpec_Literal(X) -> PGGArgSpec
  {The argspec matching only X exactly.}
  return PGG_ArgSpec(function (x)
    if X cmpeq x then
      return true, x;
    else
      return false, _;
    end if;
  end function);
end intrinsic;

intrinsic PGG_ArgSpec_Attr(name :: MonStgElt) -> PGGArgSpec
  {The argspec matching the PGGAttr with the given name and no args.}
  return PGG_ArgSpec_Attr(name, [], func<args | name>);
end intrinsic;

intrinsic PGG_ArgSpec_AttrList(name :: MonStgElt, arg, transform) -> PGGArgSpec
  {The argspec matching the PGGAttr with the given name and multiple args matching arg.}
  return PGG_ArgSpec(function (x)
    // coerce to a PGGAttr
    ok, a := PGG_Attribute_IsCoercible(x);
    if not ok then
      return false, _;
    end if;
    // check the name
    if Trim(Name(a)) ne name then
      return false, _;
    end if;
    // check the args
    xs := [**];
    for aa in Arguments(a) do
      ok, x := PGG_Parsable(arg, aa);
      if ok then
        Append(~xs, x);
      else
        return false, _;
      end if;
    end for;
    // apply the transform
    return true, transform(xs);
  end function);
end intrinsic;

intrinsic PGG_ArgSpec_Attr(name :: MonStgElt, args, transform) -> PGGArgSpec
  {The argspec matching the PGGAttr with the given name and args.}
  return PGG_ArgSpec(function (x)
    // coerce to a PGGAttr
    ok, a := PGG_Attribute_IsCoercible(x);
    if not ok then
      return false, _;
    end if;
    // check the name
    if Trim(Name(a)) ne name then
      return false, _;
    end if;
    // check the args
    // pargs := [* arg[3] : arg in args *];
    pargs := [* #arg ge 3 select <true, arg[3]> else <false> : arg in args *];
    pos := 1;
    for aa in Arguments(a) do
      // try to parse a positional argument
      for i in [pos..#args] do
        ok, parg := PGG_Parsable(args[i][1], aa);
        if ok then
          pargs[i] := <true, parg>;
          pos := i+1;
          continue aa;
        end if;
      end for;
      // try to parse keyword argument
      for i in [1..#args] do
        ok, rest := startswith(Name(aa), args[i][2] cat ":");
        if ok then
          ok, parg := PGG_Parsable(args[i][1], PGG_Attribute(rest, Arguments(aa)));
          if ok then
            pargs[i] := <true, parg>;
            continue aa;
          else
            return false, _;
          end if;
        end if;
      end for;
      // failed parsing
      return false, _;
    end for;
    // check all the arguments are defined
    if exists{p : p in pargs | not p[1]} then
      return false, _;
    end if;
    // apply the transform
    return true, transform([* p[2] : p in pargs *]);
  end function);
end intrinsic;

intrinsic PGG_ArgSpec_Recursive(mk :: UserProgram) -> PGGArgSpec
  {Allows the creation of a PGGArgSpec recursively.}
  A := New(PGGArgSpec);
  B := mk(A);
  A`is_valid := B`is_valid;
  return A;
end intrinsic;

intrinsic PGG_ArgSpec_Recursive(n :: RngIntElt, mk :: UserProgram) -> []
  {Allows the creation of n PGGArgSpecs recursively.}
  As := [New(PGGArgSpec) : i in [1..n]];
  Bs := mk(As);
  require #Bs eq n: "mk must return n PGGArgSpecs";
  for i in [1..n] do
    As[i]`is_valid := Bs[i]`is_valid;
  end for;
  return As;
end intrinsic;

intrinsic PGG_ArgSpec_ManyRecursive(mk :: UserProgram) -> Map
  {Allows the creation of many PGGArgSpecs.}
  store := NewStore();
  function set(name, A)
    ok, B := StoreIsDefined(store, name);
    if ok then
      B`is_valid := A`is_valid;
      return B;
    else
      StoreSet(store, name, A);
      return A;
    end if;
  end function;
  function get(name)
    ok, A := StoreIsDefined(store, name);
    if ok then
      return A;
    else
      A := New(PGGArgSpec);
      StoreSet(store, name, A);
      return A;
    end if;
  end function;
  mk(set, get);
  return func<name | StoreGet(store, name)>;
end intrinsic;

intrinsic PGG_ArgSpec_Predicate(test :: UserProgram) -> PGGArgSpec
  {The PGGArgSpec passing with the given test.}
  return PGG_ArgSpec(function (x)
    if test(x) then
      return true, x;
    else
      return false, _;
    end if;
  end function);
end intrinsic;

declare type PGGSetConjCls[PGGConjCls];
declare attributes PGGSetConjCls: overgroup, class_function;
declare attributes PGGConjCls: subgroup, parent, class_function_value, hash;

intrinsic PGG_ConjugacyClasses(G :: GrpPerm) -> PGGSetConjCls
  {The conjugacy classes of subgroups of G.}
  X := New(PGGSetConjCls);
  X`overgroup := G;
  X`class_function := func<H | <#H, Hash(H), {*cf(x[3])^^x[2] : x in Classes(H)*}>>
    where cf := ClassMap(G);
  return X;
end intrinsic;

intrinsic 'eq'(X :: PGGSetConjCls, Y :: PGGSetConjCls) -> BoolElt
  {Equality.}
  return IsIdentical(X, Y);
end intrinsic;

intrinsic IsCoercible(X :: PGGSetConjCls, H) -> BoolElt, .
  {IsCoercible.}
  return false, "wrong type";
end intrinsic;

intrinsic IsCoercible(X :: PGGSetConjCls, H :: GrpPerm) -> BoolElt, .
  {"}
  if H subset X`overgroup then
    x := New(PGGConjCls);
    x`subgroup := H;
    x`parent := X;
    x`class_function_value := x`parent`class_function(H);
    x`hash := Hash(x`class_function_value);
    return true, x;
  else
    return false, "not a subgroup of the right group";
  end if;
end intrinsic;

intrinsic IsCoercible(X :: PGGSetConjCls, H :: PGGConjCls) -> BoolElt, .
  {"}
  if Parent(H) eq X then
    return true, H;
  elif Parent(H)`overgroup subset X`overgroup then
    return true, X ! Rep(H);
  else
    return false, _;
  end if;
end intrinsic;

intrinsic Parent(x :: PGGConjCls) -> PGGSetConjCls
  {The parent set.}
  return x`parent;
end intrinsic;

intrinsic Hash(x :: PGGConjCls) -> RngIntElt
  {Hash.}
  return x`hash;
end intrinsic;

intrinsic Rep(x :: PGGConjCls) -> GrpPerm
  {A representative.}
  return x`subgroup;
end intrinsic;

intrinsic 'eq'(x :: PGGConjCls, y :: PGGConjCls) -> BoolElt
  {Equality.}
  assert Parent(x) eq Parent(y);
  return (x`class_function_value eq y`class_function_value) and IsConjugate(Parent(x)`overgroup, x`subgroup, y`subgroup);
end intrinsic;

declare type PGGTimer;
declare attributes PGGTimer: last_time, times, labels, current_label, idxs;

intrinsic PGG_Timer() -> PGGTimer
  {A new timer.}
  t := New(PGGTimer);
  t`last_time := Cputime();
  t`times := [RealField()|];
  t`labels := [PowerSequence(Strings())|];
  t`current_label := [Strings()|];
  t`idxs := AssociativeArray(PowerSequence(Strings()));
  return t;
end intrinsic;

intrinsic FindIndex(t :: PGGTimer, label :: [MonStgElt]) -> RngIntElt
  {The index of the given label. If it doesn't exist, creates it first.}
  ok, i := IsDefined(t`idxs, label);
  if ok then
    return i;
  end if;
  Append(~t`times, 0);
  Append(~t`labels, label);
  t`idxs[label] := #t`labels;
  return #t`labels;
end intrinsic;

intrinsic Update(t :: PGGTimer, label :: [MonStgElt])
  {Assigns the accumulated time to the given label.}
  i := FindIndex(t, label);
  now := Cputime();
  t`times[i] +:= now - t`last_time;
  t`last_time := now;
end intrinsic;

intrinsic Push(t :: PGGTimer, x :: MonStgElt)
  {Assings time to the current label, then appends x to the label.}
  Update(t, t`current_label);
  Append(~t`current_label, x);
end intrinsic;

intrinsic Pop(t :: PGGTimer, n :: RngIntElt)
  {Assigns time to the current label, then pops n items from the label.}
  error if #t`current_label lt n, "n greater than label length";
  Update(t, t`current_label);
  t`current_label := t`current_label[1..#t`current_label-n];
end intrinsic;

intrinsic Pop(t :: PGGTimer, n :: RngIntElt, x :: MonStgElt)
  {Assigns time to the current label, then pops n items from the label, the nth being x.}
  error if #t`current_label lt n, "n greater than label length";
  error if t`current_label[#t`current_label-n+1] ne x, "incorrect label entry";
  Update(t, t`current_label);
  t`current_label := t`current_label[1..#t`current_label-n];
end intrinsic;

intrinsic Pop(t :: PGGTimer, x :: MonStgElt)
  {Assigns time to the current label, then pops the last item from the label, which must be x.}
  Pop(t, 1, x);
end intrinsic;

intrinsic Pop(t :: PGGTimer)
  {Assigns time to the current label, then pops the last item from the label.}
  Pop(t, 1);
end intrinsic;

intrinsic Swap(t :: PGGTimer, x :: MonStgElt)
  {Assigns time to the current label, then swaps the last item from the label to x.}
  error if #t`current_label lt 1, "label too short";
  Update(t, t`current_label);
  t`current_label[#t`current_label] := x;
end intrinsic;

intrinsic Log(t :: PGGTimer, x :: MonStgElt)
  {Assigns time to the current label with x appended.}
  Update(t, Append(t`current_label, x));
end intrinsic;

intrinsic Tree(t :: PGGTimer) -> Tup
  {A tree representation of t.}
  procedure insert(~node, label, tm)
    node[2] +:= tm;
    if #label gt 0 then
      for i in [1..#node[3]] do
        if node[3][i][1] eq label[1] then
          insert(~node[3][i], label[2..#label], tm);
          return;
        end if;
      end for;
      Append(~node[3], <label[1], 0.0, [**]>);
      insert(~node[3][#node[3]], label[2..#label], tm);
    end if;
  end procedure;
  root := <"TOTAL", 0.0, [**]>;
  for i in [1..#t`labels] do
    insert(~root, t`labels[i], t`times[i]);
  end for;
  return root;
end intrinsic;

intrinsic PrintTree(t :: PGGTimer)
  {Prints t as a tree.}
  procedure pr(node, depth)
    printf "%o%6.2o %o\n", &cat[Strings() | "  " : i in [1..depth]], node[2], node[1];
    for n in node[3] do
      pr(n, depth+1);
    end for;
  end procedure;
  pr(Tree(t), 0);
end intrinsic;

declare type PGGAttr;
declare attributes PGGAttr: name, arguments;

intrinsic Print(x :: PGGAttr, lvl :: MonStgElt)
  {Print.}
  case lvl:
  when "Magma":
    printf "PGG_Attribute(%m, %m)", Name(x), Arguments(x);
  else
    printf "%o", Name(x);
    if #Arguments(x) gt 0 then
      printf "(%o)", Join([Sprintf("%o",a) : a in Arguments(x)], ",");
    end if;
  end case;
end intrinsic;

intrinsic Name(a :: PGGAttr) -> MonStgElt
  {The name.}
  return a`name;
end intrinsic;

intrinsic Arguments(a :: PGGAttr) -> []
  {The arguments.}
  return a`arguments;
end intrinsic;

intrinsic PGG_Attribute(name :: MonStgElt, arguments :: [PGGAttr]) -> PGGAttr
  {An attribute.}
  a := New(PGGAttr);
  a`name := name;
  a`arguments := arguments;
  return a;
end intrinsic;

intrinsic PGG_Attribute(name :: MonStgElt) -> PGGAttr
  {"}
  a := New(PGGAttr);
  a`name := name;
  a`arguments := [];
  return a;
end intrinsic;

intrinsic PGG_Attribute() -> PGGAttr
  {"}
  a := New(PGGAttr);
  a`name := "";
  a`arguments := [];
  return a;
end intrinsic;

intrinsic PGG_Attribute_IsCoercible(x) -> BoolElt, .
  {True if x is coercible to a PGGAttr.}
  return false, "wrong type";
end intrinsic;

intrinsic PGG_Attribute_IsCoercible(x :: PGGAttr) -> BoolElt, .
  {"}
  return true, x;
end intrinsic;

intrinsic PGG_Attribute_IsCoercible(x :: MonStgElt) -> BoolElt, .
  {"}
  // process each character in turn
  stack := [PGG_Attribute()];
  i := 0;
  for i in [1..#x] do
    c := x[i];
    assert #stack ge 1;
    case c:
    when ",":
      if #stack lt 2 then
        return false, Sprintf("parse error: %o: illegal ','", i);
      end if;
      Append(~stack[#stack-1]`arguments, stack[#stack]);
      stack[#stack] := PGG_Attribute();
    when "[":
      Append(~stack, PGG_Attribute());
    when "]":
      if #stack lt 2 then
        return false, Sprintf("parse error: %o: illegal ')'");
      end if;
      Append(~stack[#stack-1]`arguments, stack[#stack]);
      stack := stack[1..#stack-1];
    else
      stack[#stack]`name cat:= c;
    end case;
  end for;
  assert #stack ge 1;
  if #stack gt 1 then
    return false, Sprintf("parse error: end of input: too few ')'");
  end if;
  // done
  return true, stack[1];
end intrinsic;




declare type PGGAlg;

declare type PGGAlgState;
declare attributes PGGAlgState: algorithm;

declare type PGGAlg_GaloisGroup: PGGAlg;

declare type PGGAlg_GaloisGroup_Builtin: PGGAlg_GaloisGroup;

declare type PGGAlg_GaloisGroup_SinglyRamified: PGGAlg_GaloisGroup;

declare type PGGAlg_GaloisGroup_ResolventMethod: PGGAlg_GaloisGroup;
declare attributes PGGAlg_GaloisGroup_ResolventMethod: groups_alg, resolvent_alg, conjugacy_alg, use_easy_resolvents;

declare type PGGAlg_ResGroups: PGGAlg;

declare type PGGAlg_ResGroups_All: PGGAlg_ResGroups;
declare attributes PGGAlg_ResGroups_All: subgroup_tranche, subgroup_score, subgroup_order, subgroup_choice, statistic;

declare type PGGAlgState_ResGroups_All: PGGAlgState;
declare attributes PGGAlgState_ResGroups_All: conjugacy, overgroup, possible_groups, possible_subgroups;

declare type PGGAlg_ResEval: PGGAlg;

declare type PGGAlg_ResEval_Global: PGGAlg_ResEval;

declare type PGGAlgState_ResEval_Global: PGGAlgState;
declare attributes PGGAlgState_ResEval_Global: conjugacy, base_field_model, pol_model, precision, complex_roots;

declare type PGGAlg_Conjugacy: PGGAlg;

declare type PGGAlg_Conjugacy_Symmetric: PGGAlg_Conjugacy;
declare attributes PGGAlg_Conjugacy_Symmetric: galois_group_alg;

declare type PGGAlg_Conjugacy_Factors: PGGAlg_Conjugacy;
declare attributes PGGAlg_Conjugacy_Factors: next;

declare type PGGAlg_Conjugacy_RamTower: PGGAlg_Conjugacy;
declare attributes PGGAlg_Conjugacy_RamTower: next;

declare type PGGConj;
declare attributes PGGConj
  : group           // the group in which the Galois group is defined up to conjugacy
  , base_field      // the base field of the Galois group
  , parent_subgroup // when part of a larger Galois group, this group is a quotient of a subgroup of the parent group; parent_subgroup is the subgroup
  , parent_quotient // the quotient map from parent_subgroup to this group
  , is_known        // [* false *] or [* true, G *] where G is the actual Galois group
  , is_transitive   // true if the actual Galois group is known to be transitive
  , overgroup       // an overgroup of the actual Galois group (a subgroup of `group`)
  , orbits_of_subgroups // for cacheing OrbitsOfSubgroups
  ;

declare type PGGConj_Symmetric: PGGConj;
declare attributes PGGConj_Symmetric: pol, top_field;

declare type PGGConj_Factors: PGGConj;
declare attributes PGGConj_Factors: factors;

declare type PGGConj_Tower: PGGConj;
declare attributes PGGConj_Tower: tower, top_field, pol, orbits_of_subgroups_above;

declare type PGGGloMod;

declare type PGGGloMod_Rational: PGGGloMod;
declare attributes PGGGloMod_Rational: local_field, global_field, embedding;

declare type PGGGloMod_Symmetric: PGGGloMod;
declare attributes PGGGloMod_Symmetric: local_pol, global_pol, local_field, global_field, embedding;

declare type PGGGloMod_Factors: PGGGloMod;
declare attributes PGGGloMod_Factors: factors;

declare type PGGGloMod_Tower: PGGGloMod;
declare attributes PGGGloMod_Tower: tower, global_pol, global_pol_root;

declare type PGGStat;
declare type PGGStat_HasRoot: PGGStat;
declare type PGGStat_NumRoots: PGGStat;
declare type PGGStat_FactorDegrees: PGGStat;
declare type PGGStat_FactorDegrees2: PGGStat;
declare type PGGStat_Degree: PGGStat;
declare type PGGStat_AutGroup: PGGStat;
declare attributes PGGStat_AutGroup: conjugacy_classes;
declare type PGGStat_Tup: PGGStat;
declare attributes PGGStat_Tup: stats;
declare type PGGStat_Factors: PGGStat;
declare attributes PGGStat_Factors: stat;

declare type PGGStatVal;
declare attributes PGGStatVal: stat, value, hash;

declare type PGGOrder;
declare type PGGOrder_None: PGGOrder;
declare type PGGOrder_Random: PGGOrder;
declare type PGGOrder_Reverse: PGGOrder;
declare attributes PGGOrder_Reverse: order;
declare type PGGOrder_Key: PGGOrder;
declare attributes PGGOrder_Key: key;

intrinsic PGG_AllGroups() -> PGGAlg_ResGroups_All
  {The "AllGroups" group theory algorithm for the resolvent method.}
  return New(PGGAlg_ResGroups_All);
end intrinsic;

intrinsic Start(alg :: PGGAlg_ResGroups_All, conj :: PGGConj, overgroup :: GrpPerm) -> PGGAlgState_ResGroups_All
  {Starts the algorithm and returns its state.}
  assert overgroup subset conj`group;
  s := New(PGGAlgState_ResGroups_All);
  s`algorithm := alg;
  s`conjugacy := conj;
  s`overgroup := overgroup;
  // get a list of possible groups
  s`possible_groups := (known select [G] else dedupe_conjugage_subgroups(conj`group, [G : x in Subgroups(Overgroup(conj) : IsSolvable, IsTransitive:=IsTransitive(conj)) | IsConsistent(conj, G) where G:=x`subgroup])) where known,G:=IsKnown(conj);
  vprint PGG_GaloisGroup: "#possible groups =", #s`possible_groups;
  return s;
end intrinsic;

intrinsic IsDone(s :: PGGAlgState_ResGroups_All) -> BoolElt, GrpPerm
  {True if we have deduced the Galois group.}
  if #s`possible_groups eq 1 then
    return true, s`possible_groups[1];
  else
    assert #s`possible_groups gt 1;
    return false, _;
  end if;
end intrinsic;

intrinsic TheGroup(s :: PGGAlgState_ResGroups_All) -> GrpPerm
  {The Galois group, assuming it is already known.}
  ok, G := IsDone(s);
  assert ok;
  return G;
end intrinsic;

intrinsic SubgroupTranche(s :: PGGAlgState_ResGroups_All) -> []
  {A sequence of subgroups to consider using.}
  case s`algorithm`subgroup_tranche:
  when "All":
    if not assigned s`possible_subgroups then
      s`possible_subgroups := enumerate([x`subgroup : x in Subgroups(s`overgroup)]);
    end if;
    return [x : x in s`possible_subgroups];
  when "Index":
    if not assigned s`possible_subgroups then
      s`possible_subgroups := rec<recformat<i, indices, all_groups, cur_groups> | indices:=Sort(Divisors(Order(s`overgroup))), all_groups:=[], cur_groups:=[]>;
    end if;
    while #s`possible_subgroups`cur_groups eq 0 do
      n := 1+#s`possible_subgroups`all_groups;
      error if n gt #s`possible_subgroups`indices, "ran out of possible distinguishing subgroups";
      index := s`possible_subgroups`indices[n];
      vprint PGG_GaloisGroup: "index =", index;
      Append(~s`possible_subgroups`all_groups, [x`subgroup : x in Subgroups(s`overgroup : IndexEqual:=index)]);
      s`possible_subgroups`cur_groups := enumerate(s`possible_subgroups`all_groups[n]);
    end while;
    return [x : x in s`possible_subgroups`cur_groups];
  when "MostUseful":
    W := s`overgroup;
    if not assigned s`possible_subgroups then
      CW := PGG_ConjugacyClasses(W);
      s`possible_subgroups := rec<recformat<queue, queue_changed, cur_groups, usefulness, ignore_groups, classes> | queue:=[<CW!W, <1, 1>>], queue_changed:=false, cur_groups:=[], usefulness:=AssociativeArray(), classes:=CW>;
    else
      CW := s`possible_subgroups`classes;
    end if;
    while #s`possible_subgroups`cur_groups eq 0 do
      // ensure the queue is sorted
      if s`possible_subgroups`queue_changed then
        s`possible_subgroups`queue_changed := false;
        isort_by(~s`possible_subgroups`queue, func<x | x[2]>);
      end if;
      // pop a group class from the queue
      pop_start(~item, ~s`possible_subgroups`queue);
      class, usefulness := Explode(item);
      vprint PGG_GaloisGroup: "usefulness =", usefulness;
      // find its maximal subgroups
      subclasses := {CW ! x`subgroup : x in MaximalSubgroups(Rep(class))};
      // throw out the ones which have been used already, and so have an assigned usefulness
      subclasses := [c : c in subclasses | not IsDefined(s`possible_subgroups`usefulness, c)];
      s`possible_subgroups`cur_groups := [<Rep(c), i, c, usefulness[1]*Index(Rep(class), Rep(c))> where c:=subclasses[i] : i in [1..#subclasses]];
    end while;
    return [x : x in s`possible_subgroups`cur_groups];
  else
    assert false;
  end case;
end intrinsic;

intrinsic MakeValue(S :: PGGStat, value) -> PGGStatVal
  {A value for the statistic S.}
  x := New(PGGStatVal);
  x`stat := S;
  x`value := value;
  return x;
end intrinsic;

intrinsic Hash(v :: PGGStatVal) -> .
  {Hash of v.}
  if not assigned v`hash then
    v`hash := Hash(v`stat, v);
  end if;
  return v`hash;
end intrinsic;

intrinsic 'eq'(S1 :: PGGStat, S2 :: PGGStat) -> BoolElt
  {Equality.}
  return IsIdentical(S1, S2);
end intrinsic;

intrinsic 'eq'(v1 :: PGGStatVal, v2 :: PGGStatVal) -> BoolElt
  {Equality.}
  require v1`stat eq v2`stat: "must be values of the same statistic";
  return 'eq'(v1`stat, v1, v2);
end intrinsic;

intrinsic Print(v :: PGGStatVal)
  {Prints.}
  Print(v`stat, v);
end intrinsic;

intrinsic PGGStat_HasRoot_Make() -> PGGStat_HasRoot
  {Makes a new PGGStat.}
  return New(PGGStat_HasRoot);
end intrinsic;

intrinsic PGGStat_NumRoots_Make() -> PGGStat_NumRoots
  {Makes a new PGGStat.}
  return New(PGGStat_NumRoots);
end intrinsic;

intrinsic PGGStat_FactorDegrees_Make() -> PGGStat_FactorDegrees
  {Makes a new PGGStat.}
  return New(PGGStat_FactorDegrees);
end intrinsic;

intrinsic PGGStat_FactorDegrees2_Make() -> PGGStat_FactorDegrees2
  {"}
  return New(PGGStat_FactorDegrees2);
end intrinsic;

intrinsic PGGStat_AutGroup_Make() -> PGGStat_AutGroup
  {"}
  return New(PGGStat_AutGroup);
end intrinsic;

intrinsic PGGStat_Degree_Make() -> PGGStat_Degree
  {Makes a new PGGStat.}
  return New(PGGStat_Degree);
end intrinsic;

intrinsic PGGStat_Factors_Make(:Stat:=false) -> PGGStat_Factors
  {Makes a new PGGStat.}
  S := New(PGGStat_Factors);
  S`stat := Stat cmpne false select Stat else PGGStat_Degree_Make();
  return S;
end intrinsic;

intrinsic PGGStat_Tup_Make(args) -> PGGStat_Tup
  {Makes a new PGGStat.}
  S := New(PGGStat_Tup);
  S`stats := args;
  return S;
end intrinsic;

intrinsic ConjugacyClasses(S :: PGGStat_AutGroup, d :: RngIntElt) -> PGGSetConjCls
  {The conjugacy classes of Sym(d).}
  if not assigned S`conjugacy_classes then
    S`conjugacy_classes := AssociativeArray();
  end if;
  if not IsDefined(S`conjugacy_classes, d) then
    S`conjugacy_classes[d] := PGG_ConjugacyClasses(SymmetricGroup(d));
  end if;
  return S`conjugacy_classes[d];
end intrinsic;

intrinsic GroupStat(S :: PGGStat_HasRoot, G :: GrpPerm) -> PGGStatVal
  {The value of the statistic on the group.}
  return MakeValue(S, exists{o : o in Orbits(G) | #o eq 1});
end intrinsic;

intrinsic GroupStat(S :: PGGStat_NumRoots, G :: GrpPerm) -> PGGStatVal
  {The value of the statistic on the group.}
  return MakeValue(S, #[o : o in Orbits(G) | #o eq 1]);
end intrinsic;

intrinsic GroupStat(S :: PGGStat_FactorDegrees, G :: GrpPerm) -> PGGStatVal
  {The value of the statistic on the group.}
  return MakeValue(S, {* #o : o in Orbits(G) *});
end intrinsic;

intrinsic GroupStat(S :: PGGStat_FactorDegrees2, G :: GrpPerm) -> PGGStatVal
  {"}
  return MakeValue(S, {* <#o, {*#o : o in Orbits(S)*}> where S:=Stabilizer(G, Rep(o)) : o in Orbits(G)*});
end intrinsic;

intrinsic GroupStat(S :: PGGStat_Degree, G :: GrpPerm) -> PGGStatVal
  {The value of the statistic on the group.}
  return MakeValue(S, Degree(G));
end intrinsic;

intrinsic GroupStat(S :: PGGStat_AutGroup, G :: GrpPerm) -> PGGStatVal
  {"}
  assert IsTransitive(G);
  stab := Stabilizer(G, 1);
  norm := Normalizer(G, stab);
  aut := CosetImage(norm, stab);
  return MakeValue(S, ConjugacyClasses(S, Degree(aut)) ! aut);
end intrinsic;

intrinsic GroupStat(S :: PGGStat_Tup, G :: GrpPerm) -> PGGStatVal
  {The value of the statistic on the group.}
  return MakeValue(S, <GroupStat(S2, G) : S2 in S`stats>);
end intrinsic;

intrinsic GroupStat(S :: PGGStat_Factors, G :: GrpPerm) -> PGGStatVal
  {The value of the statistic on the group.}
  return MakeValue(S, {* GroupStat(S`stat, OrbitImage(G, o)) : o in Orbits(G) *});
end intrinsic;

intrinsic ResolventStat(S :: PGGStat_HasRoot, R :: RngUPolElt[FldPad]) -> PGGStatVal
  {The value of the statistic on the resolvent.}
  return MakeValue(S, has_root(R));
end intrinsic;

intrinsic ResolventStat(S :: PGGStat_NumRoots, R :: RngUPolElt[FldPad]) -> PGGStatVal
  {The value of the statistic on the resolvent.}
  return MakeValue(S, #roots(R));
end intrinsic;

intrinsic ResolventStat(S :: PGGStat_FactorDegrees, R :: RngUPolElt[FldPad]) -> PGGStatVal
  {The value of the statistic on the resolvent.}
  return MakeValue(S, {* Degree(fac) : fac in factorization(R) *});
end intrinsic;

intrinsic ResolventStat(S :: PGGStat_FactorDegrees2, R :: RngUPolElt[FldPad]) -> PGGStatVal
  {"}
  return MakeValue(S, {* <Degree(fac), {* Degree(fac) : fac in factorization(ChangeRing(R, L)) *}> where L:=certs[i]`Extension where fac:=facs[i] : i in [1..#facs] *} where facs,certs:=factorization(R : Extensions));
end intrinsic;

intrinsic ResolventStat(S :: PGGStat_Degree, R :: RngUPolElt[FldPad]) -> PGGStatVal
  {The value of the statistic on the resolvent.}
  return MakeValue(S, Degree(R));
end intrinsic;

intrinsic ResolventStat(S :: PGGStat_AutGroup, R :: RngUPolElt[FldPad]) -> PGGStatVal
  {"}
  K := BaseRing(R);
  L := extension(R);
  aut := AutomorphismGroup(L, K);
  return MakeValue(S, ConjugacyClasses(S, Degree(aut)) ! aut);
end intrinsic;

intrinsic ResolventStat(S :: PGGStat_Tup, R :: RngUPolElt[FldPad]) -> PGGStatVal
  {The value of the statistic on the resolvent.}
  return MakeValue(S, <ResolventStat(S2, R) : S2 in S`stats>);
end intrinsic;

intrinsic ResolventStat(S :: PGGStat_Factors, R :: RngUPolElt[FldPad]) -> PGGStatVal
  {The value of the statistic on the resolvent.}
  return MakeValue(S, {* ResolventStat(S`stat, fac) : fac in factorization(R) *});
end intrinsic;

intrinsic 'eq'(S :: PGGStat, v1, v2) -> BoolElt
  {Equality.}
  return v1`value eq v2`value;
end intrinsic;

intrinsic 'eq'(S :: PGGStat_AutGroup, v1, v2) -> BoolElt
  {"}
  return Degree(Rep(v1`value)) eq Degree(Rep(v2`value)) and v1`value eq v2`value;
end intrinsic;

intrinsic Hash(S :: PGGStat, v) -> .
  {Hash.}
  return Hash(v`value);
end intrinsic;

intrinsic Hash(S :: PGGStat_AutGroup, v) -> .
  {"}
  return Hash(<Degree(Rep(v`value)), v`value>);
end intrinsic;

intrinsic Print(S :: PGGStat, v)
  {"}
  printf "%o", v`value;
end intrinsic;

intrinsic Print(S :: PGGStat_AutGroup, v)
  {"}
  printf "%o", GroupName(Rep(v`value));
end intrinsic;

intrinsic ScoreSubgroup(s :: PGGAlgState_ResGroups_All, subgroup :: GrpPerm) -> FldReElt
  {Scores the given subgroup.}
  assert #s`possible_groups gt 0;
  stats := [**];
  h := CosetAction(s`overgroup, subgroup);
  A := AssociativeArray();
  for G in s`possible_groups do
    stat := GroupStat(s`algorithm`statistic, h(G));
    if IsDefined(A, stat) then
      Append(~A[stat], G);
    else
      A[stat] := [G];
      if (s`algorithm`subgroup_score eq "IsUseful") and (#A gt 1) then
        return 1;
      end if;
    end if;
  end for;
  case s`algorithm`subgroup_score:
  when "IsUseful":
    assert #A le 1;
    return -1;
  when "Diversity":
    return #A le 1 select -1 else #A;
  when "Information":
    return #A le 1 select -1 else multiplicities_to_information([#A[k] : k in Keys(A)]);
  else
    assert false;
  end case;
end intrinsic;

intrinsic TerminateScoring(s :: PGGAlgState_ResGroups_All, scores :: []) -> BoolElt
  {True if we know enough scores to finish.}
  case s`algorithm`subgroup_choice:
  when "First":
    return #scores ge 1;
  when "Best":
    return false;
  else
    assert false;
  end case;
end intrinsic;

intrinsic PGGOrder_None_Make() -> PGGOrder_None
  {Makes an ordering.}
  return New(PGGOrder_None);
end intrinsic;

intrinsic PGGOrder_Random_Make() -> PGGOrder_Random
  {"}
  return New(PGGOrder_Random);
end intrinsic;

intrinsic PGGOrder_Reverse_Make(order :: PGGOrder) -> PGGOrder_Reverse
  {"}
  o := New(PGGOrder_Reverse);
  o`order := order;
  return o;
end intrinsic;

intrinsic PGGOrder_Key_Make(key :: UserProgram) -> PGGOrder_Key
  {"}
  o := New(PGGOrder_Key);
  o`key := key;
  return o;
end intrinsic;

intrinsic PGGOrder_Key_Index_Make() -> PGGOrder_Key
  {"}
  return PGGOrder_Key_Make(func<x,s | Index(s`overgroup, x[1])>);
end intrinsic;

intrinsic PGGOrder_Key_OrbitIndex_Make() -> PGGOrder_Key
  {"}
  return PGGOrder_Key_Make(func<x,s | Index(s`overgroup, &meet[Stabilizer(s`overgroup, o) : o in Orbits(x[1])])>);
end intrinsic;

intrinsic Sort(xs :: [], order :: PGGOrder_None : Data:=false) -> []
  {Sorts xs according to the given ordering.}
  return xs;
end intrinsic;

intrinsic Sort(xs :: [], order :: PGGOrder_Random : Data:=false) -> []
  {"}
  return [xs[i^r] : i in [1..#xs]] where r:=Random(SymmetricGroup(#xs));
end intrinsic;

intrinsic Sort(xs :: [], order :: PGGOrder_Reverse : Data:=false) -> []
  {"}
  return Reverse(Sort(xs, order`order : Data:=Data));
end intrinsic;

intrinsic Sort(xs :: [], order :: PGGOrder_Key : Data:=false) -> []
  {"}
  keys := [order`key(x, Data) : x in xs];
  Sort(~keys, ~permut);
  return [xs[i^permut] : i in [1..#xs]];
end intrinsic;

// intrinsic OrderSubgroups(s :: PGGAlgState_ResGroups_All, groups :: [Tup]) -> []
//   {Orders the subgroups.}
//   case s`algorithm`subgroup_order:
//   when "None":
//     return groups;
//   when "Random":
//     return [groups[i^r] : i in [1..#groups]] where r:=Random(SymmetricGroup(#groups));
//   when "Index":
//     return sort_by(groups, func<G | -#G[1]>);
//   when "OrbitIndex":
//     return sort_by(groups, func<G | -#&meet[Stabilizer(s`overgroup, o) : o in Orbits(G[1])]>);
//   else
//     assert false;
//   end case;
// end intrinsic;

intrinsic UselessSubgroups(s :: PGGAlgState_ResGroups_All, subgroups :: [Tup])
  {Declares we are done considering these groups.}
  case s`algorithm`subgroup_tranche:
  when "All":
    for x in subgroups do
      Undefine(~s`possible_subgroups, x[2]);
    end for;
  when "Index":
    for x in subgroups do
      Undefine(~s`possible_subgroups`cur_groups, x[2]);
    end for;
  when "MostUseful":
    for x in subgroups do
      _, i, c, u := Explode(x);
      Undefine(~s`possible_subgroups`cur_groups, i);
      s`possible_subgroups`usefulness[c] := u;
      Append(~s`possible_subgroups`queue, <c, <u, Index(s`overgroup, Rep(c))>>);
      s`possible_subgroups`queue_changed := true;
    end for;
  else
    assert false;
  end case;
end intrinsic;

intrinsic UsefulSubgroup(s :: PGGAlgState_ResGroups_All, subgroup :: Tup)
  {Declare that we are using the given subgroup.}
  case s`algorithm`subgroup_tranche:
  when "All", "Index":
    UselessSubgroups(s, [subgroup]);
  when "MostUseful":
    _, i, c, _ := Explode(subgroup);
    Undefine(~s`possible_subgroups`cur_groups, i);
    s`possible_subgroups`usefulness[c] := 1;
    Append(~s`possible_subgroups`queue, <c, <1, Index(s`overgroup, Rep(c))>>);
    s`possible_subgroups`queue_changed := true;
  else
    assert false;
  end case;
end intrinsic;

intrinsic Subgroup(s :: PGGAlgState_ResGroups_All) -> GrpPerm
  {A subgroup to get a resolvent of.}
  while true do
    // get the next tranche of groups
    groups := SubgroupTranche(s);
    // reorder them
    groups := Sort(groups, s`algorithm`subgroup_order : Data:=s);
    // score them
    scores := [car<Universe(groups), RealField()>| ];
    useless := [Universe(groups)| ];
    for U in groups do
      score := ScoreSubgroup(s, U[1]);
      if score ge 0 then
        Append(~scores, <U, score>);
        if TerminateScoring(s, scores) then
          break U;
        end if;
      else
        Append(~useless, U);
      end if;
    end for;
    // ignore the useless subgroups
    vprint PGG_GaloisGroup: "#useless =", #useless, "of", #groups;
    UselessSubgroups(s, useless);
    // get the best scoring
    if #scores gt 0 then
      U := Sort(scores, func<a,b | b[2]-a[2]>)[1][1];
      UsefulSubgroup(s, U);
      return U[1];
    end if;
  end while;
end intrinsic;

intrinsic ProcessResolvent(s :: PGGAlgState_ResGroups_All, resolvent :: RngUPolElt[FldPad], subgroup :: GrpPerm)
  {Use the resolvent to get information about the Galois group.}
  rstat := ResolventStat(s`algorithm`statistic, resolvent);
  vprint PGG_GaloisGroup: "resolvent statistic =", rstat;
  h := CosetAction(s`overgroup, subgroup);
  vprint PGG_GaloisGroup: "group statistics =", {* GroupStat(s`algorithm`statistic, h(G)) : G in s`possible_groups *};
  s`possible_groups := [G : G in s`possible_groups | gstat eq rstat where gstat := GroupStat(s`algorithm`statistic, h(G))];
  vprint PGG_GaloisGroup: "#possible groups =", #s`possible_groups;
end intrinsic;

intrinsic GlobalModel(F :: FldPad) -> PGGGloMod
  {A global model for F.}
  if IsPrimeField(F) then
    m := New(PGGGloMod_Rational);
    m`local_field := F;
    m`global_field := Q;
    m`embedding := map<Q -> F | x :-> x, y :-> y>;
    return m;
  else
    not_implemented("global_model: non-prime field");
  end if;
end intrinsic;

intrinsic GlobalModel(conj :: PGGConj_Symmetric, bm :: PGGGloMod) -> PGGGloMod
  {Global model with the given base model.}
  m := New(PGGGloMod_Symmetric);
  e := bm`embedding;
  locpol := conj`pol;
  m`local_pol := locpol;
  glopol0 := Polynomial([c@@e : c in Coefficients(locpol)]);
  if assigned conj`top_field then
    locext := conj`top_field;
    assert IsWeaklyEqual(DefiningPolynomial(locext), locpol);
    // minimize the coefficients of glopol
    K := BaseRing(locpol);
    pr := Precision(K);
    glopol := glopol0;
    root := locext.1;
    locext2 := locext;
    isom := map<locext -> locext2 | x :-> x, y :-> y>;
    pr := Ceiling(Log(Prime(K), Max([largest_coefficient(c) : c in Coefficients(glopol)])));
    while true do
      pr div:= 2;
      if pr lt 2 then
        break;
      end if;
      glopol2 := Polynomial([reduce_coefficients(c, Prime(K)^pr) : c in Coefficients(glopol)]);
      locpol2 := Polynomial([change_apr(c@e, Precision(K)) : c in Coefficients(glopol2)]);
      locext2new := ext<K | locpol2>;
      ok1, root := has_root(ChangeRing(locpol, locext2new));
      ok2, root2 := has_root(ChangeRing(locpol2, locext));
      if ok1 and ok2 then
        locext2 := locext2new;
        isom := map<locext -> locext2 | x :-> &+[cs[i] * root^(i-1) : i in [1..#cs]] where cs:=Eltseq(x), y :-> &+[cs[i] * root2^(i-1) : i in [1..#cs]] where cs:=Eltseq(y)>;
        glopol := glopol2;
      else
        break;
      end if;
    end while;
    // make the embedding
    m`global_pol := glopol;
    gloext := ext<BaseRing(glopol) | glopol>;
    ee := map<gloext -> locext | x :-> (locext2![c@e : c in Eltseq(x)]) @@ isom, y :-> gloext![c@@e : c in Eltseq(y @ isom)]>;
    m`local_field := locext;
    m`global_field := gloext;
    m`embedding := ee;
  else
    m`global_pol := glopol0;
  end if;
  return m;
end intrinsic;

intrinsic GlobalModel(conj :: PGGConj_Factors, bm :: PGGGloMod) -> PGGGloMod
  {"}
  m := New(PGGGloMod_Factors);
  m`factors := [GlobalModel(c, bm) : c in conj`factors];
  return m;
end intrinsic;

intrinsic GlobalModel(conj :: PGGConj_Tower, bm :: PGGGloMod) -> PGGGloMod
  {"}
  m := New(PGGGloMod_Tower);
  m`tower := [**];
  m2 := bm;
  for c in conj`tower do
    m2 := GlobalModel(c, m2);
    Append(~m`tower, m2);
  end for;
  gloroot, glopol := random_primitive_element(m`tower[#m`tower]`global_field, BaseRing(m`tower[1]`global_pol));
  m`global_pol := glopol;
  m`global_pol_root := gloroot;
  return m;
end intrinsic;

intrinsic PGG_AbsoluteResolvents() -> PGGAlg_ResEval_Global
  {The "AbsoluteResolvents" resolvent algorithm for the resolvent method.}
  return New(PGGAlg_ResEval_Global);
end intrinsic;

intrinsic Start(alg :: PGGAlg_ResEval_Global, conj :: PGGConj) -> PGGAlgState_ResEval_Global
  {Starts the algorithm and returns its state.}
  s := New(PGGAlgState_ResEval_Global);
  s`algorithm := alg;
  s`conjugacy := conj;
  s`precision := -Infinity();
  s`base_field_model := GlobalModel(BaseField(conj));
  s`pol_model := GlobalModel(conj, s`base_field_model);
  return s;
end intrinsic;

intrinsic Overgroup(s :: PGGAlgState_ResEval_Global) -> GrpPerm
  {The overgroup we can evaluate resolvents in.}
  return s`conjugacy`group;
end intrinsic;

intrinsic ComplexEmbeddings(m :: PGGGloMod_Rational, embs :: [Map]) -> []
  {The complex embeddings of m extending embs.}
  return embs;
end intrinsic;

intrinsic ComplexEmbeddings(m :: PGGGloMod_Symmetric, embs :: [Map]) -> []
  {"}
  rss := ComplexRoots(m, embs);
  return [map<m`global_field -> C | x :-> &+[(cs[j] @ e) * r^(j-1) : j in [1..#cs]] where cs:=Eltseq(x)> where C:=Codomain(e) where e:=embs[i] : r in rss[i], i in [1..#embs]];
end intrinsic;

intrinsic ComplexRoots(m :: PGGGloMod_Symmetric, embs :: [Map]) -> []
  {The complex roots of the polynomial model.}
  return [[r[1] : r in Roots(Polynomial([c@e : c in Coefficients(m`global_pol)]))] : e in embs];
end intrinsic;

intrinsic ComplexRoots(m :: PGGGloMod_Factors, embs :: [Map]) -> []
  {"}
  rsss := [ComplexRoots(fac, embs) : fac in m`factors];
  return [&cat[rss[i] : rss in rsss] : i in [1..#embs]];
end intrinsic;

intrinsic ComplexRoots(m :: PGGGloMod_Tower, embs :: [Map]) -> []
  {"}
  es := embs;
  for m2 in m`tower do
    es := ComplexEmbeddings(m2, es);
  end for;
  d := Degree(m`tower[#m`tower]`local_field, BaseRing(m`tower[1]`local_pol));
  assert #es eq #embs * d;
  // todo: also find complex roots of the global_pol, which should be more accurate but unordered, and pair them up
  return [[e(m`global_pol_root) : e in es[1+d*(i-1)..d*i]] : i in [1..#embs]];
end intrinsic;

intrinsic ComplexRoots(s :: PGGAlgState_ResEval_Global, pr :: RngIntElt) -> []
  {A sequence of complex roots, one for each embedding of the base field.}
  C := ComplexField(pr);
  if pr gt s`precision then
    vprint PGG_GaloisGroup: "complex precision =", pr;
    s`complex_roots := ComplexRoots(s`pol_model, ComplexEmbeddings(s`base_field_model, [map<Q -> C | x :-> C!x>]));
    s`precision := pr;
  end if;
  return PowerSequence(PowerSequence(C)) ! s`complex_roots;
end intrinsic;

intrinsic Resolvent(s :: PGGAlgState_ResEval_Global, I, U :: GrpPerm) -> RngUPolElt
  {The resolvent associated to the invariant I.}
  W := Overgroup(s);
  assert U subset W;
  ntries := 0;
  while true do
    ntries +:= 1;
    trans := tschirnhaus_transformation(ntries, Index(W, U));
    rss0 := ComplexRoots(s, 30);
    trss0 := [[Evaluate(trans, r) : r in rs] : rs in rss0];
    rbound := Max([Abs(r) : r in rs, rs in trss0]);
    pr := Ceiling(Log(10, slpol_bound(I, rbound)) * Index(W, U) * 2 + 30);
    rss := ComplexRoots(s, pr);
    trss := [[Evaluate(trans, r) : r in rs] : rs in rss];
    Rxrss := [[Evaluate(I, permute_seq(g, rs)) : g in left_coset_representatives(W, U)] : rs in trss];
    Rxs := [polynomial_with_roots(rs) : rs in Rxrss];
    if #Rxs eq 1 then
      R := Polynomial([Round(Real(c)) : c in Coefficients(Rxs[1])]);
      err := Max([Abs(c) : c in Coefficients(R - Rxs[1])] cat [0]);
      assert err lt 1e-20;
      if IsSquarefree(R) then
        return ChangeRing(R, BaseField(s`conjugacy));
      end if;
    else
      not_implemented("only implemented over Q");
    end if;
  end while;
end intrinsic;

intrinsic PGGAlg_Conjugacy_Symmetric_Make( : GaloisGroupAlg:=false) -> PGGAlg_Conjugacy_Symmetric
  {The "Symmetric" conjugacy algorithm.}
  alg := New(PGGAlg_Conjugacy_Symmetric);
  if GaloisGroupAlg cmpne false then
    alg`galois_group_alg := GaloisGroupAlg;
  end if;
  return alg;
end intrinsic;

intrinsic PGGAlg_Conjugacy_Factors_Make(:Next:=false) -> PGGAlg_Conjugacy_Factors
  {The "Factors" conjugacy algorithm.}
  a := New(PGGAlg_Conjugacy_Factors);
  a`next := Next cmpne false select Next else PGGAlg_Conjugacy_Symmetric_Make();
  return a;
end intrinsic;

intrinsic PGGAlg_Conjugacy_RamTower_Make(:Next:=false) -> PGGAlg_Conjugacy_RamTower
  {The "RamTower" conjugacy algorithm.}
  a := New(PGGAlg_Conjugacy_RamTower);
  a`next := Next cmpne false select Next else PGGAlg_Conjugacy_Symmetric_Make();
  return a;
end intrinsic;

intrinsic Conjugacy(alg :: PGGAlg_Conjugacy_Symmetric, f :: RngUPolElt[FldPad] : TopField:=false, IsTransitive:=false, KnownGroup:=false) -> PGGConj
  {Gets the conjugacy.}
  c := New(PGGConj_Symmetric);
  c`group := SymmetricGroup(Degree(f));
  c`base_field := BaseRing(f);
  c`pol := f;
  if TopField cmpne false then
    c`top_field := TopField;
  end if;
  if KnownGroup cmpne false then
    assert KnownGroup subset c`group;
    c`is_known := [* true, KnownGroup *];
  elif Degree(c) eq 1 then
    c`is_known := [* true, c`group *];
  elif assigned alg`galois_group_alg then
    c`is_known := [* true, GaloisGroup(alg`galois_group_alg, f) *];
  else
    c`is_known := [* false *];
  end if;
  c`is_transitive := IsTransitive or Degree(c) eq 1;
  return c;
end intrinsic;

intrinsic Conjugacy(alg :: PGGAlg_Conjugacy_Factors, f :: RngUPolElt[FldPad] : IsTransitive:=false) -> PGGConj
  {"}
  facs := factorization(f);
  assert #facs le 1 or not IsTransitive;
  c := New(PGGConj_Factors);
  c`factors := [Conjugacy(alg`next, fac : IsTransitive) : fac in facs];
  c`group := DirectProduct([cc`group : cc in c`factors]);
  c`base_field := BaseRing(f);
  offset := 0;
  for i in [1..#c`factors] do
    cc := c`factors[i];
    d := Degree(cc);
    cc`parent_subgroup := c`group;
    cc`parent_quotient := OrbitAction(c`group, [offset+1..offset+d]);
    offset +:= d;
  end for;
  assert Degree(c) eq offset;
  return c;
end intrinsic;

intrinsic Conjugacy(alg :: PGGAlg_Conjugacy_RamTower, f :: RngUPolElt[FldPad] : IsTransitive:=false) -> PGGConj
  {"}
  facs, certs := factorization(f : Extensions);
  assert #facs eq 1;
  t := ramification_tower(certs[1]`Extension, BaseRing(f));
  c := New(PGGConj_Tower);
  c`pol := f;
  c`tower := [Conjugacy(alg`next, DefiningPolynomial(t[i]) : IsTransitive, TopField:=t[i]) : i in [2..#t]];
  c`group := WreathProduct([cc`group : cc in Reverse(c`tower)]);
  c`base_field := BaseRing(f);
  degree := 1;
  for i in [#c`tower..1 by -1] do
    cc := c`tower[i];
    d := Degree(cc);
    cc`parent_subgroup := Stabilizer(c`group, {1..degree*d});
    oact := OrbitAction(cc`parent_subgroup, [1..degree*d]);
    bact := BlocksAction(Codomain(oact), [{(i-1)*degree+j : j in [1..degree]} : i in [1..d]]);
    cc`parent_quotient := oact * bact;
    degree *:= d;
  end for;
  assert Degree(c) eq degree;
  return c;
end intrinsic;

intrinsic EasyResolvents(conj :: PGGConj_Symmetric) -> []
  {Some trivial resolvents based on the initial presentation of the problem.}
  return [<conj`pol, Stabilizer(conj`group, 1)>];
end intrinsic;

intrinsic EasyResolvents(conj :: PGGConj_Factors) -> []
  {Some trivial resolvents based on the initial presentation of the problem.}
  // TODO: resolvents corresponding to each factor, and the whole polynomial?
  not_implemented("easy resolvents: factors");
end intrinsic;

intrinsic EasyResolvents(conj :: PGGConj_Tower) -> []
  {Some trivial resolvents based on the initial presentation of the problem.}
  // TODO: more resolvents corresponding to pieces of the tower?
  return [<conj`pol, Stabilizer(conj`group, 1)>];
end intrinsic;

intrinsic OrbitsOfSubgroups(conj :: PGGConj, n :: RngIntElt) -> []
  {All possible orbit systems of subgroups of conj`overgroup of index n, up to conjugacy.}
  require n ge 1: "n must be positive";
  if not IsDivisibleBy(#conj`group, n) then
    return [];
  end if;
  if not assigned conj`orbits_of_subgroups then
    conj`orbits_of_subgroups := AssociativeArray();
  end if;
  if not IsDefined(conj`orbits_of_subgroups, n) then
    conj`orbits_of_subgroups[n] := _OrbitsOfSubgroups(conj, n);
  end if;
  return conj`orbits_of_subgroups[n];
end intrinsic;

intrinsic _OrbitsOfSubgroups(conj :: PGGConj_Symmetric, n :: RngIntElt) -> []
  {"}
  // absolutely any partition of d corresponds to an orbit system for S_d: for such a partition, consider an element whose cycles are this partition, its orbits are precisely the partition.
  // what is the index of a partition? given partition P=[X_1,...,X_k] with |X_i|=d_i (so sum_i d_i = d) then Stab(P) = prod_i S_(d_i) has order prod_i d_i!, so index d!/prod_i d_i! = multinomial(d; d_1,...,d_k).
  todo := [<[Z|], Degree(conj), Degree(conj), n>];
  ret := [];
  while #todo gt 0 do
    // get an item from the todo list
    pop_start(~item, ~todo);
    partial, degree, limit, index := Explode(item);
    // are we done?
    if degree eq 0 then
      // are we valid?
      if index eq 1 then
        Append(~ret, [{d+1..d+partial[i]} where d:=&+partial[1..i-1] : i in [1..#partial]]);
      end if;
      continue;
    end if;
    // if not, choose a new element to add to the partition
    // we consider d and degree-d and the same time
    for d in [0..degree div 2] do
      if d gt limit then
        break;
      end if;
      x := Binomial(degree, d);
      if x gt index then
        break;
      end if;
      ok, y := IsDivisibleBy(index, x);
      if ok then
        dd := degree - d;
        if d gt 0 then
          Append(~todo, <Append(partial, d), dd, d, y>);
        end if;
        if dd le limit and dd ne d then
          Append(~todo, <Append(partial, dd), d, dd, y>);
        end if;
      end if;
    end for;
  end while;
  return ret;
end intrinsic;

intrinsic _OrbitsOfSubgroups(conj :: PGGConj_Tower, n :: RngIntElt) -> []
  {"}
  return _OrbitsOfSubgroups(conj, n, 1);
end intrinsic;

// given a sequence ns of integers and an integer m, finds all the sequences of integers cs so that sum_i cs_i * ns_i = m
function dot_product_inverse(ns, m)
  todo := [<[Z|], m>];
  ret := [PowerSequence(Z)|];
  while #todo gt 0 do
    pop_start(~item, ~todo);
    partial, target := Explode(item);
    // done?
    if #partial eq #ns then
      if target eq 0 then
        Append(~ret, partial);
      end if;
      continue;
    end if;
    // loop over possible next coefficients
    n := ns[#partial+1];
    for c in [0..target div n] do
      Append(~todo, <Append(partial, c), target - c*n>);
    end for;
  end while;
  return ret;
end function;

function factorizations_of_length(N, n : Max:=N)
  if n eq 0 then
    error if N ne 1, "impossible";
    return [];
  elif n eq 1 then
    return N le Max select [[N]] else [];
  else
    assert n gt 1;
    return &cat[PowerSequence(PowerSequence(Z))| [Append(facs, d) : facs in factorizations_of_length(xdiv(N, d), n-1 : Max:=d)] : d in Divisors(N) | d le Max];
  end if;
end function;

intrinsic _OrbitsOfSubgroups(conj :: PGGConj_Tower, n :: RngIntElt, m :: RngIntElt) -> []
  {"}
  assert m ge 1 and m le #conj`tower;
  if not assigned conj`orbits_of_subgroups_above then
    conj`orbits_of_subgroups_above := AssociativeArray();
  end if;
  if not IsDefined(conj`orbits_of_subgroups_above, <n,m>) then
    if m eq #conj`tower then
      ans := OrbitsOfSubgroups(conj`tower[m], n);
    elif Degree(conj`tower[m]) eq 1 then
      ans := _OrbitsOfSubgroups(conj, n, m+1);
    elif Degree(conj`tower[m]) eq 2 then
      upper_deg := &*[Z| Degree(conj`tower[i]) : i in [m+1..#conj`tower]];
      ans := [];
      case #conj`tower[m]`group:
      when 1:
        for n1 in Divisors(n) do
          n2 := xdiv(n, n1);
          if n2 lt n1 then 
            break;
          elif n2 eq n1 then
            oss := _OrbitsOfSubgroups(conj, n1, m+1);
            ans cat:= [[{x : x in o} : o in os1] cat [{x+upper_deg : x in o} : o in os2] where os1:=oss[i] where os2:=oss[j] : j in [i+1..#oss], i in [1..#oss]];
          else
            oss1 := _OrbitsOfSubgroups(conj, n1, m+1);
            oss2 := _OrbitsOfSubgroups(conj, n2, m+1);
            ans cat:= [[{x : x in o} : o in os1] cat [{x+upper_deg : x in o} : o in os2] : os1 in oss1, os2 in oss2];
          end if;
        end for;
      when 2:
        ok, nrest := IsDivisibleBy(n, 2);
        if ok then
          for n1 in Divisors(nrest) do
            n2 := xdiv(nrest, n1);
            if n2 lt n1 then
              break;
            elif n2 eq n1 then
              oss := _OrbitsOfSubgroups(conj, n1, m+1);
              ans cat:= [[{x : x in o} : o in os1] cat [{x+upper_deg : x in o} : o in os2] where os1:=oss[i] where os2:=oss[j] : j in [i..#oss], i in [1..#oss]];
            else
              oss1 := _OrbitsOfSubgroups(conj, n1, m+1);
              oss2 := _OrbitsOfSubgroups(conj, n2, m+1);
              ans cat:= [[{x : x in o} : o in os1] cat [{x+upper_deg : x in o} : o in os2] : os1 in oss1, os2 in oss2];
            end if;
          end for;
        end if;
        ok, nrest := IsSquare(n);
        if ok then
          oss := _OrbitsOfSubgroups(conj, nrest, m+1);
          ans cat:= [[{x : x in o} join {x+upper_deg : x in o} : o in os] : os in oss];
        end if;
      else
        assert false;
      end case;
    else
      // TODO: implement this in general
      //       this is quite tricky if we want to avoid conjugate answers:
      //       - first find orbits for the base group
      //       - group these by conjugacy
      //       - distribute a factorization of the remaining index over the conjugacy classes
      //       - then distribute over each orbit in each class, but with an ordering enforced
      //       - group orbits in each class further by the index they just received
      //       - find orbits for each of these indices
      //       - distribute these over each class, but with an ordering enforced
      //       - take the product of all these choices
      //       maybe it's worth changing the return value of OrbitsOfSubgroups to group the orbits by conjugacy
      not_implemented("OrbitsOfSubgroups");
    end if;
    conj`orbits_of_subgroups_above[<n,m>] := ans;
  end if;
  return conj`orbits_of_subgroups_above[<n,m>];
end intrinsic;

intrinsic Print(conj :: PGGConj)
  {"}
  _Print(conj);
  ok, G := IsKnown(conj);
  if ok then
    if G eq Group(conj) then
      printf " exactly";
    else
      printf " actually %o", GroupName(G);
    end if;
  else
    if IsTransitive(conj) then
      printf " transitive";
    end if;
    if Overgroup(conj) ne Group(conj) then
      printf " subgroup of %o", GroupName(Overgroup(conj));
    end if;
  end if;
end intrinsic;

intrinsic _Print(conj :: PGGConj_Symmetric)
  {"}
  printf "Symmetric(%o)", Degree(conj);
end intrinsic;

intrinsic _Print(conj :: PGGConj_Factors)
  {"}
  printf "Factors(%o)", Join([Sprintf("%o", c) : c in conj`factors], ", ");
end intrinsic;

intrinsic _Print(conj :: PGGConj_Tower)
  {"}
  printf "Tower(%o)", Join([Sprintf("%o", c) : c in conj`tower], ", ");
end intrinsic;

intrinsic Group(conj :: PGGConj) -> GrpPerm
  {The group.}
  return conj`group;
end intrinsic;

intrinsic BaseField(conj :: PGGConj) -> FldPad
  {The base field.}
  return conj`base_field;
end intrinsic;

intrinsic Degree(conj :: PGGConj) -> RngIntElt
  {The degree of the group.}
  return Degree(conj`group);
end intrinsic;

intrinsic Overgroup(conj :: PGGConj) -> GrpPerm
  {An overgroup of the Galois group.}
  if not assigned conj`overgroup then
    ok, G := IsKnown(conj);
    if not ok then
      G := _Overgroup(conj);
    end if;
    assert G subset conj`group;
    conj`overgroup := G;
  end if;
  return conj`overgroup;
end intrinsic;

intrinsic _Overgroup(conj :: PGGConj_Symmetric) -> GrpPerm
  {"}
  return Group(conj);
end intrinsic;

intrinsic _Overgroup(conj :: PGGConj_Factors) -> GrpPerm
  {"}
  return DirectProduct([Overgroup(c) : c in conj`factors]);
end intrinsic;

intrinsic _Overgroup(conj :: PGGConj_Tower) -> GrpPerm
  {"}
  return WreathProduct([Overgroup(c) : c in Reverse(conj`tower)]);
end intrinsic;

intrinsic IsTransitive(conj :: PGGConj) -> BoolElt
  {True if the Galois group is known to be transitive on this part of the group.}
  if not assigned conj`is_transitive then
    conj`is_transitive := _IsTransitive(conj);
  end if;
  return conj`is_transitive;
end intrinsic;

intrinsic _IsTransitive(conj :: PGGConj_Factors) -> BoolElt
  {"}
  return #conj`factors le 1 and forall{c : c in conj`factors | IsTransitive(conj`factors[1])};
end intrinsic;

intrinsic _IsTransitive(conj :: PGGConj_Tower) -> BoolElt
  {"}
  assert forall{c : c in conj`tower | IsTransitive(c)};
  return true;
end intrinsic;

intrinsic IsConsistent(conj :: PGGConj, G :: GrpPerm) -> BoolElt
  {True if G could be the Galois group.}
  ok, G2 := IsKnown(conj);
  if ok then
    return IsConjugate(conj`group, G, G2);
  else
    return _IsConsistent(conj, G);
  end if;
end intrinsic;

intrinsic _IsConsistent(conj :: PGGConj_Symmetric, G :: GrpPerm) -> BoolElt
  {True if G could be the Galois group.}
  return (not IsTransitive(conj)) or IsTransitive(G);
end intrinsic;

intrinsic _IsConsistent(conj :: PGGConj_Factors, G :: GrpPerm) -> BoolElt
  {"}
  return forall{c : c in conj`factors | IsConsistent(c, c`parent_quotient(G meet c`parent_subgroup))};
end intrinsic;

intrinsic _IsConsistent(conj :: PGGConj_Tower, G :: GrpPerm) -> BoolElt
  {"}
  return forall{c : c in conj`tower | IsConsistent(c, c`parent_quotient(G meet c`parent_subgroup))};
end intrinsic;

intrinsic IsKnown(conj :: PGGConj) -> BoolElt, GrpPerm
  {True if the Galois group is known exactly, and the group.}
  if not assigned conj`is_known then
    ok, G := _IsKnown(conj);
    if ok then
      assert G subset conj`group;
      conj`is_known := [* true, G *];
    else
      conj`is_known := [* false *];
    end if;
  end if;
  if conj`is_known[1] then
    return true, conj`is_known[2];
  else
    return false, _;
  end if;
end intrinsic;

intrinsic _IsKnown(conj :: PGGConj_Factors) -> BoolElt, GrpPerm
  {"}
  if #[c : c in conj`factors | Degree(c) gt 1] le 1 then
    Gs := [];
    for c in conj`factors do
      ok, G := IsKnown(c);
      if ok then
        Append(~Gs, G);
      else
        return false, _;
      end if;
    end for;
    return true, DirectProduct(Gs);
  else
    return false, _;
  end if;
end intrinsic;

intrinsic _IsKnown(conj :: PGGConj_Tower) -> BoolElt, GrpPerm
  {"}
  if #[c : c in conj`tower | Degree(c) gt 1] le 1 then
    Gs := [];
    for c in conj`tower do
      ok, G := IsKnown(c);
      if ok then
        Append(~Gs, G);
      else
        return false, _;
      end if;
    end for;
    return true, WreathProduct(Reverse(Gs));
  else
    return false, _;
  end if;
end intrinsic;

intrinsic PGGAlg_ResGroups_All_Make(:Statistic:=false, SubgroupTranche:=false, SubgroupOrder:=false, SubgroupScore:=false, SubgroupChoice:=false) -> PGGAlg_ResGroups_All
  {The "All" resolvent groups algorithm.}
  alg := New(PGGAlg_ResGroups_All);
  alg`statistic := Statistic cmpne false select Statistic else PGGStat_FactorDegrees_Make();
  alg`subgroup_tranche := SubgroupTranche cmpne false select SubgroupTranche else "Index";
  alg`subgroup_order := SubgroupOrder cmpne false select SubgroupOrder else PGGOrder_Key_Index_Make();
  alg`subgroup_score := SubgroupScore cmpne false select SubgroupScore else "Information";
  alg`subgroup_choice := SubgroupChoice cmpne false select SubgroupChoice else "Best";
  return alg;
end intrinsic;

intrinsic PGGAlg_ResEval_Global_Make() -> PGGAlg_ResEval_Global
  {The "Absolute" resolvent evaluation algorithm.}
  alg := New(PGGAlg_ResEval_Global);
  return alg;
end intrinsic;

intrinsic PGGAlg_GaloisGroup_ResolventMethod_Make( : GroupsAlg:=false, ResolventAlg:=false, ConjugacyAlg:=false, UseEasyResolvents:=false) -> PGGAlg_GaloisGroup_ResolventMethod
  {The resolvent method algorithm for computing Galois groups.}
  alg := New(PGGAlg_GaloisGroup_ResolventMethod);
  alg`groups_alg := GroupsAlg cmpne false select GroupsAlg else PGGAlg_ResGroups_All_Make();
  alg`resolvent_alg := ResolventAlg cmpne false select ResolventAlg else PGGAlg_ResEval_Global_Make();
  alg`conjugacy_alg := ConjugacyAlg cmpne false select ConjugacyAlg else PGGAlg_Conjugacy_Factors_Make(:Next:=PGGAlg_Conjugacy_RamTower_Make());
  alg`use_easy_resolvents := UseEasyResolvents;
  return alg;
end intrinsic;

intrinsic PGGAlg_GaloisGroup_Builtin_Make() -> PGGAlg_GaloisGroup_Builtin
  {Calls Magma's builtin GaloisGroup intrinsic, which currently computes a splitting field explicitly.}
  alg := New(PGGAlg_GaloisGroup_Builtin);
  return alg;
end intrinsic;

intrinsic PGGAlg_GaloisGroup_SinglyRamified_Make() -> PGGAlg_GaloisGroup_SinglyRamified
  {A direct algorithm for singly ramified extensions.}
  alg := New(PGGAlg_GaloisGroup_SinglyRamified);
  return alg;
end intrinsic;

intrinsic GaloisGroup(Alg :: PGGAlg_GaloisGroup_ResolventMethod, f :: RngUPolElt[FldPad]) -> GrpPerm
  {The Galois group of f.}
  vprint PGG_GaloisGroup: "ResolventMethod...";
  t := PGG_Timer();
  Push(t, "conjugacy");
  conj := Conjugacy(Alg`conjugacy_alg, f);
  vprint PGG_GaloisGroup: "conjugacy =", conj;
  Swap(t, "start resolvent");
  rst := Start(Alg`resolvent_alg, conj);
  Swap(t, "overgroup");
  W := Overgroup(rst);
  vprint PGG_GaloisGroup: "overgroup =", W;
  Swap(t, "start groups");
  gst := Start(Alg`groups_alg, conj, W);
  if Alg`use_easy_resolvents then
    vprint PGG_GaloisGroup: "easy resolvents...";
    Swap(t, "easy resolvents");
    RUs := EasyResolvents(conj);
    for RU in RUs do
      if IsDone(gst) then
        break;
      end if;
      R, U := Explode(RU);
      Swap(t, "process resolvent");
      ProcessResolvent(gst, R, U);
    end for;
  end if;
  if not IsDone(gst) then
    vprint PGG_GaloisGroup: "main loop...";
    repeat
      Swap(t, "subgroup");
      U := Subgroup(gst);
      vprint PGG_GaloisGroup: "subgroup =", U;
      vprint PGG_GaloisGroup: "orbits =", Orbits(U);
      vprint PGG_GaloisGroup: "partitions =", [<o, AllPartitions(Uo) where Uo:=OrbitImage(U,o)> : o in Orbits(U)];
      vprint PGG_GaloisGroup: "subgroup index =", Index(W, U);
      Swap(t, "invariant");
      I := RelativeInvariant(W, U);
      vprint PGG_GaloisGroup: "invariant =", I;
      Swap(t, "resolvent");
      R := Resolvent(rst, I, U);
      vprint PGG_GaloisGroup: "resolvent =", R;
      Swap(t, "process resolvent");
      ProcessResolvent(gst, R, U);
    until IsDone(gst);
  end if;
  vprint PGG_GaloisGroup: "success";
  Pop(t);
  if GetVerbose("PGG_GaloisGroup") gt 0 then
    PrintTree(t);
  end if;
  return TheGroup(gst);
end intrinsic;

intrinsic GaloisGroup(alg :: PGGAlg_GaloisGroup_Builtin, f :: RngUPolElt[FldPad]) -> GrpPerm
  {"}
  G := GaloisGroup(f);
  return G;
end intrinsic;

// some example polynomials to try this on:
// Example 9.* from Greve, Pauli "On ramification polygons..."
// Example 3.24 from Milstead "Computing Galois groups..." (thesis)
intrinsic GaloisGroup(alg :: PGGAlg_GaloisGroup_SinglyRamified, f :: RngUPolElt[FldPad]) -> GrpPerm
  {"}
  // check f is irreducible and find the extension it defines
  d := Degree(f);
  facs, certs := factorization(f : Extensions);
  error if #facs ne 1, "only implemented for irreducible f";
  K := BaseRing(f);
  cert := certs[1];
  L := cert`Extension;
  assert Degree(L, K) eq d;
  assert cert`E * cert`F eq d;

  // special case: unramified
  if cert`E eq 1 then
    return CyclicGroup(GrpPerm, cert`F);
  elif cert`F ne 1 then
    error "f must define a singly ramified extension";
  end if;

  // special case: totally tamely ramified
  p := Prime(K);
  Qp := PrimeField(K);
  q := p^InertiaDegree(K, Qp);
  if not IsDivisibleBy(d, p) then
    // the inertia degree of the Galois closure, i.e. the degree of K(zeta_d)/K
    F := Min([F : F in [1..d] | IsDivisibleBy(q^F-1, d)]);
    S := SymmetricGroup(d);
    gen1 := S![(i mod d)+1 : i in [1..d]];
    gen2 := S![(((i-1)*q) mod d) + 1 : i in [1..d]];
    return sub<S | gen1, gen2>;
  end if;

  // check we are totally wildly ramified
  ok, m := IsPowerOf(d, p);
  error if not ok, "f must define a singly ramified extension";
  // compute the ramification polynomial and polygon
  phi := DefiningPolynomial(L);
  assert BaseRing(phi) eq K;
  assert is_eisenstein(phi);
  x := PolynomialRing(L).1;
  pi := L.1;
  assert IsWeaklyZero(Evaluate(phi, pi));
  r := Evaluate(phi, x+pi) div x;
  assert Degree(r) eq d-1;
  rp := NewtonPolygon([<i,Valuation(Coefficient(r, i))> : i in [0..d-1]] : Faces:="Lower");
  vs := ChangeUniverse(Vertices(rp), car<Z,Z>);
  assert vs[1][1] eq 0;
  assert vs[#vs][1] eq d-1;
  assert forall{v : v in vs | not IsWeaklyZero(Coefficient(r, v[1]))};
  assert forall{v : v in vs | IsPowerOf(v[1]+1, p)};
  error if #vs ne 2, "f must define a singly ramified extension";
  // now compute the galois group
  // this is an implementation of Algorithm 3.23 of Milstead's thesis.
  // we try to keep the notation and step numbers of the description
  // step 1
  slope := (vs[2][2] - vs[1][2])/(vs[2][1] - vs[1][1]);
  h := Numerator(-slope);
  e := Denominator(-slope);
  ok, d0 := IsDivisibleBy(d-1, e);
  assert ok;
  // step 2
  Fq, LtoFq:=ResidueClassField(Integers(L));
  assert #Fq eq q;
  A := Polynomial([ShiftValuation(Coefficient(r, i*e), i*h - vs[1][2]) @ LtoFq : i in [0..d0]]);
  assert Degree(A) eq d0;
  assert Coefficient(A, 0) ne 0;
  assert Coefficient(A, d0) ne 0;
  // steps 3 and 4 and 6
  FqF := SplittingField(A * (Parent(A).1^e - 1));
  zeta := PrimitiveElement(FqF);
  F := Degree(FqF, Fq);
  assert #FqF eq q^F;
  // step 5
  g, a, a2 := XGCD(e, -p^m);
  assert g eq 1;
  g, b, b2 := XGCD(h, -e);
  assert g eq 1;
  // step 7
  us := [x[1] : x in Roots(ChangeRing(A, FqF))];
  assert #us eq d0;
  // steps 8 and 9
  r := Log(zeta, us[1]^b) mod e;
  // steps 10 and 11 (V is the additive group of FqF)
  V, FqFtoV := VectorSpace(FqF, GF(p));
  generators := [V | FqFtoV(0)];
  M := sub<V | generators>;
  assert #M eq 1;
  assert Dimension(M) eq 0;
  for i in [1..d0] do
    roots := [x[1] : x in Roots(PolynomialRing(FqF).1^e - us[i]/zeta^(r*h))];
    assert #roots eq e;
    generators cat:= [V | FqFtoV(a*x) : x in roots];
    M := sub<V | generators>;
    assert #M eq p^Dimension(M);
    // if #M eq p^m then
    //   break;
    // end if;
  end for;
  assert #M eq p^m;
  assert Dimension(M) eq m;
  // step 12
  assert BaseField(M) eq GF(p);
  B := Basis(M);
  assert #B eq m;
  assert Universe(B) eq M;
  // step 13
  ok, ell := IsDivisibleBy(q^F-1, e);
  assert ok;
  ok, k := IsDivisibleBy(r*(q-1), e);
  assert ok;
  // steps 14, 15, 16, 17
  // the following line works around a bug in Magma: it refuses to compute AGL(GrpMat,1,GF(p))
  AGLmp := m eq 1 select sub<G | [G| [[M[1,1], 0],[0,1]] : M in Generators(GL(1,GF(p)))] cat [G![[1,0],[1,1]]]> where G:=GL(2,GF(p)) else AGL(GrpMat, m, GF(p));
  S := AGLmp ! ([Coordinates(M, b2) cat [0] where b2 := M ! ((zeta^j2) @ FqFtoV) where j2 := ell*h+j where j := Log(zeta, (V ! b) @@ FqFtoV) : b in B] cat [[i eq m+1 select 1 else 0 : i in [1..m+1]]]);
  T := AGLmp ! ([Coordinates(M, b2) cat [0] where b2 := M ! ((zeta^j2) @ FqFtoV) where j2 := k*h+q*j where j := Log(zeta, (V ! b) @@ FqFtoV) : b in B] cat [[i eq m+1 select 1 else 0 : i in [1..m+1]]]);
  // print S, T, GroupName(sub<AGLmp | [S, T]>);
  // step 18
  G := sub<AGLmp | [S, T] cat [AGLmp | [[i eq j select 1 else i eq m+1 and j eq a select 1 else 0 : j in [1..m+1]] : i in [1..m+1]] : a in [1..m]]>;
  // convert G to a permutation group
  Gperm := OrbitImage(G, {@ Vector([x : x in v]) : v in CartesianProduct([[x : x in GF(p)] : i in [1..m]] cat [[GF(p) ! 1]]) @});
  return Gperm;
end intrinsic;

function parse_algorithm(alg)

  specs := PGG_ArgSpec_ManyRecursive(procedure (set, get)

    BOOL := PGG_ArgSpec_Union([
      PGG_ArgSpec_Attr("True", [], func<args | true>),
      PGG_ArgSpec_Attr("False", [], func<args | false>)
    ]);

    CONJUGACY := set("CONJUGACY", PGG_ArgSpec_Union([
      PGG_ArgSpec_ISA(PGGAlg_Conjugacy),
      PGG_ArgSpec_Literal(false),
      PGG_ArgSpec_Attr(
        "Symmetric",
        [<get("GALOISGROUP"),"GG",false>],
        func<args | PGGAlg_Conjugacy_Symmetric_Make(:GaloisGroupAlg:=args[1])>
      ),
      PGG_ArgSpec_Attr(
        "Factors",
        [<get("CONJUGACY"),"Next",false>],
        func<args | PGGAlg_Conjugacy_Factors_Make(:Next:=args[1])>
      ),
      PGG_ArgSpec_Attr(
        "RamTower",
        [<get("CONJUGACY"),"Next",false>],
        func<args | PGGAlg_Conjugacy_RamTower_Make(:Next:=args[1])>
      )
    ]));

    STATISTIC := set("STATISTIC", PGG_ArgSpec_Union([
      PGG_ArgSpec_ISA(PGGStat),
      PGG_ArgSpec_Literal(false),
      PGG_ArgSpec_Attr("HasRoot", [], func<args | PGGStat_HasRoot_Make()>),
      PGG_ArgSpec_Attr("NumRoots", [], func<args | PGGStat_NumRoots_Make()>),
      PGG_ArgSpec_Attr("FactorDegrees", [], func<args | PGGStat_FactorDegrees_Make()>),
      PGG_ArgSpec_Attr("FactorDegrees2", [], func<args | PGGStat_FactorDegrees2_Make()>),
      PGG_ArgSpec_Attr("Degree", [], func<args | PGGStat_Degree_Make()>),
      PGG_ArgSpec_Attr("AutGroup", [], func<args | PGGStat_AutGroup_Make()>),
      PGG_ArgSpec_AttrList("Tup", get("STATISTIC"), func<args | PGGStat_Tup_Make(args)>),
      PGG_ArgSpec_Attr("Factors", [<get("STATISTIC"), "Stat", false>], func<args | PGGStat_Factors_Make(:Stat:=args[1])>)
    ]));

    SUBGROUP_TRANCHE := PGG_ArgSpec_Union([
      PGG_ArgSpec_Literal(false),
      PGG_ArgSpec_Attr("All"),
      PGG_ArgSpec_Attr("Index"),
      PGG_ArgSpec_Attr("MostUseful")
    ]);

    SUBGROUP_ORDER := set("SUBGROUP_ORDER", PGG_ArgSpec_Union([
      PGG_ArgSpec_ISA(PGGOrder),
      PGG_ArgSpec_Literal(false),
      PGG_ArgSpec_Attr("None", [], func<args | PGGOrder_None_Make()>),
      PGG_ArgSpec_Attr("Random", [], func<args | PGGOrder_Random_Make()>),
      PGG_ArgSpec_Attr("Reverse", [<get("SUBGROUP_ORDER"), "Order">], func<args | PGGOrder_Reverse_Make(args[1])>),
      PGG_ArgSpec_Attr("Index", [], func<args | PGGOrder_Key_Index_Make()>),
      PGG_ArgSpec_Attr("OrbitIndex", [], func<args | PGGOrder_Key_OrbitIndex_Make()>)
    ]));

    SUBGROUP_SCORE := PGG_ArgSpec_Union([
      PGG_ArgSpec_Literal(false),
      PGG_ArgSpec_Attr("IsUseful"),
      PGG_ArgSpec_Attr("Diversity"),
      PGG_ArgSpec_Attr("Information")
    ]);

    SUBGROUP_CHOICE := PGG_ArgSpec_Union([
      PGG_ArgSpec_Literal(false),
      PGG_ArgSpec_Attr("First"),
      PGG_ArgSpec_Attr("Best")
    ]);

    RESGROUPS := PGG_ArgSpec_Union([
      PGG_ArgSpec_ISA(PGGAlg_ResGroups),
      PGG_ArgSpec_Literal(false),
      PGG_ArgSpec_Attr(
        "All",
        [ <STATISTIC,"Stat",false>
        , <SUBGROUP_TRANCHE,"Tranche",false>
        , <SUBGROUP_ORDER,"Order",false>
        , <SUBGROUP_SCORE,"Score",false>
        , <SUBGROUP_CHOICE,"Choice",false>
        ],
        func<args | PGGAlg_ResGroups_All_Make(:Statistic:=args[1], SubgroupTranche:=args[2], SubgroupOrder:=args[3], SubgroupScore:=args[4], SubgroupChoice:=args[5])>
      )
    ]);

    RESEVAL := PGG_ArgSpec_Union([
      PGG_ArgSpec_ISA(PGGAlg_ResEval),
      PGG_ArgSpec_Literal(false),
      PGG_ArgSpec_Attr(
        "Global",
        [],
        func<args | PGGAlg_ResEval_Global_Make()>
      )
    ]);

    GALOISGROUP := set("GALOISGROUP", PGG_ArgSpec_Union([
      PGG_ArgSpec_ISA(PGGAlg_GaloisGroup),
      PGG_ArgSpec_Literal(false),
      PGG_ArgSpec_Attr(
        "ARM",
        [ <RESGROUPS,"Groups",false>
        , <RESEVAL,"Eval",false>
        , <CONJUGACY,"Conj",false>
        , <BOOL,"UseEasyResolvents",false>
        ],
        func<args | PGGAlg_GaloisGroup_ResolventMethod_Make(:GroupsAlg:=args[1], ResolventAlg:=args[2], ConjugacyAlg:=args[3], UseEasyResolvents:=args[4])>
      ),
      PGG_ArgSpec_Attr(
        "Builtin",
        [],
        func<args | PGGAlg_GaloisGroup_Builtin_Make()>
      ),
      PGG_ArgSpec_Attr(
        "SinglyRamified",
        [],
        func<args | PGGAlg_GaloisGroup_SinglyRamified_Make()>
      )
    ]));
  end procedure);

  return PGG_Parse(specs("GALOISGROUP"), alg);
end function;

intrinsic PGG_GaloisGroup(f :: RngUPolElt[FldPad] : Alg:="ARM") -> GrpPerm
  {The Galois group of f.}
  alg := parse_algorithm(Alg);
  return GaloisGroup(alg, f);
end intrinsic;