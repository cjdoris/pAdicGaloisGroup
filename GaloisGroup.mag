// implementation of a general galois-group finding algorithm, general in the sense that the algorithms involved are written in a modular fashion so that each piece can be changed independently of the rest, as far as possible

import "Utils.mag": Q, Z, not_implemented;

declare verbose PGG_GaloisGroup, 1;

declare type PGGAlg;

declare type PGGAlgState;
declare attributes PGGAlgState: algorithm;

declare type PGGAlg_GaloisGroup: PGGAlg;

intrinsic GaloisGroup(alg :: PGGAlg_GaloisGroup, f :: RngUPolElt[FldPad]) -> GrpPerm
  {The Galois group of f.}
  return RamificationGroup(alg, f, Q!-1);
end intrinsic;

intrinsic InertiaGroup(alg :: PGGAlg_GaloisGroup, f :: RngUPolElt[FldPad]) -> GrpPerm
  {The inertia group of f.}
  return RamificationGroup(alg, f, Q!0);
end intrinsic;

intrinsic RamificationGroup(alg :: PGGAlg_GaloisGroup, f :: RngUPolElt[FldPad], u :: FldRatElt) -> GrpPerm
  {The u-th ramification group of f.}
  if u lt 0 then
    not_implemented("GaloisGroup");
  elif u lt 1 then
    not_implemented("InertiaGroup");
  else
    not_implemented("RamificationGroup");
  end if;
end intrinsic;

function parse_algorithm(alg)

  specs := PGG_ArgSpec_ManyRecursive(procedure (set, get)

    BOOL := PGG_ArgSpec_Union([
      PGG_ArgSpec_Attr("True", [], func<args | true>),
      PGG_ArgSpec_Attr("False", [], func<args | false>)
    ]);

    GLOBAL_MODEL := set("GLOBAL_MODEL", PGG_ArgSpec_Union([
      PGG_ArgSpec_ISA(PGGAlg_ResEval_Global_Model),
      PGG_ArgSpec_Literal(false),
      PGG_ArgSpec_Attr(
        "Symmetric",
        [<get("GALOISGROUP"),"GG",false>],
        func<args | PGGAlg_ResEval_Global_Model_Symmetric_Make(:GaloisGroupAlg:=args[1])>
      ),
      PGG_ArgSpec_Attr(
        "Factors",
        [<get("GLOBAL_MODEL"),"Next",false>],
        func<args | PGGAlg_ResEval_Global_Model_Factors_Make(:Next:=args[1])>
      ),
      PGG_ArgSpec_Attr(
        "RamTower",
        [<get("GLOBAL_MODEL"),"Next",false>],
        func<args | PGGAlg_ResEval_Global_Model_RamTower_Make(:Next:=args[1])>
      )
    ]));

    STATISTIC := set("STATISTIC", PGG_ArgSpec_Union([
      PGG_ArgSpec_ISA(PGGStat),
      PGG_ArgSpec_Literal(false),
      PGG_ArgSpec_Attr("HasRoot", [], func<args | PGGStat_HasRoot_Make()>),
      PGG_ArgSpec_Attr("NumRoots", [], func<args | PGGStat_NumRoots_Make()>),
      PGG_ArgSpec_Attr("FactorDegrees", [], func<args | PGGStat_FactorDegrees_Make()>),
      PGG_ArgSpec_Attr("FactorDegrees2", [], func<args | PGGStat_FactorDegrees2_Make()>),
      PGG_ArgSpec_Attr("Degree", [], func<args | PGGStat_Degree_Make()>),
      PGG_ArgSpec_Attr("AutGroup", [], func<args | PGGStat_AutGroup_Make()>),
      PGG_ArgSpec_AttrList("Tup", get("STATISTIC"), func<args | PGGStat_Tup_Make(args)>),
      PGG_ArgSpec_Attr("Factors", [<get("STATISTIC"), "Stat", false>], func<args | PGGStat_Factors_Make(:Stat:=args[1])>)
    ]));

    // SUBGROUP_TRANCHE := PGG_ArgSpec_Union([
    //   PGG_ArgSpec_Literal(false),
    //   PGG_ArgSpec_Attr("All"),
    //   PGG_ArgSpec_Attr("Index"),
    //   PGG_ArgSpec_Attr("OrbitIndex"),
    //   PGG_ArgSpec_Attr("MostUseful")
    // ]);

    // SUBGROUP_SCORE := PGG_ArgSpec_Union([
    //   PGG_ArgSpec_Literal(false),
    //   PGG_ArgSpec_Attr("IsUseful"),
    //   PGG_ArgSpec_Attr("Diversity"),
    //   PGG_ArgSpec_Attr("Information")
    // ]);

    // SUBGROUP_CHOICE := PGG_ArgSpec_Union([
    //   PGG_ArgSpec_Literal(false),
    //   PGG_ArgSpec_Attr("First"),
    //   PGG_ArgSpec_Attr("Best")
    // ]);

    // SUBGROUP_PRIORITY_EXPRESSION := PGG_ArgSpec_AttrExpr(["Index","OrbitIndex","Diversity","Information"]);

    EXPRESSION := func<vars | PGG_ArgSpec_Recursive(function (X)
      return PGG_ArgSpec_Union([
        PGG_ArgSpec_Attr(var, [], func<args | PGG_Expression_FreeVariable(var)>)
        : var in vars
      ] cat [
        PGG_ArgSpec_Attr("le", [<X>,<X>], func<args | PGG_Expression_BinOp('le', args[1], args[2])>),
        PGG_ArgSpec_Attr("lt", [<X>,<X>], func<args | PGG_Expression_BinOp('lt', args[1], args[2])>),
        PGG_ArgSpec_Attr("ge", [<X>,<X>], func<args | PGG_Expression_BinOp('ge', args[1], args[2])>),
        PGG_ArgSpec_Attr("gt", [<X>,<X>], func<args | PGG_Expression_BinOp('gt', args[1], args[2])>),
        PGG_ArgSpec_Attr("eq", [<X>,<X>], func<args | PGG_Expression_BinOp('eq', args[1], args[2])>),
        PGG_ArgSpec_Attr("ne", [<X>,<X>], func<args | PGG_Expression_BinOp('ne', args[1], args[2])>),
        PGG_ArgSpec_AttrList("and", X, func<args | PGG_Expression_SeqOp('&and', [x : x in args])>),
        PGG_ArgSpec_AttrList("or", X, func<args | PGG_Expression_SeqOp('&or', [x : x in args])>),
        PGG_ArgSpec_Attr("-", [<X>], func<args | PGG_Expression_UnOp('-', args[1])>),
        PGG_ArgSpec_Attr("-", [<X>,<X>], func<args | PGG_Expression_BinOp('-', args[1], args[2])>),
        PGG_ArgSpec_AttrList("+", X, func<args | PGG_Expression_SeqOp('&+', [x : x in args])>),
        PGG_ArgSpec_AttrList("*", X, func<args | PGG_Expression_SeqOp('&*', [x : x in args])>),
        PGG_ArgSpec_Transform(PGG_ArgSpec_AttrInt(), func<x | PGG_Expression_Const(x)>)
      ]);
    end function)>;

    SUBGROUP_PRIORITY := set("SUBGROUP_PRIORITY", PGG_ArgSpec_Union([
      PGG_ArgSpec_ISA(PGGAlg_ResPriority),
      PGG_ArgSpec_Literal(false),
      PGG_ArgSpec_Attr(
        "Null",
        [],
        func<args | PGGAlg_ResPriority_Null_Make()>
      ),
      PGG_ArgSpec_Attr(
        "Random",
        [],
        func<args | PGGAlg_ResPriority_Random_Make()>
      ),
      PGG_ArgSpec_Attr(
        "Reverse",
        [ <get("SUBGROUP_PRIORITY"),"Priority",false> ],
        func<args | PGGAlg_ResPriority_Reverse_Make(:Priority:=args[1])>
      ),
      // PGG_ArgSpec_Attr(
      //   "Filter",
      //   [ <SUBGROUP_PRIORITY_EXPRESSION,"Cond",false>,
      //     <get("SUBGROUP_PRIORITY"),"Priority",false>
      //   ],
      //   func<args | PGGAlg_ResPriority_Null_Make(:Expression:=args[1], Priority:=args[2])>
      // ),
      PGG_ArgSpec_Transform(EXPRESSION(["Index","OrbitIndex","Diversity","Information"]), func<x | PGGAlg_ResPriority_Key_Make(x)>)
    ]));

    SUBGROUP_TRANCHE := PGG_ArgSpec_Union([
      PGG_ArgSpec_ISA(PGGAlg_Tranche),
      PGG_ArgSpec_Literal(false),
      PGG_ArgSpec_Attr(
        "All",
        [ ],
        func<args | PGGAlg_Tranche_All_Make()>
      ),
      PGG_ArgSpec_Attr(
        "Index",
        [ <X,"If",false>, <X,"Sort",false> ] where X:=EXPRESSION(["idx"]),
        func<args | PGGAlg_Tranche_Index_Make(:Filter:=args[1], SortKey:=args[2])>
      ),
      PGG_ArgSpec_Attr(
        "OrbitIndex",
        [ <X,"If",false>, <X,"Sort",false> ] where X:=EXPRESSION(["idx","oidx","ridx"]),
        func<args | PGGAlg_Tranche_OrbitIndex_Make(:Filter:=args[1], SortKey:=args[2])>
      )
    ]);

    SUBGROUP_CHOICE := PGG_ArgSpec_Union([
      PGG_ArgSpec_ISA(PGGAlg_ResChoice),
      PGG_ArgSpec_Literal(false),
      PGG_ArgSpec_Transform(
        SUBGROUP_TRANCHE,
        func<t | PGGAlg_ResChoice_Tranche_Make(:Tranche:=t)>
      ),
      PGG_ArgSpec_Attr(
        "",
        [ <SUBGROUP_TRANCHE,"Tranche",false>, <SUBGROUP_PRIORITY,"Priority",false> ],
        func<args | PGGAlg_ResChoice_Tranche_Make(:Tranche:=args[1], Priority:=args[2])>
      )
    ]);

    RESGROUPS := PGG_ArgSpec_Union([
      PGG_ArgSpec_ISA(PGGAlg_ResGroups),
      PGG_ArgSpec_Literal(false),
      PGG_ArgSpec_Attr(
        "All",
        [ <STATISTIC,"Stat",false>
        , <SUBGROUP_CHOICE,"Choice",false>
        ],
        func<args | PGGAlg_ResGroups_All_Make(:Statistic:=args[1], SubgroupChoice:=args[2])>
      ),
      PGG_ArgSpec_Attr(
        "Maximal",
        [ <STATISTIC,"Stat",false>
        , <SUBGROUP_CHOICE,"Choice",false>
        , <PGG_ArgSpec_Union([
            PGG_ArgSpec_Literal(false),
            PGG_ArgSpec_Attr("Eager"),
            PGG_ArgSpec_Attr("Steady"),
            PGG_ArgSpec_Attr("Patient"),
            PGG_ArgSpec_Attr("Ask")
          ]), "Descend", false>
        , <PGG_ArgSpec_Union([
            PGG_ArgSpec_Literal(false),
            PGG_ArgSpec_Attr("Sufficient"),
            PGG_ArgSpec_Attr("Necessary"),
            PGG_ArgSpec_Attr("Generous"),
            PGG_ArgSpec_Attr("All")
          ]), "Useful", false>
        , <BOOL, "Reprocess", true>
        , <BOOL, "Reset", true>
        , <BOOL, "Blacklist", false>
        , <BOOL, "Dedupe", true>
        ],
        func<args | PGGAlg_ResGroups_Maximal_Make(:Statistic:=args[1], SubgroupChoice:=args[2], Descend:=args[3], Useful:=args[4], Reprocess:=args[5], Reset:=args[6], Blacklist:=args[7], Dedupe:=args[8])>
      ),
      PGG_ArgSpec_Attr(
        "RootsMaximal",
        [ <BOOL,"Dedupe",false> ],
        func<args | PGGAlg_ResGroups_RootsMaximal_Make(:Dedupe:=args[1])>
      )
    ]);

    RESEVAL := PGG_ArgSpec_Union([
      PGG_ArgSpec_ISA(PGGAlg_ResEval),
      PGG_ArgSpec_Literal(false),
      PGG_ArgSpec_Attr(
        "Global",
        [<GLOBAL_MODEL,"Model",false>],
        func<args | PGGAlg_ResEval_Global_Make(:Model:=args[1])>
      )
    ]);

    GALOISGROUP := set("GALOISGROUP", PGG_ArgSpec_Union([
      PGG_ArgSpec_ISA(PGGAlg_GaloisGroup),
      PGG_ArgSpec_Literal(false),
      PGG_ArgSpec_Attr(
        "ARM",
        [ <RESEVAL,"Eval",false>
        , <RESGROUPS,"Groups",false>
        , <BOOL,"UseEasyResolvents",false>
        ],
        func<args | PGGAlg_GaloisGroup_ARM_Make(:ResolventAlg:=args[1], GroupsAlg:=args[2], UseEasyResolvents:=args[3])>
      ),
      PGG_ArgSpec_Attr(
        "Builtin",
        [],
        func<args | PGGAlg_GaloisGroup_Builtin_Make()>
      ),
      PGG_ArgSpec_Attr(
        "SinglyRamified",
        [],
        func<args | PGGAlg_GaloisGroup_SinglyRamified_Make()>
      )
    ]));
  end procedure);

  return PGG_Parse(specs("GALOISGROUP"), alg);
end function;

intrinsic PGG_RamificationGroup(f :: RngUPolElt[FldPad], u :: FldRatElt : Alg:=false, Time:=false) -> GrpPerm
  {The u-th Galois group of f (in the upper numbering).}
  if Time then
    PGG_StartGlobalTimer();
  end if;
  PGG_GlobalTimer_Push("parse algorithm");
  if Alg cmpeq false then
    Alg := "ARM";
  end if;
  alg := parse_algorithm(Alg);
  vprint PGG_GaloisGroup: "algorithm =", alg;
  PGG_GlobalTimer_Swap("GaloisGroup");
  if u lt 0 then
    G := GaloisGroup(alg, f);
  elif u lt 1 then
    G := InertiaGroup(alg, f);
  else
    G := RamificationGroup(alg, f, u);
  end if;
  PGG_GlobalTimer_Pop();
  if Time then
    PGG_GlobalTimer_PrintTree();
    PGG_StopGlobalTimer();
  end if;
  return G;
end intrinsic;

intrinsic PGG_RamificationGroup(f :: RngUPolElt[FldPad], u :: RngIntElt : Alg:=false, Time:=false) -> GrpPerm
  {"}
  return PGG_RamificationGroup(f, Q!u : Alg:=Alg, Time:=Time);
end intrinsic;

intrinsic PGG_GaloisGroup(f :: RngUPolElt[FldPad] : Alg:=false, Time:=false) -> GrpPerm
  {The Galois group of f.}
  return PGG_RamificationGroup(f, -1 : Alg:=Alg, Time:=Time);
end intrinsic;

intrinsic PGG_InertiaGroup(f :: RngUPolElt[FldPad] : Alg:=false, Time:=false) -> GrpPerm
  {The inertia group of f.}
  return PGG_RamificationGroup(f, 0 : Alg:=Alg, Time:=Time);
end intrinsic;