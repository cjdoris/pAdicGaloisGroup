// implementation of a general galois-group finding algorithm, general in the sense that the algorithms involved are written in a modular fashion so that each piece can be changed independently of the rest, as far as possible

import "Utils.mag": Q, Z, not_implemented;

declare verbose PGG_GaloisGroup, 2;

declare type PGGAlg;

declare type PGGAlgState;
declare attributes PGGAlgState: algorithm;

declare type PGGAlg_GaloisGroup: PGGAlg;

intrinsic GaloisGroup(alg :: PGGAlg_GaloisGroup, f :: RngUPolElt[FldPad]) -> GrpPerm
  {The Galois group of f.}
  return RamificationGroup(alg, f, Q!-1);
end intrinsic;

intrinsic InertiaGroup(alg :: PGGAlg_GaloisGroup, f :: RngUPolElt[FldPad]) -> GrpPerm
  {The inertia group of f.}
  return RamificationGroup(alg, f, Q!0);
end intrinsic;

intrinsic RamificationGroup(alg :: PGGAlg_GaloisGroup, f :: RngUPolElt[FldPad], u :: FldRatElt) -> GrpPerm
  {The u-th ramification group of f.}
  if u lt 0 then
    not_implemented("GaloisGroup");
  elif u lt 1 then
    not_implemented("InertiaGroup");
  else
    not_implemented("RamificationGroup");
  end if;
end intrinsic;

function parse_algorithm(alg : prime:=false)

  specs := PGG_ArgSpec_ManyRecursive(procedure (set, get)

    BOOL := PGG_ArgSpec_Union([
      PGG_ArgSpec_ISA(BoolElt),
      PGG_ArgSpec_Attr("True", [], func<args | true>),
      PGG_ArgSpec_Attr("False", [], func<args | false>)
    ]);

    EXPRESSION := func<vars | PGG_ArgSpec_Recursive(function (X)
      return PGG_ArgSpec_Union([
        PGG_ArgSpec_Attr(var, [], func<args | PGG_Expression_FreeVariable(var)>)
        : var in vars
      ] cat [
        // equality
        PGG_ArgSpec_Attr("eq", [<X>,<X>], func<args | PGG_Expression_BinOp('eq', args[1], args[2] : Infix)>),
        PGG_ArgSpec_Attr("ne", [<X>,<X>], func<args | PGG_Expression_BinOp('ne', args[1], args[2] : Infix)>),
        // (additive) ordering
        PGG_ArgSpec_Attr("le", [<X>,<X>], func<args | PGG_Expression_BinOp('le', args[1], args[2] : Infix)>),
        PGG_ArgSpec_Attr("lt", [<X>,<X>], func<args | PGG_Expression_BinOp('lt', args[1], args[2] : Infix)>),
        PGG_ArgSpec_Attr("ge", [<X>,<X>], func<args | PGG_Expression_BinOp('ge', args[1], args[2] : Infix)>),
        PGG_ArgSpec_Attr("gt", [<X>,<X>], func<args | PGG_Expression_BinOp('gt', args[1], args[2] : Infix)>),
        // multiplicative ordering
        PGG_ArgSpec_Attr("mle", [<X>,<X>], func<args | PGG_Expression_BinOp(func<x,y | IsDivisibleBy(y,x)>, args[1], args[2] : Infix, Name:="mle")>),
        PGG_ArgSpec_Attr("mlt", [<X>,<X>], func<args | PGG_Expression_BinOp(func<x,y | x ne y and IsDivisibleBy(y,x)>, args[1], args[2] : Infix, Name:="mlt")>),
        PGG_ArgSpec_Attr("mge", [<X>,<X>], func<args | PGG_Expression_BinOp(func<x,y | IsDivisibleBy(x,y)>, args[1], args[2] : Infix, Name:="mge")>),
        PGG_ArgSpec_Attr("mgt", [<X>,<X>], func<args | PGG_Expression_BinOp(func<x,y | x ne y and IsDivisibleBy(x,y)>, args[1], args[2] : Infix, Name:="mgt")>),
        // valuation
        PGG_ArgSpec_Attr("val", [<X>,<X>], func<args | PGG_Expression_BinOp(func<p,x | Valuation(x,p)>, args[1], args[2] : Format:="val_%o(%o)")>),
        PGG_ArgSpec_Attr("val", [<X>], function(args) error if prime cmpeq false, "cannot use val when prime is not implied"; return PGG_Expression_UnOp(func<x | Valuation(x, prime)>, args[1] : Name:="val"); end function),
        // logical
        PGG_ArgSpec_AttrList("and", X, func<args | PGG_Expression_All([*x : x in args*])>),
        PGG_ArgSpec_AttrList("or", X, func<args | PGG_Expression_Any([*x : x in args*])>),
        PGG_ArgSpec_Attr("not", [<X>], func<args | PGG_Expression_UnOp('not', args[1] : Prefix)>),
        // arithmetic
        PGG_ArgSpec_Attr("-", [<X>], func<args | PGG_Expression_UnOp('-', args[1] : Prefix)>),
        PGG_ArgSpec_Attr("-", [<X>,<X>], func<args | PGG_Expression_BinOp('-', args[1], args[2] : Infix)>),
        PGG_ArgSpec_AttrList("+", X, func<args | PGG_Expression_SeqOp('&+', [*x : x in args*] : Infix, Name:="+")>),
        PGG_ArgSpec_AttrList("*", X, func<args | PGG_Expression_SeqOp('&*', [*x : x in args*] : Infix, Name:="*")>),
        // constants
        PGG_ArgSpec_Transform(PGG_ArgSpec_AttrInt(), func<x | PGG_Expression_Const(x)>)
      ]);
    end function)>;

    GLOBAL_MODEL := set("GLOBAL_MODEL", PGG_ArgSpec_Union([
      PGG_ArgSpec_ISA(PGGAlg_ResEval_Global_Model),
      PGG_ArgSpec_Literal(false),
      PGG_ArgSpec_Attr(
        "Symmetric",
        [<get("GALOISGROUP"),"GG",false>],
        func<args | PGGAlg_ResEval_Global_Model_Symmetric_Make(:GaloisGroupAlg:=args[1])>
      ),
      PGG_ArgSpec_Attr(
        "Factors",
        [<get("GLOBAL_MODEL"),"Next",false>],
        func<args | PGGAlg_ResEval_Global_Model_Factors_Make(:Next:=args[1])>
      ),
      PGG_ArgSpec_Attr(
        "RamTower",
        [<get("GLOBAL_MODEL"),"Next",false>],
        func<args | PGGAlg_ResEval_Global_Model_RamTower_Make(:Next:=args[1])>
      ),
      PGG_ArgSpec_AttrSelect(
        "Select",
        EXPRESSION(["p","faccerts","irr","unram","tame","ram","wild","totram","totwild"]),
        get("GLOBAL_MODEL"),
        func<pargs, rargs | PGGAlg_ResEval_Global_Model_Select_Make(:Predicates:=pargs, Models:=rargs)>
      ),
      PGG_ArgSpec_Attr(
        "RootOfUnity",
        [ <BOOL, "Minimize", false>
        , <BOOL, "Complement", false>
        ],
        func<args | PGGAlg_ResEval_Global_Model_RootOfUnity_Make(:Minimize:=args[1], Complement:=args[2])>
      ),
      PGG_ArgSpec_Attr(
        "RootOfUniformizer",
        [],
        func<args | PGGAlg_ResEval_Global_Model_RootOfUniformizer_Make()>
      )
    ]));

    STATISTIC := set("STATISTIC", PGG_ArgSpec_Union([
      PGG_ArgSpec_ISA(PGGStat),
      PGG_ArgSpec_Literal(false),
      PGG_ArgSpec_Attr("HasRoot", [], func<args | PGGStat_HasRoot_Make()>),
      PGG_ArgSpec_Attr("NumRoots", [], func<args | PGGStat_NumRoots_Make()>),
      PGG_ArgSpec_Attr("FactorDegrees", [], func<args | PGGStat_FactorDegrees_Make()>),
      PGG_ArgSpec_Attr("Degree", [], func<args | PGGStat_Degree_Make()>),
      PGG_ArgSpec_Attr("AutGroup", [], func<args | PGGStat_AutGroup_Make()>),
      PGG_ArgSpec_AttrList("Tup", get("STATISTIC"), func<args | PGGStat_Tup_Make(args)>),
      PGG_ArgSpec_Attr("Factors", [<get("STATISTIC"), "Stat", false>], func<args | PGGStat_Factors_Make(:Stat:=args[1])>),
      PGG_ArgSpec_Attr("Factors2",
        [ <get("STATISTIC"), "Stat2", false>
        , <get("STATISTIC"), "Stat1", false>
        , <BOOL, "Strict", false>
        ],
        func<args | PGGStat_Factors2_Make(
          : Stat2:=args[1]
          , Stat1:=args[2] cmpne false select args[2] else args[1]
          , Strict:=args[3]
        )>
      ),
      PGG_ArgSpec_Attr("Stab", [<get("STATISTIC"), "Stat", false>], func<args | PGGStat_Stab_Make(:Stat:=args[1])>),
      PGG_ArgSpec_Attr("GaloisGroup", [<get("GALOISGROUP"),"Alg",false>], func<args | PGGStat_GaloisGroup_Make(:Alg:=args[1])>)
    ]));

    // SUBGROUP_TRANCHE := PGG_ArgSpec_Union([
    //   PGG_ArgSpec_Literal(false),
    //   PGG_ArgSpec_Attr("All"),
    //   PGG_ArgSpec_Attr("Index"),
    //   PGG_ArgSpec_Attr("OrbitIndex"),
    //   PGG_ArgSpec_Attr("MostUseful")
    // ]);

    // SUBGROUP_SCORE := PGG_ArgSpec_Union([
    //   PGG_ArgSpec_Literal(false),
    //   PGG_ArgSpec_Attr("IsUseful"),
    //   PGG_ArgSpec_Attr("Diversity"),
    //   PGG_ArgSpec_Attr("Information")
    // ]);

    // SUBGROUP_CHOICE := PGG_ArgSpec_Union([
    //   PGG_ArgSpec_Literal(false),
    //   PGG_ArgSpec_Attr("First"),
    //   PGG_ArgSpec_Attr("Best")
    // ]);

    // SUBGROUP_PRIORITY_EXPRESSION := PGG_ArgSpec_AttrExpr(["Index","OrbitIndex","Diversity","Information"]);

    SUBGROUP_PRIORITY := set("SUBGROUP_PRIORITY", PGG_ArgSpec_Union([
      PGG_ArgSpec_ISA(PGGAlg_ResPriority),
      PGG_ArgSpec_Literal(false),
      PGG_ArgSpec_Attr(
        "Null",
        [],
        func<args | PGGAlg_ResPriority_Null_Make()>
      ),
      PGG_ArgSpec_Attr(
        "Random",
        [],
        func<args | PGGAlg_ResPriority_Random_Make()>
      ),
      PGG_ArgSpec_Attr(
        "Reverse",
        [ <get("SUBGROUP_PRIORITY"),"Priority",false> ],
        func<args | PGGAlg_ResPriority_Reverse_Make(:Priority:=args[1])>
      ),
      // PGG_ArgSpec_Attr(
      //   "Filter",
      //   [ <SUBGROUP_PRIORITY_EXPRESSION,"Cond",false>,
      //     <get("SUBGROUP_PRIORITY"),"Priority",false>
      //   ],
      //   func<args | PGGAlg_ResPriority_Null_Make(:Expression:=args[1], Priority:=args[2])>
      // ),
      PGG_ArgSpec_Transform(EXPRESSION(["Index","OrbitIndex","Diversity","Information"]), func<x | PGGAlg_ResPriority_Key_Make(x)>)
    ]));

    SUBGROUP_TRANCHE := PGG_ArgSpec_Union([
      PGG_ArgSpec_ISA(PGGAlg_Tranche),
      PGG_ArgSpec_Literal(false),
      PGG_ArgSpec_Attr(
        "All",
        [ ],
        func<args | PGGAlg_Tranche_All_Make()>
      ),
      PGG_ArgSpec_Attr(
        "Index",
        [ <EXPRESSION(["idx","has_special","sidx0"]),"If",false>
        , <EXPRESSION(["idx"]),"Sort",false>
        ],
        func<args | PGGAlg_Tranche_Index_Make(:Filter:=args[1], SortKey:=args[2])>
      ),
      PGG_ArgSpec_Attr(
        "OrbitIndex",
        [ <EXPRESSION(["idx","oidx","ridx","has_special","sidx0"]),"If",false>
        , <EXPRESSION(["idx","oidx","ridx"]),"Sort",false>
        ],
        func<args | PGGAlg_Tranche_OrbitIndex_Make(:Filter:=args[1], SortKey:=args[2])>
      )
    ]);

    SUBGROUP_CHOICE := PGG_ArgSpec_Union([
      PGG_ArgSpec_ISA(PGGAlg_ResChoice),
      PGG_ArgSpec_Literal(false),
      PGG_ArgSpec_Transform(
        SUBGROUP_TRANCHE,
        func<t | PGGAlg_ResChoice_Tranche_Make(:Tranche:=t)>
      ),
      PGG_ArgSpec_Attr(
        "",
        [ <SUBGROUP_TRANCHE,"Tranche",false>, <SUBGROUP_PRIORITY,"Priority",false> ],
        func<args | PGGAlg_ResChoice_Tranche_Make(:Tranche:=args[1], Priority:=args[2])>
      )
    ]);

    RESGROUPS := set("RESGROUPS", PGG_ArgSpec_Union([
      PGG_ArgSpec_ISA(PGGAlg_ResGroups),
      PGG_ArgSpec_Literal(false),
      PGG_ArgSpec_Attr(
        "All",
        [ <STATISTIC,"Stat",false>
        , <SUBGROUP_CHOICE,"Choice",false>
        ],
        func<args | PGGAlg_ResGroups_All_Make(:Statistic:=args[1], SubgroupChoice:=args[2])>
      ),
      PGG_ArgSpec_Attr(
        "Maximal",
        [ <STATISTIC,"Stat",false>
        , <SUBGROUP_CHOICE,"Choice",false>
        , <PGG_ArgSpec_Union([
            PGG_ArgSpec_Literal(false),
            PGG_ArgSpec_Attr("Always"),
            PGG_ArgSpec_Attr("AllUnequal"),
            PGG_ArgSpec_Attr("AllUnequalAndNoSubgroup"),
            PGG_ArgSpec_Attr("Necessary"),
            PGG_ArgSpec_Attr("NoSubgroup"),
            PGG_ArgSpec_Attr("Sufficient"),
            PGG_ArgSpec_Attr("Ask")
          ]), "DescendWhen", false>
        , <PGG_ArgSpec_Union([
            PGG_ArgSpec_Literal(false),
            PGG_ArgSpec_Attr("All"),
            PGG_ArgSpec_Attr("OneNode"),
            PGG_ArgSpec_Attr("OneChild")
          ]), "Descend", false>
        , <PGG_ArgSpec_Union([
            PGG_ArgSpec_Literal(false),
            PGG_ArgSpec_Attr("Sufficient"),
            PGG_ArgSpec_Attr("Necessary"),
            PGG_ArgSpec_Attr("Generous"),
            PGG_ArgSpec_Attr("All")
          ]), "Useful", false>
        , <BOOL, "Reprocess", true>
        , <BOOL, "Reset", true>
        , <BOOL, "Dedupe", true>
        ],
        func<args | PGGAlg_ResGroups_Maximal_Make(:Statistic:=args[1], SubgroupChoice:=args[2], DescendWhen:=args[3], Descend:=args[4], Useful:=args[5], Reprocess:=args[6], Reset:=args[7], Dedupe:=args[8])>
      ),
      PGG_ArgSpec_Attr(
        "Maximal2",
        [ <STATISTIC,"Stat",false>
        , <SUBGROUP_CHOICE,"Choice",false>
        , <PGG_ArgSpec_Union([
            PGG_ArgSpec_Literal(false),
            PGG_ArgSpec_Attr("Strict"),
            PGG_ArgSpec_Attr("SimpleMagic"),
            PGG_ArgSpec_Attr("Magic")
          ]), "Descend", false>
        , <BOOL, "Reset", true>
        , <BOOL, "Dedupe", true>
        ],
        func<args | PGGAlg_ResGroups_Maximal2_Make(:Statistic:=args[1], SubgroupChoice:=args[2], Descend:=args[3], Reset:=args[4], Dedupe:=args[5])>
      ),
      PGG_ArgSpec_Attr(
        "RootsMaximal",
        [ <BOOL,"Dedupe",false> ],
        func<args | PGGAlg_ResGroups_RootsMaximal_Make(:Dedupe:=args[1])>
      ),
      PGG_ArgSpec_AttrList(
        "",
        get("RESGROUPS"),
        func<args | PGGAlg_ResGroups_Sequence_Make(args)>
      ),
      PGG_ArgSpec_AttrForEach(
        "ForEach",
        get("RESGROUPS"),
        func<args | PGGAlg_ResGroups_Sequence_Make(args)>
      )
    ]));

    RESEVAL := PGG_ArgSpec_Union([
      PGG_ArgSpec_ISA(PGGAlg_ResEval),
      PGG_ArgSpec_Literal(false),
      PGG_ArgSpec_Attr(
        "Global",
        [<GLOBAL_MODEL,"Model",false>],
        func<args | PGGAlg_ResEval_Global_Make(:Model:=args[1])>
      )
    ]);

    GALOISGROUP := set("GALOISGROUP", PGG_ArgSpec_Union([
      PGG_ArgSpec_ISA(PGGAlg_GaloisGroup),
      PGG_ArgSpec_Literal(false),
      PGG_ArgSpec_Attr(
        "ARM",
        [ <RESEVAL,"Eval",false>
        , <RESGROUPS,"Groups",false>
        , <BOOL,"UseEasyResolvents",false>
        ],
        func<args | PGGAlg_GaloisGroup_ARM_Make(:ResolventAlg:=args[1], GroupsAlg:=args[2], UseEasyResolvents:=args[3])>
      ),
      PGG_ArgSpec_Attr(
        "Builtin",
        [],
        func<args | PGGAlg_GaloisGroup_Builtin_Make()>
      ),
      PGG_ArgSpec_Attr(
        "SinglyRamified",
        [],
        func<args | PGGAlg_GaloisGroup_SinglyRamified_Make()>
      )
    ]));
  end procedure);

  return PGG_Parse(specs("GALOISGROUP"), alg);
end function;

intrinsic PGG_RamificationGroup(f :: RngUPolElt[FldPad], u :: FldRatElt : Alg:=false, Time:=false) -> GrpPerm
  {The u-th Galois group of f (in the upper numbering).}
  if Time then
    PGG_StartGlobalTimer();
  end if;
  PGG_GlobalTimer_Push("parse algorithm");
  if Alg cmpeq false then
    Alg := "ARM";
  end if;
  alg := parse_algorithm(Alg : prime:=Prime(BaseRing(f)));
  vprint PGG_GaloisGroup: "algorithm =", alg;
  PGG_GlobalTimer_Swap("GaloisGroup");
  if u lt 0 then
    G := GaloisGroup(alg, f);
  elif u lt 1 then
    G := InertiaGroup(alg, f);
  else
    G := RamificationGroup(alg, f, u);
  end if;
  PGG_GlobalTimer_Pop();
  if Time then
    PGG_GlobalTimer_PrintTree();
    PGG_StopGlobalTimer();
  end if;
  return G;
end intrinsic;

intrinsic PGG_RamificationGroup(f :: RngUPolElt[FldPad], u :: RngIntElt : Alg:=false, Time:=false) -> GrpPerm
  {"}
  return PGG_RamificationGroup(f, Q!u : Alg:=Alg, Time:=Time);
end intrinsic;

intrinsic PGG_GaloisGroup(f :: RngUPolElt[FldPad] : Alg:=false, Time:=false) -> GrpPerm
  {The Galois group of f.}
  return PGG_RamificationGroup(f, -1 : Alg:=Alg, Time:=Time);
end intrinsic;

intrinsic PGG_InertiaGroup(f :: RngUPolElt[FldPad] : Alg:=false, Time:=false) -> GrpPerm
  {The inertia group of f.}
  return PGG_RamificationGroup(f, 0 : Alg:=Alg, Time:=Time);
end intrinsic;