// implementation of a general galois-group finding algorithm, general in the sense that the algorithms involved are written in a modular fashion so that each piece can be changed independently of the rest, as far as possible

declare verbose PGG_GaloisGroup, 1;

Z := IntegerRing();
Q := RationalField();

function not_implemented(msg, ...)
  error "not implemented: " cat Join([Sprintf("%o", x) : x in msg], " ");  
end function;

function precision_error()
  error "precision error";
end function;

procedure isort_by(~xs, key)
  keys := [key(xs[i]) : i in [1..#xs]];
  Sort(~keys, ~permutation);
  xs := [xs[i^permutation] : i in [1..#xs]];
end procedure;

function sort_by(xs, key)
  isort_by(~xs, key);
  return xs;
end function;

function group_by(xs, key)
  A := AssociativeArray();
  for x in xs do
    k := key(x);
    if IsDefined(A, k) then
      Append(~A[k], x);
    else
      A[k] := [x];
    end if;
  end for;
end function;

function enumerate(xs)
  return [<xs[i], i> : i in [1..#xs] | IsDefined(xs, i)];
end function;

function is_any_coercible(coercers, x)
  for i in [1..#coercers] do
    ok, y := coercers[i](x);
    if ok then
      return true, i, y;
    end if;
  end for;
  return false, _, _;
end function;

function all_coercible(dflts, coercers, xs)
  assert #dflts eq #coercers;
  dflts := [* d : d in dflts *];
  for x in xs do
    ok, i, y := is_any_coercible(coercers, x);
    if ok then
      dflts[i] := y;
    else
      return false, _;
    end if;
  end for;
  return true, dflts;
end function;

function the(xs)
  assert #xs eq 1;
  return [x : x in xs][1];
end function;

// the roots of f as a sequence (no multiplicities)
// f must be squarefree
function roots(f)
  rs := Roots(f : IsSquarefree);
  assert forall{r : r in rs | r[2] eq 1};
  return [r[1] : r in rs];
end function;

// true if f has a root
// f must be squarefree
// also returns a root
function has_root(f)
  rs := roots(f);
  if #rs eq 0 then
    return false, _;
  else
    return true, rs[1];
  end if;
end function;

// the factorization of f as a sequence (no multiplicities)
// f must be squarefree
// also the certificates
function factorization(f : Extensions:=false)
  slope := Ceiling(Max(Slopes(NewtonPolygon(f))));
  d := Degree(f);
  vlc := Valuation(Coefficient(f, d));
  f2 := Parent(f) ! [ShiftValuation(Coefficient(f, i), (d-i)*slope - vlc) : i in [0..d]];
  facs, _, certs := Factorization(f2 : IsSquarefree, Certificates, Extensions:=Extensions);
  assert forall{fac : fac in facs | fac[2] eq 1};
  return [Parent(g)![ShiftValuation(Coefficient(g,i), (i-d)*slope-vlc) : i in [0..d]] where vlc:=Valuation(Coefficient(g,d)) where d:=Degree(g) where g:=fac[1] : fac in facs], certs;
end function;

function extension(f)
  facs, certs := factorization(f : Extensions);
  error if #facs gt 1, "expecting at most 1 factor";
  return certs[1]`Extension;
end function;

function pol_invmod(g, f)
  d := Degree(f);
  // rows are coefficients of g^i mod f
  M := Matrix([[Coefficient(gg, j) : j in [0..d-1]] where gg := Polynomial([0 : j in [1..i]] cat Coefficients(g)) mod f : i in [0..d-1]]);
  // rows are linear combinations of g^i summing to x^j
  ok, Minv := IsInvertible(M);
  assert ok;
  // first row is h(x) so that h(x)g(x)=1 mod f(x)
  return Polynomial(Eltseq(Rows(Minv)[1]));
end function;

// the factorization of f into pieces corresponding to the slopes of its newton polygon as a sequence
function newton_polygon_factorization(f : alg:="Hensel")
  // special cases
  d := Degree(f);
  error if d lt 0, "f must be non-zero";
  error if IsWeaklyZero(Coefficient(f, d)), "precision error: leading coefficient is weakly zero";
  if d eq 0 then
    return [];
  end if;
  case alg:
  when "Cheat":
    // we cheat and do a full factorization and then aggregate the results
    // this will be very inefficient for some polynomials!
    facs := factorization(f);
    a := AssociativeArray();
    for fac in facs do
      s := the(Slopes(NewtonPolygon(fac)));
      if IsDefined(a, s) then
        Append(~a[s], fac);
      else
        a[s] := [fac];
      end if;
    end for;
    return [&*a[s] : s in Sort([s : s in Keys(a)])];
  when "Hensel":
    // use Hensel's lemma
    R := Parent(f);
    K := BaseRing(R);
    pr := Precision(K);
    assert pr lt Infinity();
    np := NewtonPolygon(f);
    vs := ChangeUniverse(Vertices(np), car<Z,Z>);
    assert #vs ge 2;
    assert vs[1][1] eq 0;
    assert vs[#vs][1] eq Degree(f);
    error if exists{v : v in vs | IsWeaklyZero(Coefficient(f, v[1]))}, "precision error: coefficient weakly zero";
    factors := [];
    for n in [2..#vs] do
      i0, v0 := Explode(vs[n-1]);
      i1, v1 := Explode(vs[n]);
      width := i1 - i0;
      slope := (v1 - v0) / width;
      h := -Numerator(slope);
      e := Denominator(slope);
      g0 := R ! [Coefficient(f, i) / Coefficient(f, i1) : i in [i0..i1]];
      g := R ! [IsWeaklyZero(c) select 0 else ChangePrecision(c, pr) : c in Coefficients(g0)];
      assert Degree(g) eq width;
      assert Valuation(Coefficient(g, 0)) eq v0-v1;
      assert Valuation(Coefficient(g, width)) eq 0;
      vprint PGG_GaloisGroup: "hensel lifting slope =", slope;
      niters := 0;
      while true do
        niters +:= 1;
        if false then
          // use arithmetic in R mod g instead of reducing things mod g explicitly
          Q := quo<R | g>;
          PGG_GlobalTimer_Push("quotrem g");
          h, fmodg := Quotrem(f, g);
          PGG_GlobalTimer_Swap("gnew");
          gnew := g + R!(Q!fmodg/Q!h);
        else
          PGG_GlobalTimer_Push("quotrem g");
          h, fmodg := Quotrem(f, g);
          if true then
            // use Newton lifting to find hinv = h^-1 mod g after the first iteration
            // TODO: even better would be to only do pol_invmod() to limited precision at first, and then do many rounds of Newton lifting
            if niters eq 1 then
              PGG_GlobalTimer_Swap("invmod g");
              hinv := pol_invmod(h, g);
            else
              PGG_GlobalTimer_Swap("newton lift");
              hinv := (hinv * (2 - ((h * hinv) mod g))) mod g;
            end if;
          else
            PGG_GlobalTimer_Swap("invmod g");
            hinv := pol_invmod(h, g);
          end if;
          PGG_GlobalTimer_Swap("mult");
          tmp := fmodg * hinv;
          PGG_GlobalTimer_Swap("mod g");
          tmp := tmp mod g;
          PGG_GlobalTimer_Swap("add");
          gnew := g + tmp;
        end if;
        PGG_GlobalTimer_Swap("check");
        assert Degree(gnew) eq width;
        assert Valuation(Coefficient(g, 0)) eq v0-v1;
        assert Valuation(Coefficient(g, width)) eq 0;
        delta := g - gnew;
        PGG_GlobalTimer_Pop();
        if forall{i : i in [0..width] | IsWeaklyZero(Coefficient(delta, i))} then
          vprint PGG_GaloisGroup: "f mod g =", fmodg;
          Append(~factors, g);
          continue n;
        else
          g := R ! [IsWeaklyZero(c) select 0 else ChangePrecision(c, pr) : c in Coefficients(gnew)];
        end if;
      end while;
    end for;
    return factors;
  else
    error "invalid algorithm:", alg;
  end case;
end function;

function multiplicities_to_information(mults)
  mults := [m : m in mults | m ne 0];
  assert forall{m : m in mults | m gt 0};
  assert #mults gt 0;
  if #mults eq 1 then
    return 0.0;
  end if;
  total := &+mults;
  ans := &+[-p*Log(2,p) where p:=m/total : m in mults];
  assert ans gt 0;
  return ans;
end function;

function largest_coefficient(x)
  if IsPrimeField(Parent(x)) then
    return Abs(x);
  else
    return Max([largest_coefficient(c) : c in Eltseq(x)]);
  end if;
end function;

function reduce_coefficients(x, M)
  if IsPrimeField(Parent(x)) then
    return Parent(x) ! ((Z!x) mod M);
  else
    return Parent(x) ! [reduce_coefficients(c, M) : c in Eltseq(x)];
  end if;
end function;

function startswith(x, y)
  if #x ge #y and x[1..#y] eq y then
    return true, x[#y+1..#x];
  else
    return false, _;
  end if;
end function;

procedure seq_idiff(~xs, ys)
  ys := {y : y in ys};
  xs := [xs[i] : i in [1..#xs] | xs[i] notin ys];
end procedure;

// a bound on |f(a_1,...,a_n)| where |a_i| le b.
// f is a RngSLPolElt
function slpol_bound(f, b)
  op := Operator(f);
  f1, f2 := Operands(f);
  case op:
  when "var":
    return b;
  when "const":
    return Abs(f1);
  when "+", "-":
    return slpol_bound(f1, b) + slpol_bound(f2, b);
  when "*":
    return slpol_bound(f1, b) * slpol_bound(f2, b);
  when "^":
    return slpol_bound(f1, b) ^ f2;
  else
    assert false;
  end case;
end function;

function permute_seq(g, xs)
  d := Degree(Parent(g));
  assert d eq #xs;
  return [xs[i^g] : i in [1..d]];
end function;

procedure pop_start(~x, ~xs)
  assert #xs ne 0;
  x := xs[1];
  xs := xs[2..#xs];
end procedure;

function polynomial_with_roots(rs)
  U := Universe(rs);
  R := PolynomialRing(U);
  return &*[R| [-r, 1] : r in rs];
end function;

function left_coset_representatives(G, H)
  assert H subset G;
  cosets, indices := DoubleCosetRepresentatives(G, H, sub<G | 1>);
  return cosets;
end function;

function is_extension_of(L, K)
  if L eq K then
    return true, [K];
  elif IsPrimeField(L) then
    return false, _;
  else
    ok, twr := is_extension_of(BaseField(L), K);
    if ok then
      return true, Append(twr, L);
    else
      return false, _;
    end if;
  end if;
end function;

function tower(L, K)
  ok, twr := is_extension_of(L, K);
  assert ok;
  return twr;
end function;

function is_in_standard_form(L, K)
  t := tower(L, K);
  if #t eq 1 then
    return true, K;
  elif #t eq 2 then
    if RamificationDegree(t[2]) gt 1 then
      return true, K;
    elif InertiaDegree(t[2]) gt 1 then
      return true, L;
    end if;
  elif #t eq 3 then
    U := t[2];
    if RamificationDegree(L) gt 1 and InertiaDegree(U) gt 1 then
      return true, U;
    end if;
  end if;
  return false, _;
end function;

function valuation_eq(c, n)
  if Valuation(c) gt n then
    return false;
  elif IsWeaklyZero(c) then
    precision_error();
  else
    return Valuation(c) eq n;
  end if;
end function;

function valuation_ge(c, n)
  if Valuation(c) ge n then
    return true;
  elif IsWeaklyZero(c) then
    precision_error();
  else
    return false;
  end if;
end function;

function is_eisenstein(f)
  d := Degree(f);
  return (d ge 0) and valuation_eq(Coefficient(f, d), 0) and valuation_eq(Coefficient(f, 0), 1) and forall{i : i in [1..d-1] | valuation_ge(Coefficient(f, i), 1)};
end function;

function xdiv(x, y)
  ok, z := IsDivisibleBy(x, y);
  assert ok;
  return z;
end function;

// solves S*M=V for S
function solve(M, V)
  return V * M^-1;
  ok, S := IsSolvable(M, V);
  if ok then
    return S;
  else
    return V * M^-1;
  end if;
end function;

// given L/K and a sequence pis of elements of L which are uniformizing elements of subextensions K(pis[#pis])/.../K(pis[1]), return this tower from the bottom up
function tower_from_uniformizers(L, K, pis : alg:="LA")
  assert Universe(pis) eq L;
  assert not IsPrimeField(L);
  assert BaseField(L) eq K;
  t := [];
  K2 := K;
  L2 := L;
  LtoL2 := map<L -> L2 | x :-> x>;
  f := DefiningPolynomial(L);
  Lpi := L.1;
  for i in [1..#pis] do
    PGG_GlobalTimer_Push("minimal polynomial");
    pi2 := LtoL2(pis[i]);
    m := MinimalPolynomial(pi2, K2);
    PGG_GlobalTimer_Swap("factorization");
    assert is_eisenstein(m);
    d := Degree(m);
    n := xdiv(Degree(L2, K2), d);
    if d gt 1 then
      K2new := ext<K2 | ChangePrecision(m, Precision(K2))>;
      case alg:
      when "Factorization":
        f2 := factorization(ChangeRing(f, K2new))[1];
      when "LA":
        V := VectorSpace(K2, Degree(L2, K2));
        vmap := map<L2 -> V | x :-> V!Eltseq(x), y :-> L2!Eltseq(y)>;
        L2pi := LtoL2(Lpi);
        vec := vmap(L2pi^n);
        mat := Matrix([vmap(L2pi^i * pi2^j) : j in [0..d-1], i in [0..n-1]]);
        coeffs := Eltseq(solve(mat, vec));
        f2 := Polynomial([K2new| i eq n select 1 else -&+[coeffs[i*d+j+1] * K2new.1^j : j in [0..d-1]] : i in [0..n]]);
      else
        assert false;
      end case;
      assert Degree(f2) eq n;
      assert is_eisenstein(f2);
      L2new := ext<K2new | ChangePrecision(f2, Precision(L2))>;
      LtoL2new := map<L -> L2new | x :-> &+[L2new| L2new.1^(i-1) * cs[i] : i in [1..#cs]] where cs:=Eltseq(x)>;
      // rename for iterating
      K2 := K2new;
      L2 := L2new;
      LtoL2 := LtoL2new;
    end if;
    Append(~t, K2);
    PGG_GlobalTimer_Pop();
  end for;
  return t;
end function;

function ramification_tower(L, K)
  ok, U := is_in_standard_form(L, K);
  assert ok;
  if L eq K then
    return [K];
  elif L eq U then
    return [K, U];
  elif U eq K then
    f := DefiningPolynomial(L);
    R := Parent(f);
    assert is_eisenstein(f);
    pi := L.1;
    assert IsWeaklyZero(Evaluate(f, pi));
    r := Evaluate(f, PolynomialRing(L) ! [pi, 1]);
    assert IsWeaklyZero(Coefficient(r, 0));
    PGG_GlobalTimer_Push("newton polygon factorization");
    rfacs := [R.1] cat newton_polygon_factorization(r div R.1);
    PGG_GlobalTimer_Swap("get uniformizers");
    assert Degree(rfacs[1]) eq 1;
    assert forall{i : i in [1..#rfacs] | IsDivisibleBy(Degree(f), &+[Degree(rfacs[j]) : j in [1..i]])};
    crfacs := [&*rfacs[1..i] : i in [1..#rfacs]];
    cffacs := [Evaluate(crfac, PolynomialRing(L) ! [-pi, 1]) : crfac in crfacs];
    pis := [Coefficient(cffac, 0) : cffac in cffacs];
    PGG_GlobalTimer_Swap("tower from uniformizers");
    twr := tower_from_uniformizers(L, K, Reverse(pis));
    PGG_GlobalTimer_Pop();
    return twr;
  else
    return [K] cat ramification_tower(L, U);
  end if;
end function;

function random_element(E, B)
  if IsPrimeField(E) then
    return E ! Random(B);
  else
    return E ! [random_element(BaseField(E), B) : i in [1..Degree(E)]];
  end if;
end function;

function random_primitive_element(E, F)
  d := Degree(E, F);
  if d eq 1 then
    return E!0, PolynomialRing(F)![0,1];
  end if;
  B := 1;
  while true do
    x := random_element(E, B);
    minpol := MinimalPolynomial(x, F);
    if Degree(minpol) eq d then
      return x, minpol;
    else
      B +:= 1;
    end if;
  end while;
end function;

function zero(K, apr)
  z := (K!1) - (K!1);
  return ShiftValuation(z, apr - AbsolutePrecision(z));
end function;

function change_apr(x, apr)
  if IsWeaklyZero(x) or apr le Valuation(x) then
    return zero(Parent(x), apr);
  else
    return ChangePrecision(x, apr - Valuation(x));
  end if;
end function;

function residually_primitive_element(K)
  F, m := ResidueClassField(Integers(K));
  return PrimitiveElement(F) @@ m;
end function;

function primitive_element(L, K)
  if Degree(L, K) eq 1 then
    return L!1;
  elif RamificationDegree(L, K) eq 1 then
    return residually_primitive_element(L);
  elif InertiaDegree(L, K) eq 1 then
    return UniformizingElement(L);
  else
    return UniformizingElement(L) + residually_primitive_element(L);
  end if;
end function;

// the following works, but looks like it was fixed anyway in V2.23-6
// function automorphism_group(L, K)
//   ok, twr := is_extension_of(L, K);
//   assert ok;
//   if #twr eq 1 or Degree(L, K) eq 1 then
//     return SymmetricGroup(1);
//   end if;
//   hs := Automorphisms(L, K);
//   us := [h(u) : h in hs] where u:=primitive_element(L, K);
//   huss := [[h(u) : u in us] : h in hs];
//   perms := [[the([i : i in [1..#us] | IsWeaklyEqual(hu, us[i])]) : hu in hus] : hus in huss];
//   return sub<SymmetricGroup(#us) | perms>;
// end function;

DEFAULT_TSCHIRNHAUS_TRANSFORMATIONS := [PolynomialRing(Z) | [0,1], [0,0,1], [0,-1,1], [0,1,1], [0,0,0,1], [0,1,0,1], [0,-1,0,1], [0,0,1,1], [0,0,-1,1], [0,1,1,1], [0,-1,-1,1]];

function tschirnhaus_transformation(ntries, degree)
  assert ntries gt 0;
  if ntries le #DEFAULT_TSCHIRNHAUS_TRANSFORMATIONS then
    t := DEFAULT_TSCHIRNHAUS_TRANSFORMATIONS[ntries];
    if Degree(t) le degree then
      return t;
    end if;
  end if;
  return PolynomialRing(Z) ! [Random(1,ntries) : i in [1..degree]];
end function;

function dflt(what, d)
  return (what cmpne false) select what else d;
end function;

function dedupe_conjugage_subgroups(G, Hs)
  CG := PGG_SubgroupClasses(G);
  return [Rep(c) : c in {CG ! H : H in Hs}];
end function;

// non-checking version
// TODO: consider _is_subpartition_of({*1^^9*},{*2,3,4*}); currently we try assigning 1 to each of 2, 3, 4, and then assign 1 again, and keep going; but since we are assigning the same thing over and over, the order that these occur in is unimportant, so we are repeating work; hence, we should do a strategy which assigns all of the same element in one go
function _is_subpartition_of(P, Q)
  if #P eq 0 then
    assert #Q eq 0;
    return true;
  end if;
  assert #P gt 0;
  assert #Q gt 0;
  // pick an element of p
  // hopefully dealing with the largest ones first is optimal
  p := Max(P);
  P2 := Exclude(P, p);
  // pick an element of Q it could come from
  for q in MultisetToSet(Q) do
    if p le q then
      Q2 := Exclude(Q, q);
      if p lt q then
        Include(~Q2, q-p);
      end if;
      ok := _is_subpartition_of(P2, Q2);
      if ok then
        return true;
      end if;
    end if;
  end for;
  return false;
end function;

// given two multisets of positive integers, determine if P may be obtained by partitioning each element of Q
function is_subpartition_of(P, Q)
  assert Type(P) eq SetMulti;
  assert Type(Q) eq SetMulti;
  assert Universe(P) cmpeq Z;
  assert Universe(Q) cmpeq Z;
  assert forall{x : x in MultisetToSet(P) | x gt 0};
  assert forall{x : x in MultisetToSet(Q) | x gt 0};
  assert ((#P eq 0) and (#Q eq 0)) or ((#P gt 0) and (#Q gt 0) and (&+P eq &+Q));
  return _is_subpartition_of(P, Q);
end function;

declare type PGGArgSpec;
declare attributes PGGArgSpec: is_valid;

intrinsic PGG_Parsable(A :: PGGArgSpec, x) -> BoolElt, .
  {Tries to parse x according to A.}
  return A`is_valid(x);
end intrinsic;

intrinsic PGG_Parse(A :: PGGArgSpec, x) -> .
  {Parses x according to A}
  ok, y := PGG_Parsable(A, x);
  error if not ok, "could not parse", x;
  return y;
end intrinsic;

intrinsic PGG_ArgSpec(is_valid :: UserProgram) -> PGGArgSpec
  {The argspec with the given is_valid function.}
  A := New(PGGArgSpec);
  A`is_valid := is_valid;
  return A;
end intrinsic;

intrinsic PGG_ArgSpec_Union(choices :: [PGGArgSpec]) -> PGGArgSpec
  {The argspec for the union of the given choices.}
  return PGG_ArgSpec(function (x)
    for A in choices do
      ok, y := PGG_Parsable(A, x);
      if ok then
        return true, y;
      end if;
    end for;
    return false, _;
  end function);
end intrinsic;

intrinsic PGG_ArgSpec_Transform(A :: PGGArgSpec, tr) -> PGGArgSpec
  {The argspec A with its output modified by tr.}
  return PGG_ArgSpec(function (x)
    ok, y := PGG_Parsable(A, x);
    if ok then
      return true, tr(y);
    else
      return false, _;
    end if;
  end function);
end intrinsic;

intrinsic PGG_ArgSpec_ISA(C) -> PGGArgSpec
  {The argspec testing if the input has the given category.}
  return PGG_ArgSpec(function (x)
    if ISA(ExtendedType(x), C) then
      return true, x;
    else
      return false, _;
    end if;
  end function);
end intrinsic;

intrinsic PGG_ArgSpec_Literal(X) -> PGGArgSpec
  {The argspec matching only X exactly.}
  return PGG_ArgSpec(function (x)
    if X cmpeq x then
      return true, x;
    else
      return false, _;
    end if;
  end function);
end intrinsic;

intrinsic PGG_ArgSpec_Attr(name :: MonStgElt) -> PGGArgSpec
  {The argspec matching the PGGAttr with the given name and no args.}
  return PGG_ArgSpec_Attr(name, [], func<args | name>);
end intrinsic;

intrinsic PGG_ArgSpec_AttrList(name :: MonStgElt, arg, transform) -> PGGArgSpec
  {The argspec matching the PGGAttr with the given name and multiple args matching arg.}
  return PGG_ArgSpec(function (x)
    // coerce to a PGGAttr
    ok, a := PGG_Attribute_IsCoercible(x);
    if not ok then
      return false, _;
    end if;
    // check the name
    if Trim(Name(a)) ne name then
      return false, _;
    end if;
    // check the args
    xs := [**];
    for aa in Arguments(a) do
      ok, x := PGG_Parsable(arg, aa);
      if ok then
        Append(~xs, x);
      else
        return false, _;
      end if;
    end for;
    // apply the transform
    return true, transform(xs);
  end function);
end intrinsic;

intrinsic PGG_ArgSpec_AttrInt() -> PGGArgSpec
  {The argspec matching the PGGAttr when it looks like an integer.}
  return PGG_ArgSpec(function (x)
    // coerce toa PGGAttr
    ok, a := PGG_Attribute_IsCoercible(x);
    if not ok then
      return false, _;
    end if;
    // check it has no arguments
    if #Arguments(a) ne 0 then
      return false, _;
    end if;
    // check it looks like an integer
    z := Trim(Name(a));
    ok, _, groups := Regexp("^-?[0-9]+$", z);
    if ok then
      return true, StringToInteger(z);
    else
      return false, _;
    end if;
  end function);
end intrinsic;

intrinsic PGG_ArgSpec_Attr(name :: MonStgElt, args, transform) -> PGGArgSpec
  {The argspec matching the PGGAttr with the given name and args.}
  return PGG_ArgSpec(function (x)
    // coerce to a PGGAttr
    ok, a := PGG_Attribute_IsCoercible(x);
    if not ok then
      return false, _;
    end if;
    // check the name
    if Trim(Name(a)) ne name then
      return false, _;
    end if;
    // check the args
    // pargs := [* arg[3] : arg in args *];
    pargs := [* #arg ge 3 select <true, arg[3]> else <false> : arg in args *];
    pos := 1;
    for aa in Arguments(a) do
      // try to parse a positional argument
      for i in [pos..#args] do
        ok, parg := PGG_Parsable(args[i][1], aa);
        if ok then
          pargs[i] := <true, parg>;
          pos := i+1;
          continue aa;
        end if;
      end for;
      // try to parse keyword argument
      for i in [1..#args] do
        if #args[i] ge 2 then
          ok, rest := startswith(Name(aa), args[i][2] cat ":");
          if ok then
            ok, parg := PGG_Parsable(args[i][1], PGG_Attribute(rest, Arguments(aa)));
            if ok then
              pargs[i] := <true, parg>;
              continue aa;
            else
              return false, _;
            end if;
          end if;
        end if;
      end for;
      // failed parsing
      return false, _;
    end for;
    // check all the arguments are defined
    if exists{p : p in pargs | not p[1]} then
      return false, _;
    end if;
    // apply the transform
    return true, transform([* p[2] : p in pargs *]);
  end function);
end intrinsic;

intrinsic PGG_ArgSpec_Recursive(mk :: UserProgram) -> PGGArgSpec
  {Allows the creation of a PGGArgSpec recursively.}
  A := New(PGGArgSpec);
  B := mk(A);
  A`is_valid := B`is_valid;
  return A;
end intrinsic;

intrinsic PGG_ArgSpec_Recursive(n :: RngIntElt, mk :: UserProgram) -> []
  {Allows the creation of n PGGArgSpecs recursively.}
  As := [New(PGGArgSpec) : i in [1..n]];
  Bs := mk(As);
  require #Bs eq n: "mk must return n PGGArgSpecs";
  for i in [1..n] do
    As[i]`is_valid := Bs[i]`is_valid;
  end for;
  return As;
end intrinsic;

intrinsic PGG_ArgSpec_ManyRecursive(mk :: UserProgram) -> Map
  {Allows the creation of many PGGArgSpecs.}
  store := NewStore();
  function set(name, A)
    ok, B := StoreIsDefined(store, name);
    if ok then
      B`is_valid := A`is_valid;
      return B;
    else
      StoreSet(store, name, A);
      return A;
    end if;
  end function;
  function get(name)
    ok, A := StoreIsDefined(store, name);
    if ok then
      return A;
    else
      A := New(PGGArgSpec);
      StoreSet(store, name, A);
      return A;
    end if;
  end function;
  mk(set, get);
  return func<name | StoreGet(store, name)>;
end intrinsic;

intrinsic PGG_ArgSpec_Predicate(test :: UserProgram) -> PGGArgSpec
  {The PGGArgSpec passing with the given test.}
  return PGG_ArgSpec(function (x)
    if test(x) then
      return true, x;
    else
      return false, _;
    end if;
  end function);
end intrinsic;

declare type _PGGSetSubgrpcls[_PGGSubgrpcls];

declare type PGGSetSubgrpcls2[PGGSubgrpcls2]: _PGGSetSubgrpcls;
declare attributes PGGSetSubgrpcls2: conjugacy, statistic, tranche, root_node, count;
declare type PGGSubgrpcls2: _PGGSubgrpcls;
declare attributes PGGSubgrpcls2: up, stat, parent, group, node, id;
declare type PGGSetSubgrpcls2_Branch;
declare attributes PGGSetSubgrpcls2_Branch: up, stat, parent, down, quotient;
declare type PGGSetSubgrpcls2_Ambig;
declare attributes PGGSetSubgrpcls2_Ambig: up, stat, parent, down;

intrinsic PGG_SubgroupClasses(conj :: PGGConj : Tranche:=false, Statistic:=false) -> PGGSetSubgrpcls2
  {The conjugacy classes of subgroups of conj`group.}
  X := New(PGGSetSubgrpcls2);
  X`conjugacy := conj;
  X`tranche := Start(Tranche cmpne false select Tranche else PGGAlg_Tranche_OrbitIndex_Make(:Verbosity:=2, Filter:=PGG_Expression_BinOp('and', PGG_Expression_BinOp('le', PGG_Expression_FreeVariable("idx"), PGG_Expression_Const(8)) ,PGG_Expression_BinOp('le', PGG_Expression_FreeVariable("ridx"), PGG_Expression_Const(2)))), conj);
  X`statistic := Statistic cmpne false select Statistic else PGGStat_Tup_Make(<PGGStat_Order_Make(), PGGStat_FactorDegrees_Make()>);
  X`count := 0;
  X`root_node := MakeLeaf(X, conj`group, X);
  return X;
end intrinsic;

intrinsic MakeLeaf(X :: PGGSetSubgrpcls2, G :: GrpPerm, Up : Stat:=false) -> PGGSubgrpcls2
  {A new leaf node.}
  N := New(PGGSubgrpcls2);
  N`parent := X;
  N`group := G;
  X`count +:= 1;
  N`id := X`count;
  N`up := Up;
  if Stat cmpne false then
    N`stat := Stat;
  end if;
  return N;
end intrinsic;

intrinsic 'eq'(X :: PGGSetSubgrpcls2, Y :: PGGSetSubgrpcls2) -> BoolElt
  {Equality}
  return IsIdentical(X, Y);
end intrinsic;

intrinsic Parent(C :: PGGSubgrpcls2) -> PGGSetSubgrpcls2
  {Parent.}
  return C`parent;
end intrinsic;

intrinsic Rep(C :: PGGSubgrpcls2) -> PGGSetSubgrpcls2
  {Representative.}
  return C`group;
end intrinsic;

intrinsic Hash(C :: PGGSubgrpcls2) -> RngIntElt
  {Hash.}
  return C`id;
end intrinsic;

intrinsic 'eq'(C1 :: PGGSubgrpcls2, C2 :: PGGSubgrpcls2) -> BoolElt
  {Equality.}
  require Parent(C1) eq Parent(C2): "from different sets";
  assert IsIdentical(C1, C2) eq (C1`id eq C2`id);
  // assert IsIdentical(C1, C2) eq IsConjugate(C1`parent`conjugacy`group, C1`group, C2`group);
  return IsIdentical(C1, C2);
end intrinsic;

intrinsic IsCoercible(X :: PGGSetSubgrpcls2, C) -> BoolElt, .
  {True if C is coercible into X.}
  return false, "wrong type";
end intrinsic;

intrinsic IsCoercible(X :: PGGSetSubgrpcls2, C :: PGGSubgrpcls2) -> BoolElt, .
  {"}
  if Parent(C) eq X then
    return true, C;
  else
    return false, "wrong parent";
  end if;
end intrinsic;

intrinsic IsCoercible(X :: PGGSetSubgrpcls2, C :: GrpPerm) -> BoolElt, .
  {"}
  if C subset X`conjugacy`group then
    return true, Find(X`root_node, C);
  else
    return false, "not a subgroup of the right group";
  end if;
end intrinsic;

intrinsic Find(N :: PGGSubgrpcls2, G :: GrpPerm) -> PGGSubgrpcls2
  {Finds the conjugacy class of G.}
  if IsConjugate(N`parent`conjugacy`group, N`group, G) then
    return N;
  else
    Reset(N`parent`tranche);
    while true do
      ok, t := HasTranche(N`parent`tranche);
      if ok then
        for i in Tranche(N`parent`tranche) do
          q := CosetAction(N`parent`conjugacy`group, Group(i));
          Nstat := GroupStat(N`parent`statistic, q(N`group));
          Gstat := GroupStat(N`parent`statistic, q(G));
          if Nstat ne Gstat then
            // we have found a distinguishing statistic, so insert a branch here
            B := New(PGGSetSubgrpcls2_Branch);
            B`quotient := q;
            B`up := N`up;
            N`up := B;
            if assigned N`stat then
              B`stat := N`stat;
            end if;
            N`stat := Nstat;
            B`parent := N`parent;
            B`down := AssociativeArray();
            B`down[Nstat] := N;
            M := MakeLeaf(N`parent, G, B : Stat:=Gstat);
            B`down[Gstat] := M;
            case Type(B`up):
            when PGGSetSubgrpcls2:
              assert B`up eq B`parent;
              B`up`root_node := B;
            when PGGSetSubgrpcls2_Branch:
              B`up`down[B`stat] := B;
            else
              assert false;
            end case;
            return M;
          end if;
          Forget(i);
        end for;
      else
        // we have failed to find a distinguishing statistic, so insert an ambiguous node here
        B := New(PGGSetSubgrpcls2_Ambig);
        B`up := N`up;
        N`up := B;
        if assigned N`stat then
          B`stat := N`stat;
          delete N`stat;
        end if;
        B`parent := N`parent;
        M := MakeLeaf(N`parent, G, B);
        B`down := [* N, M *];
        case Type(B`up):
        when PGGSetSubgrpcls2:
          assert B`up eq B`parent;
          B`up`root_node := B;
        when PGGSetSubgrpcls2_Branch:
          B`up`down[B`stat] := B;
        else
          assert false;
        end case;
        return M;
      end if;
    end while;
  end if;
end intrinsic;

intrinsic Find(B :: PGGSetSubgrpcls2_Branch, G :: GrpPerm) -> PGGSubgrpcls2
  {"}
  Gstat := GroupStat(B`parent`statistic, B`quotient(G));
  ok, N := IsDefined(B`down, Gstat);
  if ok then
    return Find(N, G);
  else
    M := MakeLeaf(B`parent, G, B : Stat:=Gstat);
    B`down[Gstat] := M;
    return M;
  end if;
end intrinsic;

intrinsic Find(A :: PGGSetSubgrpcls2_Ambig, G :: GrpPerm) -> PGGSubgrpcls2
  {"}
  for N in A`down do
    if IsConjugate(A`parent`conjugacy`group, N`group, G) then
      return N;
    end if;
  end for;
  N := MakeLeaf(A`parent, G, A);
  Append(~A`down, N);
  return N;
end intrinsic;

intrinsic Shape(N :: PGGSubgrpcls2) -> .
  {The shape of the node N.}
  return 1;
end intrinsic;

intrinsic Shape(N :: PGGSetSubgrpcls2_Branch) -> .
  {"}
  return [* Shape(N`down[k]) : k in Keys(N`down) *];
end intrinsic;

intrinsic Shape(N :: PGGSetSubgrpcls2_Ambig) -> .
  {"}
  return #N`down;
end intrinsic;

intrinsic Depths(N :: PGGSubgrpcls2) -> .
  {The depths of the leaves of N.}
  return {* 0 *};
end intrinsic;

intrinsic Depths(N :: PGGSetSubgrpcls2_Branch) -> .
  {"}
  return &join[{* (d+1)^^Multiplicity(ds, d) : d in MultisetToSet(ds) *} where ds := Depths(N`down[k]) : k in Keys(N`down) ];
end intrinsic;

intrinsic Depths(N :: PGGSubgrpcls2) -> .
  {"}
  return {* 0^^#N`down *};
end intrinsic;

declare type PGGSetSubgrpcls[PGGSubgrpcls]: _PGGSetSubgrpcls;
declare attributes PGGSetSubgrpcls: overgroup, class_function, eq_op, subset_op;
declare type PGGSubgrpcls: _PGGSubgrpcls;
declare attributes PGGSubgrpcls: subgroup, parent, class_function_value, hash;

intrinsic PGG_SubgroupClasses(G :: GrpPerm : ClassFunction:=4) -> PGGSetSubgrpcls
  {The conjugacy classes of subgroups of G.}
  X := New(PGGSetSubgrpcls);
  X`overgroup := G;
  case ClassFunction:
  when 1:
    X`class_function := func<H | <#H, Hash(H), {*cf(x[3])^^x[2] : x in Classes(H)*}>>
      where cf := ClassMap(G);
  when 2:
    X`class_function := func<H | <#H, GroupName(H)>>;
  when 3:
    X`class_function := func<H | <#H, {* /* #o eq 32 select <#o, -1, "", Trans32Identify(Go)> else */ #o le TransitiveGroupDatabaseLimit() and #o ne 32 select <#o, TransitiveGroupIdentification(Go), "", <-1,-1,-1,-1>> else <#o, -1, GroupName(Go),<-1,-1,-1,-1>> where Go:=OrbitImage(G,o) : o in Orbits(H)*}>>;
  when 4:
    X`class_function := func<H | <#H, [#(N meet H) : N in Ns]>>
      where Ns := #all_Ns le limit select all_Ns else ([all_Ns[i^s] : i in [1..limit]] where s := Random(SymmetricGroup(#all_Ns)))
      where limit := Infinity()
      where all_Ns := [x`subgroup : x in NormalSubgroups(G : IndexLimit:=index_limit)]
      where index_limit := 2;
  else
    assert false;
  end case;
  X`eq_op := func<x, y | (x`hash eq y`hash) and (x`class_function_value eq y`class_function_value) and IsConjugate(Parent(x)`overgroup, x`subgroup, y`subgroup)>;
  X`subset_op := func<x, y | IsConjugateSubgroup(x`parent`overgroup, y`subgroup, x`subgroup)>;
  return X;
end intrinsic;

intrinsic PGG_Subgroups(G :: GrpPerm : RandomClass:=false) -> PGGSetSubgrpcls
  {The subgroups of G, as classes.}
  X := New(PGGSetSubgrpcls);
  X`overgroup := G;
  X`class_function := RandomClass select func<H | Random(1000000000)> else func<H | H>;
  X`eq_op := func<x, y | x`subgroup eq y`subgroup>;
  X`subset_op := func<x, y | x`subgroup subset y`subgroup>;
  return X;
end intrinsic;

intrinsic Group(X :: PGGSetSubgrpcls) -> GrpPerm
  {The group.}
  return X`overgroup;
end intrinsic;

intrinsic 'eq'(X :: PGGSetSubgrpcls, Y :: PGGSetSubgrpcls) -> BoolElt
  {Equality.}
  return IsIdentical(X, Y);
end intrinsic;

intrinsic IsCoercible(X :: PGGSetSubgrpcls, H) -> BoolElt, .
  {IsCoercible.}
  return false, "wrong type";
end intrinsic;

intrinsic IsCoercible(X :: PGGSetSubgrpcls, H :: GrpPerm) -> BoolElt, .
  {"}
  if H subset X`overgroup then
    x := New(PGGSubgrpcls);
    x`subgroup := H;
    x`parent := X;
    x`class_function_value := x`parent`class_function(H);
    x`hash := Hash(x`class_function_value);
    return true, x;
  else
    return false, "not a subgroup of the right group";
  end if;
end intrinsic;

intrinsic IsCoercible(X :: PGGSetSubgrpcls, H :: PGGSubgrpcls) -> BoolElt, .
  {"}
  if Parent(H) eq X then
    return true, H;
  elif Parent(H)`overgroup subset X`overgroup then
    return true, X ! Rep(H);
  else
    return false, _;
  end if;
end intrinsic;

intrinsic Parent(x :: PGGSubgrpcls) -> PGGSetSubgrpcls
  {The parent set.}
  return x`parent;
end intrinsic;

intrinsic Hash(x :: PGGSubgrpcls) -> RngIntElt
  {Hash.}
  return x`hash;
end intrinsic;

intrinsic Rep(x :: PGGSubgrpcls) -> GrpPerm
  {A representative.}
  return x`subgroup;
end intrinsic;

intrinsic 'eq'(x :: PGGSubgrpcls, y :: PGGSubgrpcls) -> BoolElt
  {Equality.}
  assert Parent(x) eq Parent(y);
  return Parent(x)`eq_op(x, y);
end intrinsic;

intrinsic 'subset'(x :: PGGSubgrpcls, y :: PGGSubgrpcls) -> BoolElt
  {Subset.}
  assert Parent(x) eq Parent(y);
  return Parent(x)`subset_op(x, y);
end intrinsic;

declare type PGGTimer;
declare attributes PGGTimer: last_time, times, counts, labels, current_label, idxs;

intrinsic PGG_Timer() -> PGGTimer
  {A new timer.}
  t := New(PGGTimer);
  t`last_time := Cputime();
  t`times := [RealField()|];
  t`counts := [Integers()|];
  t`labels := [PowerSequence(Strings())|];
  t`current_label := [Strings()|];
  t`idxs := AssociativeArray(PowerSequence(Strings()));
  return t;
end intrinsic;

intrinsic FindIndex(t :: PGGTimer, label :: [MonStgElt]) -> RngIntElt
  {The index of the given label. If it doesn't exist, creates it first.}
  ok, i := IsDefined(t`idxs, label);
  if ok then
    return i;
  end if;
  Append(~t`times, 0);
  Append(~t`counts, 0);
  Append(~t`labels, label);
  t`idxs[label] := #t`labels;
  return #t`labels;
end intrinsic;

intrinsic Update(t :: PGGTimer, c :: RngIntElt, label :: [MonStgElt])
  {Assigns the accumulated time to the given label.}
  i := FindIndex(t, label);
  now := Cputime();
  t`times[i] +:= now - t`last_time;
  t`counts[i] +:= c;
  t`last_time := now;
end intrinsic;

intrinsic Update(t :: PGGTimer, label :: [MonStgElt])
  {"}
  Update(t, 0, label);
end intrinsic;

intrinsic Push(t :: PGGTimer, x :: MonStgElt)
  {Assings time to the current label, then appends x to the label.}
  Update(t, t`current_label);
  Append(~t`current_label, x);
end intrinsic;

intrinsic Pop(t :: PGGTimer, n :: RngIntElt)
  {Assigns time to the current label, then pops n items from the label.}
  error if #t`current_label lt n, "n greater than label length";
  Update(t, 1, t`current_label);
  t`current_label := t`current_label[1..#t`current_label-n];
end intrinsic;

intrinsic Pop(t :: PGGTimer, n :: RngIntElt, x :: MonStgElt)
  {Assigns time to the current label, then pops n items from the label, the nth being x.}
  error if #t`current_label lt n, "n greater than label length";
  error if t`current_label[#t`current_label-n+1] ne x, "incorrect label entry";
  Update(t, 1, t`current_label);
  t`current_label := t`current_label[1..#t`current_label-n];
end intrinsic;

intrinsic Pop(t :: PGGTimer, x :: MonStgElt)
  {Assigns time to the current label, then pops the last item from the label, which must be x.}
  Pop(t, 1, x);
end intrinsic;

intrinsic Pop(t :: PGGTimer)
  {Assigns time to the current label, then pops the last item from the label.}
  Pop(t, 1);
end intrinsic;

intrinsic Swap(t :: PGGTimer, x :: MonStgElt)
  {Assigns time to the current label, then swaps the last item from the label to x.}
  error if #t`current_label lt 1, "label too short";
  Update(t, 1, t`current_label);
  t`current_label[#t`current_label] := x;
end intrinsic;

intrinsic Log(t :: PGGTimer, x :: MonStgElt)
  {Assigns time to the current label with x appended.}
  Update(t, 1, Append(t`current_label, x));
end intrinsic;

intrinsic Tree(t :: PGGTimer : Total:="TOTAL", Other:="OTHER") -> Tup
  {A tree representation of t.}
  procedure insert(~node, label, tm, ct)
    node[2] +:= tm;
    if #label gt 0 then
      for i in [1..#node[4]] do
        if node[4][i][1] eq label[1] then
          insert(~node[4][i], label[2..#label], tm, ct);
          return;
        end if;
      end for;
      Append(~node[4], <label[1], 0.0, 0, [**]>);
      insert(~node[4][#node[4]], label[2..#label], tm, ct);
    else
      node[3] +:= ct;
    end if;
  end procedure;
  procedure rest(~node)
    if #node[4] gt 0 then
      Append(~node[4], <Other, node[2] - &+[n[2] : n in node[4]], 0, [**]>);
      for i in [1..#node[4]] do
        rest(~node[4][i]);
      end for;
    end if;
  end procedure;
  root := <Total, 0.0, 0, [**]>;
  for i in [1..#t`labels] do
    insert(~root, t`labels[i], t`times[i], t`counts[i]);
  end for;
  rest(~root);
  return root;
end intrinsic;

intrinsic PrintTree(t :: PGGTimer)
  {Prints t as a tree.}
  procedure pr(node, depth)
    if node[3] ge 1 or node[2] ge 0.01 then
      printf "%o%6.2o", &cat[Strings() | "  " : i in [1..depth]], node[2];
      if node[3] ne 0 then
        printf " (%o)", node[3];
      end if;
      printf " %o\n", node[1];
      for n in node[4] do
        pr(n, depth+1);
      end for;
    end if;
  end procedure;
  pr(Tree(t), 0);
end intrinsic;

declare type PGGAttr;
declare attributes PGGAttr: name, arguments;

intrinsic Print(x :: PGGAttr, lvl :: MonStgElt)
  {Print.}
  case lvl:
  when "Magma":
    printf "PGG_Attribute(%m, %m)", Name(x), Arguments(x);
  else
    printf "%o", Name(x);
    if #Arguments(x) gt 0 then
      printf "(%o)", Join([Sprintf("%o",a) : a in Arguments(x)], ",");
    end if;
  end case;
end intrinsic;

intrinsic Name(a :: PGGAttr) -> MonStgElt
  {The name.}
  return a`name;
end intrinsic;

intrinsic Arguments(a :: PGGAttr) -> []
  {The arguments.}
  return a`arguments;
end intrinsic;

intrinsic PGG_Attribute(name :: MonStgElt, arguments :: [PGGAttr]) -> PGGAttr
  {An attribute.}
  a := New(PGGAttr);
  a`name := name;
  a`arguments := arguments;
  return a;
end intrinsic;

intrinsic PGG_Attribute(name :: MonStgElt) -> PGGAttr
  {"}
  a := New(PGGAttr);
  a`name := name;
  a`arguments := [];
  return a;
end intrinsic;

intrinsic PGG_Attribute() -> PGGAttr
  {"}
  a := New(PGGAttr);
  a`name := "";
  a`arguments := [];
  return a;
end intrinsic;

intrinsic PGG_Attribute_IsCoercible(x) -> BoolElt, .
  {True if x is coercible to a PGGAttr.}
  return false, "wrong type";
end intrinsic;

intrinsic PGG_Attribute_IsCoercible(x :: PGGAttr) -> BoolElt, .
  {"}
  return true, x;
end intrinsic;

intrinsic PGG_Attribute_IsCoercible(x :: MonStgElt) -> BoolElt, .
  {"}
  // process each character in turn
  stack := [PGG_Attribute()];
  i := 0;
  for i in [1..#x] do
    c := x[i];
    assert #stack ge 1;
    case c:
    when ",":
      if #stack lt 2 then
        return false, Sprintf("parse error: %o: illegal ','", i);
      end if;
      Append(~stack[#stack-1]`arguments, stack[#stack]);
      stack[#stack] := PGG_Attribute();
    when "[":
      Append(~stack, PGG_Attribute());
    when "]":
      if #stack lt 2 then
        return false, Sprintf("parse error: %o: illegal ')'");
      end if;
      Append(~stack[#stack-1]`arguments, stack[#stack]);
      stack := stack[1..#stack-1];
    else
      stack[#stack]`name cat:= c;
    end case;
  end for;
  assert #stack ge 1;
  if #stack gt 1 then
    return false, Sprintf("parse error: end of input: too few ')'");
  end if;
  // done
  return true, stack[1];
end intrinsic;

declare type PGGIter;
declare attributes PGGIter: cache;

declare type PGGIter_List: PGGIter;
declare attributes PGGIter_List: list, idx;

declare type PGGIter_Filter: PGGIter;
declare attributes PGGIter_Filter: iter, filter;

intrinsic PGG_ToIter(xs :: []) -> PGGIter
  {Makes an iterator.}
  X := New(PGGIter_List);
  X`list := SequenceToList(xs);
  X`idx := 0;
  return X;
end intrinsic;

intrinsic PGG_ToIter(xs :: List) -> PGGIter
  {Makes an iterator.}
  X := New(PGGIter_List);
  X`list := xs;
  X`idx := 0;
  return X;
end intrinsic;

intrinsic HasNext(X :: PGGIter_List) -> BoolElt, .
  {True if X has a next item.}
  if X`idx lt #X`list then
    X`idx +:= 1;
    return true, X`list[X`idx];
  else
    return false, _;
  end if;
end intrinsic;

intrinsic ToList(X :: PGGIter) -> List
  {Converts X to a list.}
  ret := [];
  while true do
    ok, x := HasNext(X);
    if ok then
      Append(~ret, x);
    else
      return ret;
    end if;
  end while;
end intrinsic;

// we make a specialized version for the common case of just dealing with lists directly
intrinsic ToList(X :: PGGIter_List) -> List
  {"}
  if X`idx eq 0 then
    return X`list;
  else
    return X`list[X`idx+1..#X`list];
  end if;
end intrinsic;

intrinsic ToSequence(X :: PGGIter) -> []
  {Converts X to a sequence.}
  return [x : x in ToList(X)];
end intrinsic;

intrinsic Filter(X :: PGGIter, f) -> PGGIter
  {The x in X such that f(x) is true.}
  Y := New(PGGIter_Filter);
  Y`iter := X;
  Y`filter := f;
  return Y;
end intrinsic;

intrinsic HasNext(X :: PGGIter_Filter) -> BoolElt, .
  {True if X has a next item.}
  while true do
    ok, x := HasNext(X`iter);
    if ok then
      if X`filter(x) then
        return true, x;
      end if;
    else
      return false, _;
    end if;
  end while;
end intrinsic;

intrinsic Reverse(X :: PGGIter) -> PGGIter
  {The reverse.}
  return PGG_ToIter(Reverse(ToList(X)));
end intrinsic;

intrinsic Shuffle(X :: PGGIter) -> PGGIter
  {Randomize the order of X.}
  xs := ToList(X);
  if #xs eq 0 then
    return X;
  else
    g := Random(SymmetricGroup(#xs));
    return PGG_ToIter([* xs[i^g] : i in [1..#xs] *]);
  end if;
end intrinsic;

intrinsic SortBy(X :: PGGIter, keyfunc :: UserProgram) -> PGGIter
  {Sorts X so that keyfunc(x) are naturally sorted.}
  xs := ToList(X);
  keys := [keyfunc(x) : x in xs];
  Sort(~keys, ~permut);
  return PGG_ToIter([* xs[i^permut] : i in [1..#xs] *]);
end intrinsic;

declare type PGGExpr;
declare attributes PGGExpr: free_vars;

declare type PGGExpr_FreeVar: PGGExpr;
declare attributes PGGExpr_FreeVar: name;

declare type PGGExpr_Unop: PGGExpr;
declare attributes PGGExpr_Unop: op, arg1;

declare type PGGExpr_Binop: PGGExpr;
declare attributes PGGExpr_Binop: op, arg1, arg2;

declare type PGGExpr_Seqop: PGGExpr;
declare attributes PGGExpr_Seqop: op, args;

declare type PGGExpr_Const: PGGExpr;
declare attributes PGGExpr_Const: val;

intrinsic Print(x :: PGGExpr_FreeVar)
  {Print.}
  printf "%o", x`name;
end intrinsic;

intrinsic Print(x :: PGGExpr_Unop)
  {"}
  printf "%o(%o)", Type(x`op) eq Intrinsic select GetIntrinsicName(x`op) else "<unknown>", x`arg1;
end intrinsic;

intrinsic Print(x :: PGGExpr_Binop)
  {"}
  printf "%o(%o, %o)", Type(x`op) eq Intrinsic select GetIntrinsicName(x`op) else "<unknown>", x`arg1, x`arg2;
end intrinsic;

intrinsic Print(x :: PGGExpr_Seqop)
  {"}
  printf "%o([%o])", Type(x`op) eq Intrinsic select GetIntrinsicName(x`op) else "<unknown>", Join([Sprintf("%o", a) : a in x`args], ", ");
end intrinsic;

intrinsic Print(x :: PGGExpr_Const)
  {"}
  printf "%o", x`val;
end intrinsic;

intrinsic FreeVariables(x :: PGGExpr) -> {}
  {The free variables in the expression.}
  if not assigned x`free_vars then
    x`free_vars := PowerSet(Strings()) ! _FreeVariables(x);
  end if;
  return x`free_vars;
end intrinsic;

intrinsic PGG_Expression_FreeVariable(name :: MonStgElt) -> PGGExpr_FreeVar
  {The free variable with the given name.}
  x := New(PGGExpr_FreeVar);
  x`name := name;
  return x;
end intrinsic;

intrinsic PGG_Expression_UnOp(op, arg1 :: PGGExpr) -> PGGExpr_Unop
  {The unary operation op (a function or intrinsic) with argument arg1.}
  x := New(PGGExpr_Unop);
  x`op := op;
  x`arg1 := arg1;
  return x;
end intrinsic;

intrinsic PGG_Expression_BinOp(op, arg1 :: PGGExpr, arg2 :: PGGExpr) -> PGGExpr_Binop
  {The binary operation op (a function or intrinsic) with arguments arg1 and arg2.}
  x := New(PGGExpr_Binop);
  x`op := op;
  x`arg1 := arg1;
  x`arg2 := arg2;
  return x;
end intrinsic;

intrinsic PGG_Expression_SeqOp(op, args :: [PGGExpr]) -> PGGExpr_Seqop
  {The operation op with one argument, the sequence args.}
  x := New(PGGExpr_Seqop);
  x`op := op;
  x`args := args;
  return x;
end intrinsic;

intrinsic PGG_Expression_Const(val) -> PGGExpr_Const
  {The constant expression val.}
  x := New(PGGExpr_Const);
  x`val := val;
  return x;
end intrinsic;

intrinsic _FreeVariables(x :: PGGExpr_FreeVar) -> {}
  {"}
  return {x`name};
end intrinsic;

intrinsic _FreeVariables(x :: PGGExpr_Unop) -> {}
  {"}
  return FreeVariables(x`arg1);
end intrinsic;

intrinsic _FreeVariables(x :: PGGExpr_Binop) -> {}
  {"}
  return FreeVariables(x`arg1) join FreeVariables(x`arg2);
end intrinsic;

intrinsic _FreeVariables(x :: PGGExpr_Const) -> {}
  {"}
  return {};
end intrinsic;

intrinsic _FreeVariables(x :: PGGExpr_Seqop) -> {}
  {"}
  return #x`args eq 0 select {} else &join[FreeVariables(arg) : arg in x`args];
end intrinsic;

intrinsic Evaluate(x :: PGGExpr, vars :: UserProgram) -> .
  {Evaluates x.}
  return _Evaluate(x, vars);
end intrinsic;

intrinsic Evaluate(x :: PGGExpr, vars :: Assoc) -> .
  {Evaluates x.}
  return _Evaluate(x, func<n | vars[n]>);
end intrinsic;

intrinsic EvaluateLazy(x :: PGGExpr, lazy_vars :: Assoc) -> .
  {Evaluates x.}
  store := NewStore();
  function vars(name)
    ok, x := StoreIsDefined(store, name);
    if ok then
      return x;
    end if;
    x := lazy_vars[name]();
    StoreSet(store, name, x);
    return x;
  end function;
  return _Evaluate(x, vars);
end intrinsic;

intrinsic EvaluateLazy(x :: PGGExpr, lazy_vars :: UserProgram) -> .
  {Evaluates x.}
  store := NewStore();
  function vars(name)
    ok, x := StoreIsDefined(store, name);
    if ok then
      return x;
    end if;
    x := lazy_vars(name);
    StoreSet(store, name, x);
    return x;
  end function;
  return _Evaluate(x, vars);
end intrinsic;

intrinsic _Evaluate(x :: PGGExpr_FreeVar, vars) -> .
  {Evaluates x.}
  return vars(x`name);
end intrinsic;

intrinsic _Evaluate(x :: PGGExpr_Unop, vars) -> .
  {"}
  return x`op(Evaluate(x`arg1, vars));
end intrinsic;

intrinsic _Evaluate(x :: PGGExpr_Binop, vars) -> .
  {"}
  return x`op(Evaluate(x`arg1, vars), Evaluate(x`arg2, vars));
end intrinsic;

intrinsic _Evaluate(x :: PGGExpr_Const, vars) -> .
  {"}
  return x`val;
end intrinsic;

intrinsic _Evaluate(x :: PGGExpr_Seqop, vars) -> .
  {"}
  return x`op([Evaluate(arg, vars) : arg in x`args]);
end intrinsic;


declare type PGGAlg;

declare type PGGAlgState;
declare attributes PGGAlgState: algorithm;

declare type PGGAlg_GaloisGroup: PGGAlg;

declare type PGGAlg_GaloisGroup_Builtin: PGGAlg_GaloisGroup;

declare type PGGAlg_GaloisGroup_SinglyRamified: PGGAlg_GaloisGroup;

declare type PGGAlg_GaloisGroup_ResolventMethod: PGGAlg_GaloisGroup;
declare attributes PGGAlg_GaloisGroup_ResolventMethod: groups_alg, resolvent_alg, conjugacy_alg, use_easy_resolvents;

declare type PGGAlg_ResGroups: PGGAlg;
declare type PGGAlgState_ResGroups: PGGAlgState;

declare type PGGAlg_ResGroups_All: PGGAlg_ResGroups;
declare attributes PGGAlg_ResGroups_All: subgroup_choice, statistic;

declare type PGGAlgState_ResGroups_All: PGGAlgState_ResGroups;
declare attributes PGGAlgState_ResGroups_All: conjugacy, overgroup, possible_groups, choice_state;

declare type PGGAlg_ResGroups_Maximal: PGGAlg_ResGroups;
declare attributes PGGAlg_ResGroups_Maximal: subgroup_choice, statistic, descend, reprocess, reset, useful, blacklist, dedupe;

declare type PGGAlgState_ResGroups_Maximal: PGGAlgState_ResGroups;
declare attributes PGGAlgState_ResGroups_Maximal: conjugacy, overgroup, choice_state, conjugacy_classes
  , resolvents    // sequence of records of information about each resolvent used
  , id_to_node    // sequence of nodes
  , class_to_node // associative array: class -> node
  , current_layer // the galois group is a subgroup of at least one of these
  , blacklist     // the galois group is not a subgroup of any of these
  ;

declare type PGGAlg_ResGroups_RootsMaximal: PGGAlg_ResGroups;
declare attributes PGGAlg_ResGroups_RootsMaximal: dedupe;

declare type PGGAlgState_ResGroups_RootsMaximal: PGGAlgState_ResGroups;
declare attributes PGGAlgState_ResGroups_RootsMaximal: conjugacy, overgroup, cur_group, possible_subgroups, conjugacy_classes;

declare type PGG_ResGroups_Maximal_Node;
declare attributes PGG_ResGroups_Maximal_Node: id, class, children, possible_children, state, maybe_equal, maybe_subgroup, seen_resolvents, blacklist_done;

declare type PGGAlg_Tranche: PGGAlg;
declare attributes PGGAlg_Tranche: verbosity;
declare type PGGAlg_Tranche_All: PGGAlg_Tranche;
declare type PGGAlg_Tranche_Index: PGGAlg_Tranche;
declare attributes PGGAlg_Tranche_Index: filter, sort_key;
declare type PGGAlg_Tranche_OrbitIndex: PGGAlg_Tranche;
declare attributes PGGAlg_Tranche_OrbitIndex: filter, sort_key;

declare type PGGAlgState_Tranche: PGGAlgState;
declare attributes PGGAlgState_Tranche: conjugacy;
declare type PGGAlgState_Tranche_All: PGGAlgState_Tranche;
declare attributes PGGAlgState_Tranche_All: all_groups, tranche;
declare type PGGAlgState_Tranche_Index: PGGAlgState_Tranche;
declare attributes PGGAlgState_Tranche_Index: indices, ii, all_groups, tranche;
declare type PGGAlgState_Tranche_OrbitIndex: PGGAlgState_Tranche;
declare attributes PGGAlgState_Tranche_OrbitIndex: indices, ii, si, all_groups, all_stabilizers, cur_stabilizers, tranche;

declare type PGGAlg_ResChoice: PGGAlg;
declare type PGGAlg_ResChoice_Tranche: PGGAlg_ResChoice;
declare attributes PGGAlg_ResChoice_Tranche: tranche_alg, priority;

declare type PGGAlgState_ResChoice_Tranche: PGGAlgState;
declare attributes PGGAlgState_ResChoice_Tranche: tranche_state, parent, overgroup;

declare type PGGAlg_ResPriority: PGGAlg;
declare type PGGAlg_ResPriority_Null: PGGAlg_ResPriority;
declare type PGGAlg_ResPriority_Random: PGGAlg_ResPriority;
declare type PGGAlg_ResPriority_Reverse: PGGAlg_ResPriority;
declare attributes PGGAlg_ResPriority_Reverse: priority;
declare type PGGAlg_ResPriority_Key: PGGAlg_ResPriority;
declare attributes PGGAlg_ResPriority_Key: key;

declare type PGGAlgState_TrancheItem;
declare attributes PGGAlgState_TrancheItem: state, idx, tidx, subgroup;

declare type PGGAlg_ResEval: PGGAlg;

declare type PGGAlg_ResEval_Global: PGGAlg_ResEval;

declare type PGGAlgState_ResEval_Global: PGGAlgState;
declare attributes PGGAlgState_ResEval_Global: conjugacy, base_field_model, pol_model, precision, complex_roots;

declare type PGGAlg_Conjugacy: PGGAlg;

declare type PGGAlg_Conjugacy_Symmetric: PGGAlg_Conjugacy;
declare attributes PGGAlg_Conjugacy_Symmetric: galois_group_alg;

declare type PGGAlg_Conjugacy_Factors: PGGAlg_Conjugacy;
declare attributes PGGAlg_Conjugacy_Factors: next;

declare type PGGAlg_Conjugacy_RamTower: PGGAlg_Conjugacy;
declare attributes PGGAlg_Conjugacy_RamTower: next;

declare type PGGConj;
declare attributes PGGConj
  : group           // the group in which the Galois group is defined up to conjugacy
  , base_field      // the base field of the Galois group
  , parent_subgroup // when part of a larger Galois group, this group is a quotient of a subgroup of the parent group; parent_subgroup is the subgroup
  , parent_quotient // the quotient map from parent_subgroup to this group
  , is_known        // [* false *] or [* true, G *] where G is the actual Galois group
  , is_transitive   // true if the actual Galois group is known to be transitive
  , overgroup       // an overgroup of the actual Galois group (a subgroup of `group`)
  , orbits_of_subgroups // for cacheing OrbitsOfSubgroups
  ;

declare type PGGConj_Symmetric: PGGConj;
declare attributes PGGConj_Symmetric: pol, top_field;

declare type PGGConj_Factors: PGGConj;
declare attributes PGGConj_Factors: factors, orbits_of_subgroups_from;

declare type PGGConj_Tower: PGGConj;
declare attributes PGGConj_Tower: tower, top_field, pol, orbits_of_subgroups_above;

declare type PGGGloMod;

declare type PGGGloMod_Rational: PGGGloMod;
declare attributes PGGGloMod_Rational: local_field, global_field, embedding;

declare type PGGGloMod_Symmetric: PGGGloMod;
declare attributes PGGGloMod_Symmetric: local_pol, global_pol, local_field, global_field, embedding;

declare type PGGGloMod_Factors: PGGGloMod;
declare attributes PGGGloMod_Factors: factors;

declare type PGGGloMod_Tower: PGGGloMod;
declare attributes PGGGloMod_Tower: tower, global_pol, global_pol_root;

declare type PGGStat;
declare type PGGStat_HasRoot: PGGStat;
declare type PGGStat_NumRoots: PGGStat;
declare type PGGStat_FactorDegrees: PGGStat;
declare type PGGStat_FactorDegrees2: PGGStat;
declare type PGGStat_Degree: PGGStat;
declare type PGGStat_Order: PGGStat;
declare type PGGStat_AutGroup: PGGStat;
declare attributes PGGStat_AutGroup: conjugacy_classes;
declare type PGGStat_Tup: PGGStat;
declare attributes PGGStat_Tup: stats;
declare type PGGStat_Factors: PGGStat;
declare attributes PGGStat_Factors: stat;

declare type PGGStatVal;
declare attributes PGGStatVal: stat, value, hash;

declare type PGGOrder;
declare type PGGOrder_None: PGGOrder;
declare type PGGOrder_Random: PGGOrder;
declare type PGGOrder_Reverse: PGGOrder;
declare attributes PGGOrder_Reverse: order;
declare type PGGOrder_Key: PGGOrder;
declare attributes PGGOrder_Key: key;

intrinsic PGG_AllGroups() -> PGGAlg_ResGroups_All
  {The "AllGroups" group theory algorithm for the resolvent method.}
  return New(PGGAlg_ResGroups_All);
end intrinsic;

intrinsic Start(alg :: PGGAlg_ResGroups_All, conj :: PGGConj, overgroup :: GrpPerm) -> PGGAlgState_ResGroups_All
  {Starts the algorithm and returns its state.}
  assert overgroup subset conj`group;
  s := New(PGGAlgState_ResGroups_All);
  s`algorithm := alg;
  s`conjugacy := conj;
  s`overgroup := overgroup;
  // get a list of possible groups
  s`possible_groups := dedupe_conjugage_subgroups(conj`group, [G : x in Subgroups(Overgroup(conj) : IsSolvable, IsTransitive:=IsTransitive(conj)) | IsConsistent(conj, G) where G:=x`subgroup]);
  s`choice_state := Start(alg`subgroup_choice, s);
  vprint PGG_GaloisGroup: "#possible groups =", #s`possible_groups;
  return s;
end intrinsic;

intrinsic Start(alg :: PGGAlg_ResGroups_Maximal, conj :: PGGConj, overgroup :: GrpPerm) -> PGGAlgState_ResGroups_Maximal
  {"}
  assert overgroup subset conj`group;
  s := New(PGGAlgState_ResGroups_Maximal);
  s`algorithm := alg;
  s`conjugacy := conj;
  s`overgroup := overgroup;
  s`choice_state := Start(alg`subgroup_choice, s);
  s`resolvents := [**];
  s`id_to_node := [];
  s`class_to_node := AssociativeArray();
  s`conjugacy_classes := alg`dedupe select PGG_SubgroupClasses(conj) else PGG_Subgroups(conj`group : RandomClass);
  s`current_layer := [Node(s, Overgroup(conj))];
  s`blacklist := [];
  return s;
end intrinsic;

intrinsic Start(alg :: PGGAlg_ResGroups_RootsMaximal, conj :: PGGConj, overgroup :: GrpPerm) -> PGGAlgState_ResGroups_RootsMaximal
  {"}
  assert overgroup subset conj`group;
  s := New(PGGAlgState_ResGroups_RootsMaximal);
  s`algorithm := alg;
  s`conjugacy := conj;
  s`overgroup := overgroup;
  s`conjugacy_classes := (alg`dedupe select PGG_SubgroupClasses else PGG_Subgroups)(conj`group);
  s`cur_group := s`conjugacy_classes ! Overgroup(conj);
  return s;
end intrinsic;

intrinsic Node(s :: PGGAlgState_ResGroups_Maximal, G :: GrpPerm) -> PGG_ResGroups_Maximal_Node
  {The node of the graph of subgroups at G.}
  return Node(s, s`conjugacy_classes ! G);
end intrinsic;

intrinsic Node(s :: PGGAlgState_ResGroups_Maximal, G :: _PGGSubgrpcls) -> PGG_ResGroups_Maximal_Node
  {The node of the graph of subgroups at G.}
  // check if the node already exists
  ok, x := IsDefined(s`class_to_node, G);
  if ok then
    return x;
  end if;
  // make a new node
  x := New(PGG_ResGroups_Maximal_Node);
  x`id := #s`id_to_node + 1;
  x`class := G;
  x`state := s;
  x`maybe_equal := true;
  x`maybe_subgroup := true;
  x`seen_resolvents := {};
  x`blacklist_done := 0;
  s`class_to_node[G] := x;
  s`id_to_node[x`id] := x;
  return x;
end intrinsic;

intrinsic GroupStat(n :: PGG_ResGroups_Maximal_Node, q) -> PGGStatVal
  {The value of the statistic under the quotient q.}
  return GroupStat(n`state`algorithm`statistic, q(Rep(n`class)));
end intrinsic;

intrinsic 'eq'(x :: PGG_ResGroups_Maximal_Node, y :: PGG_ResGroups_Maximal_Node) -> BoolElt
  {Equality.}
  return x`id eq y`id;
end intrinsic;

intrinsic Hash(x :: PGG_ResGroups_Maximal_Node) -> RngIntElt
  {Hash.}
  return x`id;
end intrinsic;

intrinsic Children(x :: PGG_ResGroups_Maximal_Node) -> []
  {The nodes below x, i.e. corresponding to maximal subgroups.}
  if not assigned x`children then
    PGG_GlobalTimer_Push("groups");
    mgroups := MaximalSubgroups(Rep(x`class) : IsSolvable, IsTransitive:=IsTransitive(x`state`conjugacy));
    PGG_GlobalTimer_Swap("consistent");
    cgroups := [G : y in mgroups | IsConsistentWithSubgroup(x`state`conjugacy, G) where G:=y`subgroup];
    PGG_GlobalTimer_Swap("nodes");
    nodes := [Node(x`state, G) : G in cgroups];
    // groups := [Node(x`state, G) : y in MaximalSubgroups(Rep(x`class) : IsSolvable, IsTransitive:=IsTransitive(x`state`conjugacy)) | IsConsistentWithSubgroup(x`state`conjugacy, G) where G:=y`subgroup];
    PGG_GlobalTimer_Swap("dedupe");
    x`children := SetToSequence(SequenceToSet(nodes));
    PGG_GlobalTimer_Pop();
  end if;
  return x`children;
end intrinsic;

intrinsic PossibleChildren(x :: PGG_ResGroups_Maximal_Node : CheckBlacklist:=true) -> []
  {The nodes below x which are possibly overgroups of the Galois group.}
  if not assigned x`possible_children then
    PGG_GlobalTimer_Push("children");
    x`possible_children := Children(x);
    PGG_GlobalTimer_Pop();
  end if;
  if CheckBlacklist and x`state`algorithm`blacklist and (#x`state`blacklist gt x`blacklist_done) then
    PGG_GlobalTimer_Push("checking blacklist");
    x`possible_children := [n : n in x`possible_children | not exists{b : b in blacklist | n`class subset b`class}]
      where blacklist := x`state`blacklist[x`blacklist_done+1 .. #x`state`blacklist];
    x`blacklist_done := #x`state`blacklist;
    PGG_GlobalTimer_Pop();
  end if;
  return x`possible_children;
end intrinsic;

intrinsic IsDone(s :: PGGAlgState_ResGroups_All) -> BoolElt, GrpPerm
  {True if we have deduced the Galois group.}
  if #s`possible_groups eq 1 then
    return true, s`possible_groups[1];
  else
    assert #s`possible_groups gt 1;
    return false, _;
  end if;
end intrinsic;

intrinsic IsDone(s :: PGGAlgState_ResGroups_Maximal) -> BoolElt, GrpPerm
  {"}
  assert #s`current_layer gt 0;
  if (s`algorithm`dedupe select #s`current_layer eq 1 else forall{n : n in s`current_layer[2..#s`current_layer] | IsConjugate(s`overgroup, Rep(n`class), Rep(s`current_layer[1]`class))}) and #PossibleChildren(s`current_layer[1]) eq 0 then
    return true, Rep(s`current_layer[1]`class);
  else
    return false, _;
  end if;
end intrinsic;

intrinsic IsDone(s :: PGGAlgState_ResGroups_RootsMaximal) -> BoolElt, GrpPerm
  {"}
  if #PossibleSubgroups(s) eq 0 then
    return true, Rep(s`cur_group);
  else
    return false, _;
  end if;
end intrinsic;

intrinsic TheGroup(s :: PGGAlgState_ResGroups) -> GrpPerm
  {The Galois group, assuming it is already known.}
  ok, G := IsDone(s);
  assert ok;
  return G;
end intrinsic;

intrinsic PossibleSubgroups(s :: PGGAlgState_ResGroups_RootsMaximal) -> []
  {The subgroups of s`cur_group which have not yet been ruled out.}
  if not assigned s`possible_subgroups then
    PGG_GlobalTimer_Push("maximal subgroups");
    Gs := [x`subgroup : x in MaximalSubgroups(Rep(s`cur_group))];
    PGG_GlobalTimer_Swap("consistent");
    Gs := [G : G in Gs | IsConsistentWithSubgroup(s`conjugacy, G)];
    if s`algorithm`dedupe then
      PGG_GlobalTimer_Swap("dedupe");
      s`possible_subgroups := SetToSequence({s`conjugacy_classes!G : G in Gs});
    else
      s`possible_subgroups := [s`conjugacy_classes!G : G in Gs];
    end if;
    PGG_GlobalTimer_Pop();
    vprint PGG_GaloisGroup: "#possible_subgroups =", #s`possible_subgroups;
  end if;
  return s`possible_subgroups;
end intrinsic;

// intrinsic SubgroupTranche(s :: PGGAlgState_ResGroups_All) -> []
//   {A sequence of subgroups to consider using.}
//   case s`algorithm`subgroup_tranche:
//   when "All":
//     if not assigned s`possible_subgroups then
//       s`possible_subgroups := enumerate([x`subgroup : x in Subgroups(s`overgroup)]);
//     end if;
//     return [x : x in s`possible_subgroups];
//   when "Index":
//     if not assigned s`possible_subgroups then
//       s`possible_subgroups := rec<recformat<i, indices, all_groups, cur_groups> | indices:=Sort(Divisors(Order(s`overgroup))), all_groups:=[], cur_groups:=[]>;
//     end if;
//     while #s`possible_subgroups`cur_groups eq 0 do
//       n := 1+#s`possible_subgroups`all_groups;
//       error if n gt #s`possible_subgroups`indices, "ran out of possible distinguishing subgroups";
//       index := s`possible_subgroups`indices[n];
//       vprint PGG_GaloisGroup: "index =", index;
//       Append(~s`possible_subgroups`all_groups, [x`subgroup : x in Subgroups(s`overgroup : IndexEqual:=index)]);
//       s`possible_subgroups`cur_groups := enumerate(s`possible_subgroups`all_groups[n]);
//     end while;
//     return [x : x in s`possible_subgroups`cur_groups];
//   when "OrbitIndex":
//     if not assigned s`possible_subgroups then
//       s`possible_subgroups := rec<recformat<indices, ii, all_stabilizers, cur_stabilizers, si, all_groups, cur_groups> | indices:=Sort([<d,e> : e in Divisors(d), d in Divisors(Order(s`overgroup))]), ii:=0, all_stabilizers:=AssociativeArray(), si:=0, all_groups:=AssociativeArray(), cur_stabilizers:=[], cur_groups:=[]>;
//     end if;
//     while #s`possible_subgroups`cur_groups eq 0 do
//       while s`possible_subgroups`si ge #s`possible_subgroups`cur_stabilizers do
//         s`possible_subgroups`ii +:= 1;
//         s`possible_subgroups`si := 0;
//         idx, ridx := Explode(s`possible_subgroups`indices[s`possible_subgroups`ii]);
//         oidx := xdiv(idx, ridx);
//         vprint PGG_GaloisGroup: "idx, oidx, ridx =", idx, oidx, ridx;
//         if not IsDefined(s`possible_subgroups`all_stabilizers, oidx) then
//           s`possible_subgroups`all_stabilizers[oidx] := [Stabilizer(s`overgroup, os) : os in OrbitsOfSubgroups(s`conjugacy, oidx)];
//         end if;
//         s`possible_subgroups`cur_stabilizers := s`possible_subgroups`all_stabilizers[oidx];
//         assert forall{S : S in s`possible_subgroups`cur_stabilizers | Index(s`overgroup, S) eq oidx};
//       end while;
//       s`possible_subgroups`si +:= 1;
//       vprint PGG_GaloisGroup: "stabilizer", s`possible_subgroups`si, "of", #s`possible_subgroups`cur_stabilizers;
//       idx, ridx := Explode(s`possible_subgroups`indices[s`possible_subgroups`ii]);
//       if not IsDefined(s`possible_subgroups`all_groups, <idx, ridx, s`possible_subgroups`si>) then
//         s`possible_subgroups`all_groups[<idx, ridx, s`possible_subgroups`si>] := [x`subgroup : x in Subgroups(S : IndexEqual:=ridx)]
//           where S := s`possible_subgroups`cur_stabilizers[s`possible_subgroups`si];
//       end if;
//       s`possible_subgroups`cur_groups := enumerate(s`possible_subgroups`all_groups[<idx, ridx, s`possible_subgroups`si>]);
//       assert forall{U : U in s`possible_subgroups`cur_groups | Index(s`overgroup, U[1]) eq idx};
//     end while;
//     return [x : x in s`possible_subgroups`cur_groups];
//   when "MostUseful":
//     W := s`overgroup;
//     if not assigned s`possible_subgroups then
//       CW := PGG_SubgroupClasses(W);
//       s`possible_subgroups := rec<recformat<queue, queue_changed, cur_groups, usefulness, ignore_groups, classes> | queue:=[<CW!W, <1, 1>>], queue_changed:=false, cur_groups:=[], usefulness:=AssociativeArray(), classes:=CW>;
//     else
//       CW := s`possible_subgroups`classes;
//     end if;
//     while #s`possible_subgroups`cur_groups eq 0 do
//       // ensure the queue is sorted
//       if s`possible_subgroups`queue_changed then
//         s`possible_subgroups`queue_changed := false;
//         isort_by(~s`possible_subgroups`queue, func<x | x[2]>);
//       end if;
//       // pop a group class from the queue
//       pop_start(~item, ~s`possible_subgroups`queue);
//       class, usefulness := Explode(item);
//       vprint PGG_GaloisGroup: "usefulness =", usefulness;
//       // find its maximal subgroups
//       subclasses := {CW ! x`subgroup : x in MaximalSubgroups(Rep(class))};
//       // throw out the ones which have been used already, and so have an assigned usefulness
//       subclasses := [c : c in subclasses | not IsDefined(s`possible_subgroups`usefulness, c)];
//       s`possible_subgroups`cur_groups := [<Rep(c), i, c, usefulness[1]*Index(Rep(class), Rep(c))> where c:=subclasses[i] : i in [1..#subclasses]];
//     end while;
//     return [x : x in s`possible_subgroups`cur_groups];
//   else
//     assert false;
//   end case;
// end intrinsic;

intrinsic MakeValue(S :: PGGStat, value) -> PGGStatVal
  {A value for the statistic S.}
  x := New(PGGStatVal);
  x`stat := S;
  x`value := value;
  return x;
end intrinsic;

intrinsic Hash(v :: PGGStatVal) -> .
  {Hash of v.}
  if not assigned v`hash then
    v`hash := _Hash(v`stat, v);
  end if;
  return v`hash;
end intrinsic;

intrinsic 'eq'(S1 :: PGGStat, S2 :: PGGStat) -> BoolElt
  {Equality.}
  return IsIdentical(S1, S2);
end intrinsic;

intrinsic 'eq'(v1 :: PGGStatVal, v2 :: PGGStatVal) -> BoolElt
  {Equality.}
  require v1`stat eq v2`stat: "must be values of the same statistic";
  return 'eq'(v1`stat, v1, v2);
end intrinsic;

intrinsic 'subset'(v1 :: PGGStatVal, v2 :: PGGStatVal) -> BoolElt
  {True if v1 is possibly a statistic for a subgroup of the group v2 is a subset for.}
  require v1`stat eq v2`stat: "must be values of the same statistic";
  return 'subset'(v1`stat, v1, v2);
end intrinsic;

intrinsic Print(v :: PGGStatVal)
  {Prints.}
  _Print(v`stat, v);
end intrinsic;

intrinsic PGGStat_HasRoot_Make() -> PGGStat_HasRoot
  {Makes a new PGGStat.}
  return New(PGGStat_HasRoot);
end intrinsic;

intrinsic PGGStat_NumRoots_Make() -> PGGStat_NumRoots
  {Makes a new PGGStat.}
  return New(PGGStat_NumRoots);
end intrinsic;

intrinsic PGGStat_FactorDegrees_Make() -> PGGStat_FactorDegrees
  {Makes a new PGGStat.}
  return New(PGGStat_FactorDegrees);
end intrinsic;

intrinsic PGGStat_FactorDegrees2_Make() -> PGGStat_FactorDegrees2
  {"}
  return New(PGGStat_FactorDegrees2);
end intrinsic;

intrinsic PGGStat_AutGroup_Make() -> PGGStat_AutGroup
  {"}
  return New(PGGStat_AutGroup);
end intrinsic;

intrinsic PGGStat_Degree_Make() -> PGGStat_Degree
  {Makes a new PGGStat.}
  return New(PGGStat_Degree);
end intrinsic;

intrinsic PGGStat_Order_Make() -> PGGStat_Order
  {"}
  return New(PGGStat_Order);
end intrinsic;

intrinsic PGGStat_Factors_Make(:Stat:=false) -> PGGStat_Factors
  {Makes a new PGGStat.}
  S := New(PGGStat_Factors);
  S`stat := Stat cmpne false select Stat else PGGStat_Degree_Make();
  return S;
end intrinsic;

intrinsic PGGStat_Tup_Make(args) -> PGGStat_Tup
  {Makes a new PGGStat.}
  S := New(PGGStat_Tup);
  S`stats := args;
  return S;
end intrinsic;

intrinsic Print(S :: PGGStat_HasRoot)
  {Print.}
  printf "has root";
end intrinsic;

intrinsic Print(S :: PGGStat_NumRoots)
  {"}
  printf "number of roots";
end intrinsic;

intrinsic Print(S :: PGGStat_FactorDegrees)
  {"}
  printf "degrees of factors";
end intrinsic;

intrinsic Print(S :: PGGStat_FactorDegrees2)
  {"}
  printf "degrees of factors of factors";
end intrinsic;

intrinsic Print(S :: PGGStat_AutGroup)
  {"}
  printf "automorphism group";
end intrinsic;

intrinsic Print(S :: PGGStat_Degree)
  {"}
  printf "degree";
end intrinsic;

intrinsic Print(S :: PGGStat_Factors)
  {"}
  printf "factors -> %o", S`stat;
end intrinsic;

intrinsic Print(S :: PGGStat_Tup)
  {"}
  if #S`stats eq 0 then
    printf "tuple (empty)";
  else
    print "tuple";
    IndentPush();
    for i in [1..#S`stats-1] do
      print S`stats[i];
    end for;
    printf "%o", S`stats[#S`stats];
    IndentPop();
  end if;
end intrinsic;
intrinsic ConjugacyClasses(S :: PGGStat_AutGroup, d :: RngIntElt) -> PGGSetSubgrpcls
  {The conjugacy classes of Sym(d).}
  if not assigned S`conjugacy_classes then
    S`conjugacy_classes := AssociativeArray();
  end if;
  if not IsDefined(S`conjugacy_classes, d) then
    S`conjugacy_classes[d] := PGG_SubgroupClasses(SymmetricGroup(d));
  end if;
  return S`conjugacy_classes[d];
end intrinsic;

intrinsic GroupStat(S :: PGGStat_HasRoot, G :: GrpPerm) -> PGGStatVal
  {The value of the statistic on the group.}
  return MakeValue(S, exists{o : o in Orbits(G) | #o eq 1});
end intrinsic;

intrinsic GroupStat(S :: PGGStat_NumRoots, G :: GrpPerm) -> PGGStatVal
  {The value of the statistic on the group.}
  return MakeValue(S, #[o : o in Orbits(G) | #o eq 1]);
end intrinsic;

intrinsic GroupStat(S :: PGGStat_FactorDegrees, G :: GrpPerm) -> PGGStatVal
  {The value of the statistic on the group.}
  return MakeValue(S, {* #o : o in Orbits(G) *});
end intrinsic;

intrinsic GroupStat(S :: PGGStat_FactorDegrees2, G :: GrpPerm) -> PGGStatVal
  {"}
  return MakeValue(S, {* <#o, {*#o : o in Orbits(S)*}> where S:=Stabilizer(G, Rep(o)) : o in Orbits(G)*});
end intrinsic;

intrinsic GroupStat(S :: PGGStat_Degree, G :: GrpPerm) -> PGGStatVal
  {The value of the statistic on the group.}
  return MakeValue(S, Degree(G));
end intrinsic;

intrinsic GroupStat(S :: PGGStat_Order, G :: GrpPerm) -> PGGStatVal
  {"}
  return MakeValue(S, #G);
end intrinsic;

intrinsic GroupStat(S :: PGGStat_AutGroup, G :: GrpPerm) -> PGGStatVal
  {"}
  assert IsTransitive(G);
  stab := Stabilizer(G, 1);
  norm := Normalizer(G, stab);
  aut := CosetImage(norm, stab);
  return MakeValue(S, ConjugacyClasses(S, Degree(aut)) ! aut);
end intrinsic;

intrinsic GroupStat(S :: PGGStat_Tup, G :: GrpPerm) -> PGGStatVal
  {The value of the statistic on the group.}
  return MakeValue(S, <GroupStat(S2, G) : S2 in S`stats>);
end intrinsic;

intrinsic GroupStat(S :: PGGStat_Factors, G :: GrpPerm) -> PGGStatVal
  {The value of the statistic on the group.}
  return MakeValue(S, {* GroupStat(S`stat, OrbitImage(G, o)) : o in Orbits(G) *});
end intrinsic;

intrinsic ResolventStat(S :: PGGStat_HasRoot, R :: RngUPolElt[FldPad]) -> PGGStatVal
  {The value of the statistic on the resolvent.}
  return MakeValue(S, has_root(R));
end intrinsic;

intrinsic ResolventStat(S :: PGGStat_NumRoots, R :: RngUPolElt[FldPad]) -> PGGStatVal
  {The value of the statistic on the resolvent.}
  return MakeValue(S, #roots(R));
end intrinsic;

intrinsic ResolventStat(S :: PGGStat_FactorDegrees, R :: RngUPolElt[FldPad]) -> PGGStatVal
  {The value of the statistic on the resolvent.}
  return MakeValue(S, {* Degree(fac) : fac in factorization(R) *});
end intrinsic;

intrinsic ResolventStat(S :: PGGStat_FactorDegrees2, R :: RngUPolElt[FldPad]) -> PGGStatVal
  {"}
  return MakeValue(S, {* <Degree(fac), {* Degree(fac) : fac in factorization(ChangeRing(R, L)) *}> where L:=certs[i]`Extension where fac:=facs[i] : i in [1..#facs] *} where facs,certs:=factorization(R : Extensions));
end intrinsic;

intrinsic ResolventStat(S :: PGGStat_Degree, R :: RngUPolElt[FldPad]) -> PGGStatVal
  {The value of the statistic on the resolvent.}
  return MakeValue(S, Degree(R));
end intrinsic;

intrinsic ResolventStat(S :: PGGStat_AutGroup, R :: RngUPolElt[FldPad]) -> PGGStatVal
  {"}
  K := BaseRing(R);
  L := extension(R);
  aut := AutomorphismGroup(L, K);
  return MakeValue(S, ConjugacyClasses(S, Degree(aut)) ! aut);
end intrinsic;

intrinsic ResolventStat(S :: PGGStat_Tup, R :: RngUPolElt[FldPad]) -> PGGStatVal
  {The value of the statistic on the resolvent.}
  return MakeValue(S, <ResolventStat(S2, R) : S2 in S`stats>);
end intrinsic;

intrinsic ResolventStat(S :: PGGStat_Factors, R :: RngUPolElt[FldPad]) -> PGGStatVal
  {The value of the statistic on the resolvent.}
  return MakeValue(S, {* ResolventStat(S`stat, fac) : fac in factorization(R) *});
end intrinsic;

intrinsic 'eq'(S :: PGGStat, v1, v2) -> BoolElt
  {Equality.}
  return v1`value eq v2`value;
end intrinsic;

intrinsic 'eq'(S :: PGGStat_AutGroup, v1, v2) -> BoolElt
  {"}
  return Degree(Rep(v1`value)) eq Degree(Rep(v2`value)) and v1`value eq v2`value;
end intrinsic;

intrinsic 'subset'(S :: PGGStat, v1, v2) -> BoolElt
  {True if v1 is a refinement of v2.}
  not_implemented("subset: ", Type(S));
end intrinsic;

intrinsic 'subset'(S :: PGGStat_HasRoot, v1, v2) -> BoolElt
  {"}
  return (not v2`value) or (v1`value);
end intrinsic;

intrinsic 'subset'(S :: PGGStat_NumRoots, v1, v2) -> BoolElt
  {"}
  return v1`value ge v2`value;
end intrinsic;

intrinsic 'subset'(S :: PGGStat_FactorDegrees, v1, v2) -> BoolElt
  {"}
  return is_subpartition_of(v1`value, v2`value);
end intrinsic;

intrinsic 'subset'(S :: PGGStat_Degree, v1, v2) -> BoolElt
  {"}
  return v1`degree eq v2`degree;
end intrinsic;

// Is it true that if H<G then N_G(Stab_G(1))/Stab_G(1) < N_H(Stab_H(1))/Stab_H(1)?
// AG < AH <=> NG/SG < NH/SH = NH/(SG meet NH) ~ (NH SG)/SG <=> NG < NH SG ?
// It is true for all transitive groups of degree up to 15.
// 
// SG = {s in G : s(1)=1}
// SH = {s in H : s(1)=1} = SG meet H
// NG = {n in G : s in SG => s^n in SG} = {n in G : s in G, s(1)=1 => (s^n)(1)=1 i.e. s(n(1))=n(1)}
// 
// intrinsic 'subset'(S :: PGGStat_AutGroup, v1, v2) -> BoolElt
//   {"}
// end intrinsic;

intrinsic _Hash(S :: PGGStat, v) -> .
  {Hash.}
  return Hash(v`value);
end intrinsic;

intrinsic _Hash(S :: PGGStat_AutGroup, v) -> .
  {"}
  return Hash(<Degree(Rep(v`value)), v`value>);
end intrinsic;

intrinsic _Print(S :: PGGStat, v)
  {"}
  printf "%o", v`value;
end intrinsic;

intrinsic _Print(S :: PGGStat_AutGroup, v)
  {"}
  printf "%o", GroupName(Rep(v`value));
end intrinsic;

// intrinsic ScoreSubgroup(s :: PGGAlgState_ResGroups_All, subgroup :: GrpPerm) -> FldReElt
//   {Scores the given subgroup.}
//   assert #s`possible_groups gt 0;
//   stats := [**];
//   h := CosetAction(s`overgroup, subgroup);
//   A := AssociativeArray();
//   for G in s`possible_groups do
//     stat := GroupStat(s`algorithm`statistic, h(G));
//     if IsDefined(A, stat) then
//       Append(~A[stat], G);
//     else
//       A[stat] := [G];
//       if (s`algorithm`subgroup_score eq "IsUseful") and (#A gt 1) then
//         return 1;
//       end if;
//     end if;
//   end for;
//   case s`algorithm`subgroup_score:
//   when "IsUseful":
//     assert #A le 1;
//     return -1;
//   when "Diversity":
//     return #A le 1 select -1 else #A;
//   when "Information":
//     return #A le 1 select -1 else multiplicities_to_information([#A[k] : k in Keys(A)]);
//   else
//     assert false;
//   end case;
// end intrinsic;

// intrinsic TerminateScoring(s :: PGGAlgState_ResGroups_All, scores :: []) -> BoolElt
//   {True if we know enough scores to finish.}
//   case s`algorithm`subgroup_choice:
//   when "First":
//     return #scores ge 1;
//   when "Best":
//     return false;
//   else
//     assert false;
//   end case;
// end intrinsic;

// intrinsic PGGOrder_None_Make() -> PGGOrder_None
//   {Makes an ordering.}
//   return New(PGGOrder_None);
// end intrinsic;

// intrinsic PGGOrder_Random_Make() -> PGGOrder_Random
//   {"}
//   return New(PGGOrder_Random);
// end intrinsic;

// intrinsic PGGOrder_Reverse_Make(order :: PGGOrder) -> PGGOrder_Reverse
//   {"}
//   o := New(PGGOrder_Reverse);
//   o`order := order;
//   return o;
// end intrinsic;

// intrinsic PGGOrder_Key_Make(key :: UserProgram) -> PGGOrder_Key
//   {"}
//   o := New(PGGOrder_Key);
//   o`key := key;
//   return o;
// end intrinsic;

// intrinsic PGGOrder_Key_Index_Make() -> PGGOrder_Key
//   {"}
//   return PGGOrder_Key_Make(func<x,s | Index(s`overgroup, x[1])>);
// end intrinsic;

// intrinsic PGGOrder_Key_OrbitIndex_Make() -> PGGOrder_Key
//   {"}
//   return PGGOrder_Key_Make(func<x,s | Index(s`overgroup, &meet[Stabilizer(s`overgroup, o) : o in Orbits(x[1])])>);
// end intrinsic;

// intrinsic Sort(xs :: [], order :: PGGOrder_None : Data:=false) -> []
//   {Sorts xs according to the given ordering.}
//   return xs;
// end intrinsic;

// intrinsic Sort(xs :: [], order :: PGGOrder_Random : Data:=false) -> []
//   {"}
//   return [xs[i^r] : i in [1..#xs]] where r:=Random(SymmetricGroup(#xs));
// end intrinsic;

// intrinsic Sort(xs :: [], order :: PGGOrder_Reverse : Data:=false) -> []
//   {"}
//   return Reverse(Sort(xs, order`order : Data:=Data));
// end intrinsic;

// intrinsic Sort(xs :: [], order :: PGGOrder_Key : Data:=false) -> []
//   {"}
//   keys := [order`key(x, Data) : x in xs];
//   Sort(~keys, ~permut);
//   return [xs[i^permut] : i in [1..#xs]];
// end intrinsic;

// intrinsic OrderSubgroups(s :: PGGAlgState_ResGroups_All, groups :: [Tup]) -> []
//   {Orders the subgroups.}
//   case s`algorithm`subgroup_order:
//   when "None":
//     return groups;
//   when "Random":
//     return [groups[i^r] : i in [1..#groups]] where r:=Random(SymmetricGroup(#groups));
//   when "Index":
//     return sort_by(groups, func<G | -#G[1]>);
//   when "OrbitIndex":
//     return sort_by(groups, func<G | -#&meet[Stabilizer(s`overgroup, o) : o in Orbits(G[1])]>);
//   else
//     assert false;
//   end case;
// end intrinsic;

// intrinsic UselessSubgroups(s :: PGGAlgState_ResGroups_All, subgroups :: [Tup])
//   {Declares we are done considering these groups.}
//   case s`algorithm`subgroup_tranche:
//   when "All":
//     for x in subgroups do
//       Undefine(~s`possible_subgroups, x[2]);
//     end for;
//   when "Index", "OrbitIndex":
//     for x in subgroups do
//       Undefine(~s`possible_subgroups`cur_groups, x[2]);
//     end for;
//   when "MostUseful":
//     for x in subgroups do
//       _, i, c, u := Explode(x);
//       Undefine(~s`possible_subgroups`cur_groups, i);
//       s`possible_subgroups`usefulness[c] := u;
//       Append(~s`possible_subgroups`queue, <c, <u, Index(s`overgroup, Rep(c))>>);
//       s`possible_subgroups`queue_changed := true;
//     end for;
//   else
//     assert false;
//   end case;
// end intrinsic;

// intrinsic UsefulSubgroup(s :: PGGAlgState_ResGroups_All, subgroup :: Tup)
//   {Declare that we are using the given subgroup.}
//   case s`algorithm`subgroup_tranche:
//   when "All", "Index", "OrbitIndex":
//     UselessSubgroups(s, [subgroup]);
//   when "MostUseful":
//     _, i, c, _ := Explode(subgroup);
//     Undefine(~s`possible_subgroups`cur_groups, i);
//     s`possible_subgroups`usefulness[c] := 1;
//     Append(~s`possible_subgroups`queue, <c, <1, Index(s`overgroup, Rep(c))>>);
//     s`possible_subgroups`queue_changed := true;
//   else
//     assert false;
//   end case;
// end intrinsic;

// intrinsic Subgroup(s :: PGGAlgState_ResGroups_All) -> GrpPerm
//   {A subgroup to get a resolvent of.}
//   while true do
//     // get the next tranche of groups
//     groups := SubgroupTranche(s);
//     // reorder them
//     groups := Sort(groups, s`algorithm`subgroup_order : Data:=s);
//     // score them
//     scores := [car<Universe(groups), RealField()>| ];
//     useless := [Universe(groups)| ];
//     for U in groups do
//       score := ScoreSubgroup(s, U[1]);
//       if score ge 0 then
//         Append(~scores, <U, score>);
//         if TerminateScoring(s, scores) then
//           break U;
//         end if;
//       else
//         Append(~useless, U);
//       end if;
//     end for;
//     // ignore the useless subgroups
//     vprint PGG_GaloisGroup: "#useless =", #useless, "of", #groups;
//     UselessSubgroups(s, useless);
//     // get the best scoring
//     if #scores gt 0 then
//       U := Sort(scores, func<a,b | b[2]-a[2]>)[1][1];
//       UsefulSubgroup(s, U);
//       return U[1];
//     end if;
//   end while;
// end intrinsic;

intrinsic ProcessResolvent(s :: PGGAlgState_ResGroups_All, resolvent :: RngUPolElt[FldPad], subgroup :: GrpPerm)
  {Use the resolvent to get information about the Galois group.}
  PGG_GlobalTimer_Push("resolvent stat");
  rstat := ResolventStat(s`algorithm`statistic, resolvent);
  vprint PGG_GaloisGroup: "resolvent statistic =", rstat;
  PGG_GlobalTimer_Swap("filter");
  h := CosetAction(s`overgroup, subgroup);
  vprint PGG_GaloisGroup: "group statistics =", {* GroupStat(s`algorithm`statistic, h(G)) : G in s`possible_groups *};
  s`possible_groups := [G : G in s`possible_groups | gstat eq rstat where gstat := GroupStat(s`algorithm`statistic, h(G))];
  vprint PGG_GaloisGroup: "#possible groups =", #s`possible_groups;
  PGG_GlobalTimer_Pop();
end intrinsic;

intrinsic _ProcessResolvent(s :: PGGAlgState_ResGroups_Maximal, rid)
  {"}
  resolvent, subgroup, rstat, h := Explode(s`resolvents[rid]);
  PGG_GlobalTimer_Push("update layer");
  statalg := s`algorithm`statistic;
  // update items in the layer
  for i in [1..#s`current_layer] do
    n := s`current_layer[i];
    if rid notin n`seen_resolvents then
      assert n`maybe_subgroup;
      nstat := GroupStat(n, h);
      n`maybe_subgroup := n`maybe_subgroup and (rstat subset nstat);
      if s`algorithm`blacklist and (not n`maybe_subgroup) then
        Append(~s`blacklist, n);
      end if;
      if n`maybe_subgroup then
        n`maybe_equal := n`maybe_equal and (rstat eq nstat);
      end if;
      Include(~n`seen_resolvents, rid);
    end if;
  end for;
  // eliminate items from the layer
  PGG_GlobalTimer_Swap("filter layer");
  new_layer := [n : n in s`current_layer | n`maybe_subgroup];
  assert #new_layer gt 0;
  // update children in the layer
  PGG_GlobalTimer_Swap("list children");
  children := SetToSequence({m : m in PossibleChildren(n), n in new_layer});
  PGG_GlobalTimer_Swap("update children");
  for i in [1..#children] do
    m := children[i];
    if rid notin m`seen_resolvents then
      assert m`maybe_subgroup;
      mstat := GroupStat(m, h);
      m`maybe_subgroup := m`maybe_subgroup and (rstat subset mstat);
      if s`algorithm`blacklist and (not m`maybe_subgroup) then
        Append(~s`blacklist, m);
      end if;
      if m`maybe_subgroup then
        m`maybe_equal := m`maybe_equal and (rstat eq mstat);
      end if;
      Include(~m`seen_resolvents, rid);
    end if;
  end for;
  // elimitate children from the layer
  PGG_GlobalTimer_Swap("filter children");
  for i in [1..#new_layer] do
    n := new_layer[i];
    n`possible_children := [m : m in PossibleChildren(n) | m`maybe_subgroup];
  end for;
  s`current_layer := [n : n in new_layer | n`maybe_equal or (#PossibleChildren(n) gt 0)];
  PGG_GlobalTimer_Pop();
end intrinsic;

intrinsic ProcessResolvent(s :: PGGAlgState_ResGroups_Maximal, resolvent :: RngUPolElt[FldPad], subgroup :: GrpPerm)
  {"}
  // process this resolvent and record it
  PGG_GlobalTimer_Push("resolvent stat");
  rstat := ResolventStat(s`algorithm`statistic, resolvent);
  vprint PGG_GaloisGroup: "resolvent statistic =", rstat;
  PGG_GlobalTimer_Swap("process");
  h := CosetAction(s`overgroup, subgroup);
  Append(~s`resolvents, <resolvent, subgroup, rstat, h>);
  _ProcessResolvent(s, #s`resolvents);
  vprint PGG_GaloisGroup: "#layer =", #s`current_layer, #[n : n in s`current_layer | n`maybe_equal], #{m : m in PossibleChildren(n), n in s`current_layer}, #{m : m in PossibleChildren(n), n in s`current_layer | m`maybe_equal};
  // now see if we need to descend a layer
  while true do
    if ShouldDescend(s) then
      vprint PGG_GaloisGroup: "next layer";
      PGG_GlobalTimer_Swap("new layer");
      Descend(s);
      vprint PGG_GaloisGroup: "#layer =", #s`current_layer, #[n : n in s`current_layer | n`maybe_equal], #{m : m in PossibleChildren(n), n in s`current_layer}, #{m : m in PossibleChildren(n), n in s`current_layer | m`maybe_equal};
      // re-process all the resolvents we have tried already
      if s`algorithm`reprocess then
        PGG_GlobalTimer_Swap("re-process");
        for i in [1..#s`resolvents] do
          _ProcessResolvent(s, i);
        end for;
        vprint PGG_GaloisGroup: "#layer =", #s`current_layer, #[n : n in s`current_layer | n`maybe_equal], #{m : m in PossibleChildren(n), n in s`current_layer}, #{m : m in PossibleChildren(n), n in s`current_layer | m`maybe_equal};
      end if;
      // start picking groups from the beginning again
      if s`algorithm`reset then
        PGG_GlobalTimer_Swap("reset");
        Reset(s`choice_state);
      end if;
    else
      break;
    end if;
  end while;
  PGG_GlobalTimer_Pop();
end intrinsic;

intrinsic ProcessResolvent(s :: PGGAlgState_ResGroups_RootsMaximal, resolvent :: RngUPolElt[FldPad], subgroup :: GrpPerm)
  {"}
  PGG_GlobalTimer_Push("assert");
  poss := PossibleSubgroups(s);
  assert #poss gt 0;
  assert IsConjugate(s`overgroup, subgroup, Rep(poss[1]));
  PGG_GlobalTimer_Swap("has root");
  ok := has_root(resolvent);
  if ok then
    PGG_GlobalTimer_Swap("descend");
    vprint PGG_GaloisGroup: "descending";
    s`cur_group := poss[1];
    if assigned s`possible_subgroups then
      delete s`possible_subgroups;
    end if;
    vprint PGG_GaloisGroup: "index =", Index(s`overgroup, Rep(s`cur_group));
  else
    PGG_GlobalTimer_Swap("eliminate");
    vprint PGG_GaloisGroup: "eliminating";
    s`possible_subgroups := poss[2..#poss];
    vprint PGG_GaloisGroup: "#possible_subgroups =", #s`possible_subgroups;
  end if;
  PGG_GlobalTimer_Pop();
end intrinsic;

function layer_has_consistent_subgroup(s, i, G)
  // check the inputs
  assert i ge 1;
  if i eq 1 then
    assert IsConsistentWithSubgroup(s`conjugacy, G);
  end if;
  // base case
  if i eq #s`current_layer then
    assert IsConsistentWithSubgroup(s`conjugacy, G);
    return true;
  end if;
  // general case
  assert i lt #s`current_layer;
  for H in Conjugates(s`conjugacy`group, Rep(s`current_layer[i+1]`class)) do
    G2 := H meet G;
    if IsConsistentWithSubgroup(s`conjugacy, G2) then
      if layer_has_consistent_subgroup(s, i+1, G2) then
        return true;
      end if;
    end if;
  end for;
  return false;
end function;

intrinsic ShouldDescend(s :: PGGAlgState_ResGroups_Maximal) -> BoolElt
  {True if we should descend now.}
  descending := false;
  case s`algorithm`descend:
  when "Eager":
    return #[n : n in s`current_layer | not n`maybe_equal] ne 0;
  when "Steady":
    return #[n : n in s`current_layer | n`maybe_equal] eq 0;
  when "Patient":
    if #[n : n in s`current_layer | n`maybe_equal] eq 0 then
      return layer_has_consistent_subgroup(s, 1, Rep(s`current_layer[1]`class));
    else
      return false;
    end if;
  when "Ask":
    while true do
      read ans, "Descend? (y/n) ";
      case ans:
      when "y":
        return true;
      when "n":
        return false;
      end case;
    end while;
  else
    assert false;
  end case;  
end intrinsic;

intrinsic Descend(s :: PGGAlgState_ResGroups_Maximal)
  {Descend.}
  s`current_layer := SetToSequence({m : m in (n`maybe_equal select [n] else PossibleChildren(n)), n in s`current_layer});
end intrinsic;

intrinsic GlobalModel(F :: FldPad) -> PGGGloMod
  {A global model for F.}
  if IsPrimeField(F) then
    m := New(PGGGloMod_Rational);
    m`local_field := F;
    m`global_field := Q;
    m`embedding := map<Q -> F | x :-> x, y :-> y>;
    return m;
  else
    not_implemented("global_model: non-prime field");
  end if;
end intrinsic;

intrinsic GlobalModel(conj :: PGGConj_Symmetric, bm :: PGGGloMod) -> PGGGloMod
  {Global model with the given base model.}
  m := New(PGGGloMod_Symmetric);
  e := bm`embedding;
  locpol := conj`pol;
  m`local_pol := locpol;
  PGG_GlobalTimer_Push("global polynomial");
  glopol0 := Polynomial([c@@e : c in Coefficients(locpol)]);
  if assigned conj`top_field then
    PGG_GlobalTimer_Swap("minimize coefficients");
    locext := conj`top_field;
    assert IsWeaklyEqual(DefiningPolynomial(locext), locpol);
    // minimize the coefficients of glopol
    K := BaseRing(locpol);
    pr := Precision(K);
    glopol := glopol0;
    root := locext.1;
    locext2 := locext;
    isom := map<locext -> locext2 | x :-> x, y :-> y>;
    pr := Ceiling(Log(Prime(K), Max([largest_coefficient(c) : c in Coefficients(glopol)])));
    while true do
      pr div:= 2;
      if pr lt 2 then
        break;
      end if;
      PGG_GlobalTimer_Push("reduce coefficients");
      glopol2 := Polynomial([reduce_coefficients(c, Prime(K)^pr) : c in Coefficients(glopol)]);
      locpol2 := Polynomial([change_apr(c@e, Precision(K)) : c in Coefficients(glopol2)]);
      locext2new := ext<K | locpol2>;
      PGG_GlobalTimer_Swap("has root");
      ok1, root := has_root(ChangeRing(locpol, locext2new));
      ok2, root2 := has_root(ChangeRing(locpol2, locext));
      PGG_GlobalTimer_Pop();
      if ok1 and ok2 then
        locext2 := locext2new;
        isom := map<locext -> locext2 | x :-> &+[cs[i] * root^(i-1) : i in [1..#cs]] where cs:=Eltseq(x), y :-> &+[cs[i] * root2^(i-1) : i in [1..#cs]] where cs:=Eltseq(y)>;
        glopol := glopol2;
      else
        break;
      end if;
    end while;
    // make the embedding
    m`global_pol := glopol;
    gloext := ext<BaseRing(glopol) | glopol>;
    ee := map<gloext -> locext | x :-> (locext2![c@e : c in Eltseq(x)]) @@ isom, y :-> gloext![c@@e : c in Eltseq(y @ isom)]>;
    m`local_field := locext;
    m`global_field := gloext;
    m`embedding := ee;
  else
    m`global_pol := glopol0;
  end if;
  PGG_GlobalTimer_Pop();
  return m;
end intrinsic;

intrinsic GlobalModel(conj :: PGGConj_Factors, bm :: PGGGloMod) -> PGGGloMod
  {"}
  m := New(PGGGloMod_Factors);
  PGG_GlobalTimer_Push("recurse");
  m`factors := [GlobalModel(c, bm) : c in conj`factors];
  PGG_GlobalTimer_Pop();
  return m;
end intrinsic;

intrinsic GlobalModel(conj :: PGGConj_Tower, bm :: PGGGloMod) -> PGGGloMod
  {"}
  m := New(PGGGloMod_Tower);
  m`tower := [**];
  m2 := bm;
  PGG_GlobalTimer_Push("recurse");
  for c in conj`tower do
    m2 := GlobalModel(c, m2);
    Append(~m`tower, m2);
  end for;
  PGG_GlobalTimer_Swap("primitive element");
  gloroot, glopol := random_primitive_element(m`tower[#m`tower]`global_field, BaseRing(m`tower[1]`global_pol));
  PGG_GlobalTimer_Pop();
  m`global_pol := glopol;
  m`global_pol_root := gloroot;
  return m;
end intrinsic;

intrinsic Start(alg :: PGGAlg_ResEval_Global, conj :: PGGConj) -> PGGAlgState_ResEval_Global
  {Starts the algorithm and returns its state.}
  s := New(PGGAlgState_ResEval_Global);
  s`algorithm := alg;
  s`conjugacy := conj;
  s`precision := -Infinity();
  PGG_GlobalTimer_Push("base field model");
  s`base_field_model := GlobalModel(BaseField(conj));
  PGG_GlobalTimer_Swap("polynomial model");
  s`pol_model := GlobalModel(conj, s`base_field_model);
  PGG_GlobalTimer_Pop();
  return s;
end intrinsic;

intrinsic Overgroup(s :: PGGAlgState_ResEval_Global) -> GrpPerm
  {The overgroup we can evaluate resolvents in.}
  return s`conjugacy`group;
end intrinsic;

intrinsic ComplexEmbeddings(m :: PGGGloMod_Rational, embs :: [Map]) -> []
  {The complex embeddings of m extending embs.}
  return embs;
end intrinsic;

intrinsic ComplexEmbeddings(m :: PGGGloMod_Symmetric, embs :: [Map]) -> []
  {"}
  rss := ComplexRoots(m, embs);
  return [map<m`global_field -> C | x :-> &+[(cs[j] @ e) * r^(j-1) : j in [1..#cs]] where cs:=Eltseq(x)> where C:=Codomain(e) where e:=embs[i] : r in rss[i], i in [1..#embs]];
end intrinsic;

intrinsic ComplexRoots(m :: PGGGloMod_Symmetric, embs :: [Map]) -> []
  {The complex roots of the polynomial model.}
  return [[r[1] : r in Roots(Polynomial([c@e : c in Coefficients(m`global_pol)]))] : e in embs];
end intrinsic;

intrinsic ComplexRoots(m :: PGGGloMod_Factors, embs :: [Map]) -> []
  {"}
  rsss := [ComplexRoots(fac, embs) : fac in m`factors];
  return [&cat[rss[i] : rss in rsss] : i in [1..#embs]];
end intrinsic;

intrinsic ComplexRoots(m :: PGGGloMod_Tower, embs :: [Map]) -> []
  {"}
  es := embs;
  for m2 in m`tower do
    es := ComplexEmbeddings(m2, es);
  end for;
  d := Degree(m`tower[#m`tower]`local_field, BaseRing(m`tower[1]`local_pol));
  assert #es eq #embs * d;
  // todo: also find complex roots of the global_pol, which should be more accurate but unordered, and pair them up
  return [[e(m`global_pol_root) : e in es[1+d*(i-1)..d*i]] : i in [1..#embs]];
end intrinsic;

intrinsic ComplexRoots(s :: PGGAlgState_ResEval_Global, pr :: RngIntElt) -> []
  {A sequence of complex roots, one for each embedding of the base field.}
  C := ComplexField(pr);
  if pr gt s`precision then
    vprint PGG_GaloisGroup: "complex precision =", pr;
    s`complex_roots := ComplexRoots(s`pol_model, ComplexEmbeddings(s`base_field_model, [map<Q -> C | x :-> C!x>]));
    s`precision := pr;
  end if;
  return PowerSequence(PowerSequence(C)) ! s`complex_roots;
end intrinsic;

intrinsic Resolvent(s :: PGGAlgState_ResEval_Global, I, U :: GrpPerm) -> RngUPolElt
  {The resolvent associated to the invariant I.}
  W := Overgroup(s);
  assert U subset W;
  ntries := 0;
  while true do
    ntries +:= 1;
    trans := tschirnhaus_transformation(ntries, Index(W, U));
    rss0 := ComplexRoots(s, 30);
    trss0 := [[Evaluate(trans, r) : r in rs] : rs in rss0];
    rbound := Max([Abs(r) : r in rs, rs in trss0]);
    pr := Ceiling(Log(10, slpol_bound(I, rbound)) * Index(W, U) * 2 + 30);
    rss := ComplexRoots(s, pr);
    trss := [[Evaluate(trans, r) : r in rs] : rs in rss];
    Rxrss := [[Evaluate(I, permute_seq(g, rs)) : g in left_coset_representatives(W, U)] : rs in trss];
    Rxs := [polynomial_with_roots(rs) : rs in Rxrss];
    if #Rxs eq 1 then
      R := Polynomial([Round(Real(c)) : c in Coefficients(Rxs[1])]);
      err := Max([Abs(c) : c in Coefficients(R - Rxs[1])] cat [0]);
      assert err lt 1e-20;
      if IsSquarefree(R) then
        return ChangeRing(R, BaseField(s`conjugacy));
      end if;
    else
      not_implemented("Resolvent: only implemented over Q");
    end if;
  end while;
end intrinsic;

intrinsic PGGAlg_Conjugacy_Symmetric_Make( : GaloisGroupAlg:=false) -> PGGAlg_Conjugacy_Symmetric
  {The "Symmetric" conjugacy algorithm.}
  alg := New(PGGAlg_Conjugacy_Symmetric);
  if GaloisGroupAlg cmpne false then
    alg`galois_group_alg := GaloisGroupAlg;
  end if;
  return alg;
end intrinsic;

intrinsic PGGAlg_Conjugacy_Factors_Make(:Next:=false) -> PGGAlg_Conjugacy_Factors
  {The "Factors" conjugacy algorithm.}
  a := New(PGGAlg_Conjugacy_Factors);
  a`next := Next cmpne false select Next else PGGAlg_Conjugacy_Symmetric_Make();
  return a;
end intrinsic;

intrinsic PGGAlg_Conjugacy_RamTower_Make(:Next:=false) -> PGGAlg_Conjugacy_RamTower
  {The "RamTower" conjugacy algorithm.}
  a := New(PGGAlg_Conjugacy_RamTower);
  a`next := Next cmpne false select Next else PGGAlg_Conjugacy_Symmetric_Make();
  return a;
end intrinsic;

intrinsic Print(alg :: PGGAlg_Conjugacy_Symmetric)
  {Print.}
  print "symmetric";
  IndentPush();
  printf "galois group = %o", assigned alg`galois_group_alg select alg`galois_group_alg else "unset";
  IndentPop();
end intrinsic;

intrinsic Print(alg :: PGGAlg_Conjugacy_Factors)
  {"}
  printf "factors -> "; Print(alg`next);
end intrinsic;

intrinsic Print(alg :: PGGAlg_Conjugacy_RamTower)
  {"}
  printf "ramification tower -> "; Print(alg`next);
end intrinsic;

intrinsic Conjugacy(alg :: PGGAlg_Conjugacy_Symmetric, f :: RngUPolElt[FldPad] : TopField:=false, IsTransitive:=false, KnownGroup:=false) -> PGGConj
  {Gets the conjugacy.}
  c := New(PGGConj_Symmetric);
  c`group := SymmetricGroup(Degree(f));
  c`base_field := BaseRing(f);
  c`pol := f;
  if TopField cmpne false then
    c`top_field := TopField;
  end if;
  if KnownGroup cmpne false then
    assert KnownGroup subset c`group;
    c`is_known := [* true, KnownGroup *];
  elif Degree(c) eq 1 then
    c`is_known := [* true, c`group *];
  elif assigned alg`galois_group_alg then
    PGG_GlobalTimer_Push("galois group");
    c`is_known := [* true, GaloisGroup(alg`galois_group_alg, f) *];
    PGG_GlobalTimer_Pop();
  else
    c`is_known := [* false *];
  end if;
  c`is_transitive := IsTransitive or Degree(c) eq 1;
  return c;
end intrinsic;

intrinsic Conjugacy(alg :: PGGAlg_Conjugacy_Factors, f :: RngUPolElt[FldPad] : IsTransitive:=false) -> PGGConj
  {"}
  PGG_GlobalTimer_Push("factorization");
  facs := factorization(f);
  assert #facs le 1 or not IsTransitive;
  c := New(PGGConj_Factors);
  PGG_GlobalTimer_Swap("recurse");
  c`factors := [Conjugacy(alg`next, fac : IsTransitive) : fac in facs];
  PGG_GlobalTimer_Pop();
  c`group := DirectProduct([cc`group : cc in c`factors]);
  c`base_field := BaseRing(f);
  offset := 0;
  for i in [1..#c`factors] do
    cc := c`factors[i];
    d := Degree(cc);
    cc`parent_subgroup := c`group;
    cc`parent_quotient := OrbitAction(c`group, [offset+1..offset+d]);
    offset +:= d;
  end for;
  assert Degree(c) eq offset;
  return c;
end intrinsic;

intrinsic Conjugacy(alg :: PGGAlg_Conjugacy_RamTower, f :: RngUPolElt[FldPad] : IsTransitive:=false) -> PGGConj
  {"}
  PGG_GlobalTimer_Push("factorization");
  facs, certs := factorization(f : Extensions);
  assert #facs eq 1;
  PGG_GlobalTimer_Swap("ramification tower");
  t := ramification_tower(certs[1]`Extension, BaseRing(f));
  c := New(PGGConj_Tower);
  c`pol := f;
  PGG_GlobalTimer_Swap("recurse");
  c`tower := [Conjugacy(alg`next, DefiningPolynomial(t[i]) : IsTransitive, TopField:=t[i]) : i in [2..#t]];
  PGG_GlobalTimer_Pop();
  c`group := WreathProduct([cc`group : cc in Reverse(c`tower)]);
  c`base_field := BaseRing(f);
  degree := 1;
  for i in [#c`tower..1 by -1] do
    cc := c`tower[i];
    d := Degree(cc);
    cc`parent_subgroup := Stabilizer(c`group, {1..degree*d});
    oact := OrbitAction(cc`parent_subgroup, [1..degree*d]);
    bact := BlocksAction(Codomain(oact), [{(i-1)*degree+j : j in [1..degree]} : i in [1..d]]);
    cc`parent_quotient := oact * bact;
    degree *:= d;
  end for;
  assert Degree(c) eq degree;
  return c;
end intrinsic;

intrinsic EasyResolvents(conj :: PGGConj_Symmetric) -> []
  {Some trivial resolvents based on the initial presentation of the problem.}
  return [<conj`pol, Stabilizer(conj`group, 1)>];
end intrinsic;

intrinsic EasyResolvents(conj :: PGGConj_Factors) -> []
  {Some trivial resolvents based on the initial presentation of the problem.}
  // TODO: resolvents corresponding to each factor, and the whole polynomial?
  not_implemented("easy resolvents: factors");
end intrinsic;

intrinsic EasyResolvents(conj :: PGGConj_Tower) -> []
  {Some trivial resolvents based on the initial presentation of the problem.}
  // TODO: more resolvents corresponding to pieces of the tower?
  return [<conj`pol, Stabilizer(conj`group, 1)>];
end intrinsic;

intrinsic OrbitsOfSubgroups(conj :: PGGConj, n :: RngIntElt) -> []
  {All possible orbit systems of subgroups of conj`overgroup of index n, up to conjugacy.}
  require n ge 1: "n must be positive";
  if not IsDivisibleBy(#conj`group, n) then
    return [];
  end if;
  if not assigned conj`orbits_of_subgroups then
    conj`orbits_of_subgroups := AssociativeArray();
  end if;
  if not IsDefined(conj`orbits_of_subgroups, n) then
    conj`orbits_of_subgroups[n] := _OrbitsOfSubgroups(conj, n);
  end if;
  return conj`orbits_of_subgroups[n];
end intrinsic;

intrinsic _OrbitsOfSubgroups(conj :: PGGConj_Symmetric, n :: RngIntElt) -> []
  {"}
  // absolutely any partition of d corresponds to an orbit system for S_d: for such a partition, consider an element whose cycles are this partition, its orbits are precisely the partition.
  // what is the index of a partition? given partition P=[X_1,...,X_k] with |X_i|=d_i (so sum_i d_i = d) then Stab(P) = prod_i S_(d_i) has order prod_i d_i!, so index d!/prod_i d_i! = multinomial(d; d_1,...,d_k).
  todo := [<[Z|], Degree(conj), Degree(conj), n>];
  ret := [];
  while #todo gt 0 do
    // get an item from the todo list
    pop_start(~item, ~todo);
    partial, degree, limit, index := Explode(item);
    // are we done?
    if degree eq 0 then
      // are we valid?
      if index eq 1 then
        Append(~ret, [{d+1..d+partial[i]} where d:=&+partial[1..i-1] : i in [1..#partial]]);
      end if;
      continue;
    end if;
    // if not, choose a new element to add to the partition
    // we consider d and degree-d and the same time
    for d in [0..degree div 2] do
      if d gt limit then
        break;
      end if;
      x := Binomial(degree, d);
      if x gt index then
        break;
      end if;
      ok, y := IsDivisibleBy(index, x);
      if ok then
        dd := degree - d;
        if d gt 0 then
          Append(~todo, <Append(partial, d), dd, d, y>);
        end if;
        if dd le limit and dd ne d then
          Append(~todo, <Append(partial, dd), d, dd, y>);
        end if;
      end if;
    end for;
  end while;
  return ret;
end intrinsic;

intrinsic _OrbitsOfSubgroups(conj :: PGGConj_Tower, n :: RngIntElt) -> []
  {"}
  return _OrbitsOfSubgroups(conj, n, 1);
end intrinsic;

// given a sequence ns of integers and an integer m, finds all the sequences of integers cs so that sum_i cs_i * ns_i = m
function dot_product_inverse(ns, m)
  todo := [<[Z|], m>];
  ret := [PowerSequence(Z)|];
  while #todo gt 0 do
    pop_start(~item, ~todo);
    partial, target := Explode(item);
    // done?
    if #partial eq #ns then
      if target eq 0 then
        Append(~ret, partial);
      end if;
      continue;
    end if;
    // loop over possible next coefficients
    n := ns[#partial+1];
    for c in [0..target div n] do
      Append(~todo, <Append(partial, c), target - c*n>);
    end for;
  end while;
  return ret;
end function;

function factorizations_of_length(N, n : Max:=N)
  if n eq 0 then
    error if N ne 1, "impossible";
    return [];
  elif n eq 1 then
    return N le Max select [[N]] else [];
  else
    assert n gt 1;
    return &cat[PowerSequence(PowerSequence(Z))| [Append(facs, d) : facs in factorizations_of_length(xdiv(N, d), n-1 : Max:=d)] : d in Divisors(N) | d le Max];
  end if;
end function;

intrinsic _OrbitsOfSubgroups(conj :: PGGConj_Tower, n :: RngIntElt, m :: RngIntElt) -> []
  {"}
  assert m ge 1 and m le #conj`tower;
  if not assigned conj`orbits_of_subgroups_above then
    conj`orbits_of_subgroups_above := AssociativeArray();
  end if;
  if not IsDefined(conj`orbits_of_subgroups_above, <n,m>) then
    if m eq #conj`tower then
      ans := OrbitsOfSubgroups(conj`tower[m], n);
    elif Degree(conj`tower[m]) eq 1 then
      ans := _OrbitsOfSubgroups(conj, n, m+1);
    elif Degree(conj`tower[m]) eq 2 then
      upper_deg := &*[Z| Degree(conj`tower[i]) : i in [m+1..#conj`tower]];
      ans := [];
      case #conj`tower[m]`group:
      when 1:
        for n1 in Divisors(n) do
          n2 := xdiv(n, n1);
          if n2 lt n1 then 
            break;
          elif n2 eq n1 then
            oss := _OrbitsOfSubgroups(conj, n1, m+1);
            ans cat:= [[{x : x in o} : o in os1] cat [{x+upper_deg : x in o} : o in os2] where os1:=oss[i] where os2:=oss[j] : j in [i+1..#oss], i in [1..#oss]];
          else
            oss1 := _OrbitsOfSubgroups(conj, n1, m+1);
            oss2 := _OrbitsOfSubgroups(conj, n2, m+1);
            ans cat:= [[{x : x in o} : o in os1] cat [{x+upper_deg : x in o} : o in os2] : os1 in oss1, os2 in oss2];
          end if;
        end for;
      when 2:
        ok, nrest := IsDivisibleBy(n, 2);
        if ok then
          for n1 in Divisors(nrest) do
            n2 := xdiv(nrest, n1);
            if n2 lt n1 then
              break;
            elif n2 eq n1 then
              oss := _OrbitsOfSubgroups(conj, n1, m+1);
              ans cat:= [[{x : x in o} : o in os1] cat [{x+upper_deg : x in o} : o in os2] where os1:=oss[i] where os2:=oss[j] : j in [i..#oss], i in [1..#oss]];
            else
              oss1 := _OrbitsOfSubgroups(conj, n1, m+1);
              oss2 := _OrbitsOfSubgroups(conj, n2, m+1);
              ans cat:= [[{x : x in o} : o in os1] cat [{x+upper_deg : x in o} : o in os2] : os1 in oss1, os2 in oss2];
            end if;
          end for;
        end if;
        ok, nrest := IsSquare(n);
        if ok then
          oss := _OrbitsOfSubgroups(conj, nrest, m+1);
          ans cat:= [[{x : x in o} join {x+upper_deg : x in o} : o in os] : os in oss];
        end if;
      else
        assert false;
      end case;
    else
      // TODO: implement this in general
      //       this is quite tricky if we want to avoid conjugate answers:
      //       - first find orbits for the base group
      //       - group these by conjugacy
      //       - distribute a factorization of the remaining index over the conjugacy classes
      //       - then distribute over each orbit in each class, but with an ordering enforced
      //       - group orbits in each class further by the index they just received
      //       - find orbits for each of these indices
      //       - distribute these over each class, but with an ordering enforced
      //       - take the product of all these choices
      //       maybe it's worth changing the return value of OrbitsOfSubgroups to group the orbits by conjugacy
      not_implemented("OrbitsOfSubgroups: general towers");
    end if;
    conj`orbits_of_subgroups_above[<n,m>] := ans;
  end if;
  return conj`orbits_of_subgroups_above[<n,m>];
end intrinsic;

intrinsic _OrbitsOfSubgroups(conj :: PGGConj_Factors, n :: RngIntElt, m :: RngIntElt) -> []
  {"}
  if not assigned conj`orbits_of_subgroups_from then
    conj`orbits_of_subgroups_from := AssociativeArray();
  end if;
  if not IsDefined(conj`orbits_of_subgroups_from, <n, m>) then
    if m eq #conj`factors then
      oss := OrbitsOfSubgroups(conj`factors[m], n);
    else
      assert m lt #conj`factors;
      deg := Degree(conj`factors[m]);
      oss := [];
      for n1 in Divisors(n) do
        oss1 := OrbitsOfSubgroups(conj`factors[m], n1);
        oss2 := _OrbitsOfSubgroups(conj, xdiv(n,n1), m+1);
        oss2_shifted := [[{x+deg : x in o} : o in os] : os in oss2];
        for os1 in oss1 do
          for os2 in oss2_shifted do
            Append(~oss, os1 cat os2);
          end for;
        end for;
      end for;
    end if;
    conj`orbits_of_subgroups_from[<n, m>] := oss;
  end if;
  return conj`orbits_of_subgroups_from[<n, m>];
end intrinsic;

intrinsic _OrbitsOfSubgroups(conj :: PGGConj_Factors, n :: RngIntElt) -> []
  {"}
  return _OrbitsOfSubgroups(conj, n, 1);
end intrinsic;

intrinsic Print(conj :: PGGConj)
  {"}
  _Print(conj);
  ok, G := IsKnown(conj);
  if ok then
    if G eq Group(conj) then
      printf " exactly";
    else
      printf " actually %o", GroupName(G);
    end if;
  else
    if IsTransitive(conj) then
      printf " transitive";
    end if;
    if Overgroup(conj) ne Group(conj) then
      printf " subgroup of %o", GroupName(Overgroup(conj));
    end if;
  end if;
end intrinsic;

intrinsic _Print(conj :: PGGConj_Symmetric)
  {"}
  printf "Symmetric(%o)", Degree(conj);
end intrinsic;

intrinsic _Print(conj :: PGGConj_Factors)
  {"}
  printf "Factors(%o)", Join([Sprintf("%o", c) : c in conj`factors], ", ");
end intrinsic;

intrinsic _Print(conj :: PGGConj_Tower)
  {"}
  printf "Tower(%o)", Join([Sprintf("%o", c) : c in conj`tower], ", ");
end intrinsic;

intrinsic Group(conj :: PGGConj) -> GrpPerm
  {The group.}
  return conj`group;
end intrinsic;

intrinsic BaseField(conj :: PGGConj) -> FldPad
  {The base field.}
  return conj`base_field;
end intrinsic;

intrinsic Degree(conj :: PGGConj) -> RngIntElt
  {The degree of the group.}
  return Degree(conj`group);
end intrinsic;

intrinsic Overgroup(conj :: PGGConj) -> GrpPerm
  {An overgroup of the Galois group.}
  if not assigned conj`overgroup then
    ok, G := IsKnown(conj);
    if not ok then
      G := _Overgroup(conj);
    end if;
    assert G subset conj`group;
    conj`overgroup := G;
  end if;
  return conj`overgroup;
end intrinsic;

intrinsic _Overgroup(conj :: PGGConj_Symmetric) -> GrpPerm
  {"}
  return Group(conj);
end intrinsic;

intrinsic _Overgroup(conj :: PGGConj_Factors) -> GrpPerm
  {"}
  return DirectProduct([Overgroup(c) : c in conj`factors]);
end intrinsic;

intrinsic _Overgroup(conj :: PGGConj_Tower) -> GrpPerm
  {"}
  return WreathProduct([Overgroup(c) : c in Reverse(conj`tower)]);
end intrinsic;

intrinsic IsTransitive(conj :: PGGConj) -> BoolElt
  {True if the Galois group is known to be transitive on this part of the group.}
  if not assigned conj`is_transitive then
    conj`is_transitive := _IsTransitive(conj);
  end if;
  return conj`is_transitive;
end intrinsic;

intrinsic _IsTransitive(conj :: PGGConj_Factors) -> BoolElt
  {"}
  return #conj`factors le 1 and forall{c : c in conj`factors | IsTransitive(conj`factors[1])};
end intrinsic;

intrinsic _IsTransitive(conj :: PGGConj_Tower) -> BoolElt
  {"}
  assert forall{c : c in conj`tower | IsTransitive(c)};
  return true;
end intrinsic;

intrinsic IsConsistent(conj :: PGGConj, G :: GrpPerm) -> BoolElt
  {True if G could be the Galois group.}
  ok, G2 := IsKnown(conj);
  if ok then
    return IsConjugate(conj`group, G, G2);
  else
    return _IsConsistent(conj, G);
  end if;
end intrinsic;

intrinsic _IsConsistent(conj :: PGGConj_Symmetric, G :: GrpPerm) -> BoolElt
  {True if G could be the Galois group.}
  return (not IsTransitive(conj)) or IsTransitive(G);
end intrinsic;

intrinsic _IsConsistent(conj :: PGGConj_Factors, G :: GrpPerm) -> BoolElt
  {"}
  return forall{c : c in conj`factors | IsConsistent(c, c`parent_quotient(G meet c`parent_subgroup))};
end intrinsic;

intrinsic _IsConsistent(conj :: PGGConj_Tower, G :: GrpPerm) -> BoolElt
  {"}
  return forall{c : c in conj`tower | IsConsistent(c, c`parent_quotient(G meet c`parent_subgroup))};
end intrinsic;

intrinsic IsConsistentWithSubgroup(conj :: PGGConj, G :: GrpPerm) -> BoolElt
  {True if the Galois group could be a subgroup of G.}
  not_implemented("IsConsistentWithSubgroup: ", Type(conj));
end intrinsic;

intrinsic IsConsistentWithSubgroup(conj :: PGGConj_Symmetric, G :: GrpPerm) -> BoolElt
  {"}
  return (not IsTransitive(conj)) or IsTransitive(G);
end intrinsic;

intrinsic IsConsistentWithSubgroup(conj :: PGGConj_Factors, G :: GrpPerm) -> BoolElt
  {"}
  return forall{c : c in conj`factors | IsConsistentWithSubgroup(c, c`parent_quotient(G meet c`parent_subgroup))};
end intrinsic;

intrinsic IsConsistentWithSubgroup(conj :: PGGConj_Tower, G :: GrpPerm) -> BoolElt
  {"}
  return forall{c : c in conj`tower | IsConsistentWithSubgroup(c, c`parent_quotient(G meet c`parent_subgroup))};
end intrinsic;

intrinsic IsKnown(conj :: PGGConj) -> BoolElt, GrpPerm
  {True if the Galois group is known exactly, and the group.}
  if not assigned conj`is_known then
    ok, G := _IsKnown(conj);
    if ok then
      assert G subset conj`group;
      conj`is_known := [* true, G *];
    else
      conj`is_known := [* false *];
    end if;
  end if;
  if conj`is_known[1] then
    return true, conj`is_known[2];
  else
    return false, _;
  end if;
end intrinsic;

intrinsic _IsKnown(conj :: PGGConj_Factors) -> BoolElt, GrpPerm
  {"}
  if #[c : c in conj`factors | Degree(c) gt 1] le 1 then
    Gs := [];
    for c in conj`factors do
      ok, G := IsKnown(c);
      if ok then
        Append(~Gs, G);
      else
        return false, _;
      end if;
    end for;
    return true, DirectProduct(Gs);
  else
    return false, _;
  end if;
end intrinsic;

intrinsic _IsKnown(conj :: PGGConj_Tower) -> BoolElt, GrpPerm
  {"}
  if #[c : c in conj`tower | Degree(c) gt 1] le 1 then
    Gs := [];
    for c in conj`tower do
      ok, G := IsKnown(c);
      if ok then
        Append(~Gs, G);
      else
        return false, _;
      end if;
    end for;
    return true, WreathProduct(Reverse(Gs));
  else
    return false, _;
  end if;
end intrinsic;

intrinsic PGGAlg_ResPriority_Null_Make() -> PGGAlg_ResPriority_Null_Make
  {The "Null" subgroups priority.}
  alg := New(PGGAlg_ResPriority_Null);
  return alg;
end intrinsic;

intrinsic PGGAlg_ResPriority_Random_Make() -> PGGAlg_ResPriority_Random_Make
  {The "Random" subgroups priority.}
  alg := New(PGGAlg_ResPriority_Random);
  return alg;
end intrinsic;

intrinsic PGGAlg_ResPriority_Reverse_Make(:Priority:=false) -> PGGAlg_ResPriority_Reverse_Make
  {The "Reverse" subgroups priority.}
  alg := New(PGGAlg_ResPriority_Reverse);
  alg`priority := Priority cmpne false select Priority else PGGAlg_ResPriority_Null_Make();
  return alg;
end intrinsic;

intrinsic PGGAlg_ResPriority_Key_Make(key :: PGGExpr) -> PGGAlg_ResPriority_Key
  {The "Key" subgroups priority.}
  alg := New(PGGAlg_ResPriority_Key);
  assert FreeVariables(key) subset {"Index", "OrbitIndex", "Diversity", "Information"};
  alg`key := key;
  return alg;
end intrinsic;

intrinsic Print(alg :: PGGAlg_ResPriority_Null)
  {Print.}
  printf "null";
end intrinsic;

intrinsic Print(alg :: PGGAlg_ResPriority_Random)
  {"}
  printf "random";
end intrinsic;

intrinsic Print(alg :: PGGAlg_ResPriority_Reverse)
  {"}
  print "reverse of %o", alg`priority;
end intrinsic;

intrinsic Print(alg :: PGGAlg_ResPriority_Key)
  {"}
  printf "key %o", alg`key;
end intrinsic;

intrinsic Prioritize(X, P :: PGGAlg_ResPriority_Null, s :: PGGAlgState_ResGroups) -> .
  {Prioritizes X.}
  return X;
end intrinsic;

intrinsic Prioritize(X, P :: PGGAlg_ResPriority_Reverse, s :: PGGAlgState_ResGroups) -> .
  {Prioritizes X.}
  return Reverse(Prioritize(X, P`priority, s));
end intrinsic;

intrinsic Prioritize(X, P :: PGGAlg_ResPriority_Random, s :: PGGAlgState_ResGroups) -> .
  {Prioritizes X.}
  return Shuffle(X);
end intrinsic;

intrinsic Prioritize(X, P :: PGGAlg_ResPriority_Key, s :: PGGAlgState_ResGroups) -> .
  {"}
  return SortBy(X, function (i)
    return Evaluate(P`key, func<name | case<name |
      "Index": Index(s`overgroup, i`subgroup),
      "OrbitIndex": Index(s`overgroup, Stabilizer(s`overgroup, [{x : x in o} : o in Orbits(i`subgroup)])),
      "Diversity": Diversity(i, s),
      "Information": Information(i, s),
      default: not_implemented(name)
    >>);
  end function);
end intrinsic;

intrinsic PGGAlg_ResChoice_Tranche_Make(:Tranche:=false, Priority:=false) -> PGGAlg_ResChoice_Tranche
  {The "Tranche" subgroups choice.}
  alg := New(PGGAlg_ResChoice_Tranche);
  alg`tranche_alg := Tranche cmpne false select Tranche else PGGAlg_Tranche_Index_Make();
  alg`priority := Priority cmpne false select Priority else PGGAlg_ResPriority_Null_Make();
  return alg;
end intrinsic;

intrinsic Print(alg :: PGGAlg_ResChoice_Tranche)
  {Print.}
  print "tranche";
  IndentPush();
  print "tranche =", alg`tranche_alg;
  printf "priority = "; Print(alg`priority);
  IndentPop();
end intrinsic;

intrinsic PGGAlg_Tranche_All_Make(:Verbosity:=1) -> PGGAlg_Tranche_All
  {The "All" subgroups choice.}
  alg := New(PGGAlg_Tranche_All);
  alg`verbosity := Verbosity;
  return alg;
end intrinsic;

intrinsic PGGAlg_Tranche_Index_Make(:Filter:=false, SortKey:=false, Verbosity:=1) -> PGGAlg_Tranche_Index
  {The "Index" subgroups choice.}
  alg := New(PGGAlg_Tranche_Index);
  alg`verbosity := Verbosity;
  alg`filter := Filter;
  alg`sort_key := SortKey;
  return alg;
end intrinsic;

intrinsic PGGAlg_Tranche_OrbitIndex_Make(:Filter:=false, SortKey:=false, Verbosity:=1) -> PGGAlg_Tranche_OrbitIndex
  {The "Index" subgroups choice.}
  alg := New(PGGAlg_Tranche_OrbitIndex);
  alg`verbosity := Verbosity;
  alg`filter := Filter;
  alg`sort_key := SortKey;
  return alg;
end intrinsic;

intrinsic Print(alg :: PGGAlg_Tranche_All)
  {Print.}
  printf "all";
end intrinsic;

intrinsic Print(alg :: PGGAlg_Tranche_Index)
  {"}
  print "index";
  IndentPush();
  print "filter =", alg`filter cmpeq false select "none" else alg`filter;
  printf "sort by = %o", alg`sort_key cmpeq false select "none" else alg`sort_key;
  IndentPop();
end intrinsic;

intrinsic Print(alg :: PGGAlg_Tranche_OrbitIndex)
  {"}
  print "orbit index";
  IndentPush();
  print "filter =", alg`filter cmpeq false select "none" else alg`filter;
  printf "sort by = %o", alg`sort_key cmpeq false select "none" else alg`sort_key;
  IndentPop();
end intrinsic;

intrinsic Start(alg :: PGGAlg_ResChoice_Tranche, parent :: PGGAlgState_ResGroups) -> PGGAlgState_ResChoice_Tranche
  {Starts alg.}
  s := New(PGGAlgState_ResChoice_Tranche);
  s`algorithm := alg;
  s`parent := parent;
  s`overgroup := parent`overgroup;
  s`tranche_state := Start(alg`tranche_alg, parent`conjugacy);
  return s;
end intrinsic;

intrinsic Start(alg :: PGGAlg_Tranche_All, conj :: PGGConj) -> PGGAlgState_Tranche_All
  {Starts alg.}
  s := New(PGGAlgState_Tranche_All);
  s`algorithm := alg;
  s`conjugacy := conj;
  return s;
end intrinsic;

intrinsic Start(alg :: PGGAlg_Tranche_Index, conj :: PGGConj) -> PGGAlgState_Tranche_Index
  {"}
  s := New(PGGAlgState_Tranche_Index);
  s`algorithm := alg;
  s`conjugacy := conj;
  s`indices := Divisors(Order(s`conjugacy`group));
  if alg`filter cmpne false then
    s`indices := [n : n in s`indices | Evaluate(alg`filter, func<name | case<name | "idx": n, default: not_implemented()>>)];
  end if;
  if alg`sort_key cmpne false then
    s`indices := sort_by(s`indices, func<n | Evaluate(alg`filter, func<name | case<name | "idx": n, default: not_implemented()>>)>);
  else
    s`indices := Sort(s`indices);
  end if;
  s`all_groups := [];
  Reset(s);
  return s;
end intrinsic;

intrinsic Start(alg :: PGGAlg_Tranche_OrbitIndex, conj :: PGGConj) -> PGGAlgState_Tranche_OrbitIndex
  {"}
  s := New(PGGAlgState_Tranche_OrbitIndex);
  s`algorithm := alg;
  s`conjugacy := conj;
  s`indices := [<idx,ridx> : ridx in Divisors(idx), idx in Divisors(Order(s`conjugacy`group))];
  if alg`filter cmpne false then
    s`indices := [nr : nr in s`indices | Evaluate(alg`filter, func<name | case<name | "idx": nr[1], "ridx": nr[2], "oidx": nr[1] div nr[2], default: not_implemented()>>)];
  end if;
  if alg`sort_key cmpne false then
    s`indices := sort_by(s`indices, func<nr | Evaluate(alg`filter, func<name | case<name | "idx": nr[1], "ridx": nr[2], "oidx": nr[1] div nr[2], default: not_implemented()>>)>);
  else
    s`indices := Sort(s`indices);
  end if;
  vprint PGG_GaloisGroup: "indices =", s`indices;
  s`all_groups := AssociativeArray();
  s`all_stabilizers := [];
  Reset(s);
  return s;
end intrinsic;

intrinsic Reset(s :: PGGAlgState_Tranche)
  {Starts choosing from the beginning again.}
  SetState(s, InitialState(s));
end intrinsic;

intrinsic Reset(s :: PGGAlgState_ResChoice_Tranche)
  {Starts the choice from the beginning again.}
  Reset(s`tranche_state);
end intrinsic;

intrinsic TrancheIndex(s :: PGGAlgState_Tranche_All) -> .
  {The index of the current tranche.}
  return false;
end intrinsic;

intrinsic TrancheIndex(s :: PGGAlgState_Tranche_Index) -> .
  {"}
  return s`ii;
end intrinsic;

intrinsic TrancheIndex(s :: PGGAlgState_Tranche_OrbitIndex) -> .
  {"}
  return <s`ii, s`si>;
end intrinsic;

intrinsic InitialState(s :: PGGAlgState_Tranche_All) -> .
  {Gets the initial state of the choice.}
  return false;
end intrinsic;

intrinsic InitialState(s :: PGGAlgState_Tranche_Index) -> .
  {"}
  return <0, []>;
end intrinsic;

intrinsic InitialState(s :: PGGAlgState_Tranche_OrbitIndex) -> .
  {"}
  return <0, 0, [], []>;
end intrinsic;

intrinsic CurrentState(s :: PGGAlgState_Tranche_All) -> .
  {Gets the current state of the choice.}
  return assigned s`tranche select s`tranche else false;
end intrinsic;

intrinsic CurrentState(s :: PGGAlgState_Tranche_Index) -> .
  {"}
  return <s`ii, s`tranche>;
end intrinsic;

intrinsic CurrentState(s :: PGGAlgState_Tranche_OrbitIndex) -> .
  {"}
  return <s`ii, s`si, s`tranche, s`cur_stabilizers>;
end intrinsic;

intrinsic SetState(s :: PGGAlgState_Tranche_All, x)
  {Sets the state of the choice.}
  if x cmpeq false then
    if assigned s`tranche then
      delete s`tranche;
    end if;
  else
    s`tranche := x;
  end if;
end intrinsic;

intrinsic SetState(s :: PGGAlgState_Tranche_Index, x)
  {"}
  s`ii := x[1];
  s`tranche := x[2];
end intrinsic;

intrinsic SetState(s :: PGGAlgState_Tranche_OrbitIndex, x)
  {"}
  s`ii := x[1];
  s`si := x[2];
  s`tranche := x[3];
  s`cur_stabilizers := x[4];
end intrinsic;

intrinsic Subgroup(s :: PGGAlgState_ResChoice_Tranche) -> GrpPerm
  {Selects a subgroup.}
  while true do
    PGG_GlobalTimer_Push("tranche");
    tranche := Tranche(s`tranche_state);
    assert #tranche gt 0;
    PGG_GlobalTimer_Swap("prioritize");
    tranche2 := Prioritize(Filter(PGG_ToIter(tranche), func<i | IsUseful(s`parent, i)>), s`algorithm`priority, s`parent);
    ok, i := HasNext(tranche2);
    PGG_GlobalTimer_Pop();
    if ok then
      Forget(i);
      return Group(i);
    end if;
  end while;
end intrinsic;

intrinsic Tranche(s :: PGGAlgState_Tranche) -> []
  {Gets a tranche of potential subgroups}
  ok, t := HasTranche(s);
  require ok: "no more tranches";
  assert #t gt 0;
  return t;
end intrinsic;

intrinsic HasTranche(s :: PGGAlgState_Tranche_All) -> []
  {Gets a tranche of potential subgroups.}
  if not assigned s`tranche then
    if not assigned s`all_groups then
      s`all_groups := [x`subgroup : x in Subgroups(s`conjugacy`group)];
    end if;
    s`tranche := MakeTranche(s, s`all_groups);
  end if;
  if #s`tranche gt 0 then
    return true, [i : i in s`tranche];
  else
    return false, _;
  end if;
end intrinsic;

intrinsic HasTranche(s :: PGGAlgState_Tranche_Index) -> []
  {"}
  while #s`tranche eq 0 do
    if s`ii ge #s`indices then
      return false, _;
    end if;
    s`ii +:= 1;
    index := s`indices[s`ii];
    vprint PGG_GaloisGroup, s`algorithm`verbosity: "index =", index;
    if not IsDefined(s`all_groups, s`ii) then
      s`all_groups[s`ii] := [x`subgroup : x in Subgroups(s`conjugacy`group : IndexEqual:=index)];
    end if;
    s`tranche := MakeTranche(s, s`all_groups[s`ii]);
  end while;
  return true, [i : i in s`tranche];
end intrinsic;

intrinsic HasTranche(s :: PGGAlgState_Tranche_OrbitIndex) -> []
  {"}
  while #s`tranche eq 0 do
    while s`si ge #s`cur_stabilizers do
      if s`ii ge #s`indices then
        return false, _;
      end if;
      s`ii +:= 1;
      s`si := 0;
      idx, ridx := Explode(s`indices[s`ii]);
      oidx := xdiv(idx, ridx);
      vprint PGG_GaloisGroup, s`algorithm`verbosity: "index =", idx, ridx, oidx;
      if not IsDefined(s`all_stabilizers, oidx) then
        s`all_stabilizers[oidx] := [Stabilizer(s`conjugacy`group, os) : os in OrbitsOfSubgroups(s`conjugacy, oidx)];
        assert forall{S : S in s`all_stabilizers[oidx] | Index(s`conjugacy`group, S) eq oidx};
      end if;
      s`cur_stabilizers := s`all_stabilizers[oidx];
    end while;
    s`si +:= 1;
    idx, ridx := Explode(s`indices[s`ii]);
    k := <idx, ridx, s`si>;
    if not IsDefined(s`all_groups, k) then
      s`all_groups[k] := [x`subgroup : x in Subgroups(s`cur_stabilizers[s`si] : IndexEqual:=ridx)];
      assert forall{U : U in s`all_groups[k] | Index(s`conjugacy`group, U) eq idx};
    end if;
    s`tranche := MakeTranche(s, s`all_groups[k]);
  end while;
  return true, [i : i in s`tranche];
end intrinsic;

intrinsic MakeTranche(s :: PGGAlgState_Tranche, groups :: [GrpPerm]) -> .
  {Makes a new tranche.}
  return [TrancheItem(s, i, groups[i]) : i in [1..#groups]];
end intrinsic;

intrinsic TrancheItem(s :: PGGAlgState_Tranche, idx, subgroup :: GrpPerm) -> PGGAlgState_TrancheItem
  {An item in a tranche.}
  i := New(PGGAlgState_TrancheItem);
  i`state := s;
  i`idx := idx;
  i`subgroup := subgroup;
  i`tidx := TrancheIndex(s);
  return i;
end intrinsic;

intrinsic Id(i :: PGGAlgState_TrancheItem) -> .
  {Identifies this tranche item uniquely.}
  return <i`idx, i`tidx>;
end intrinsic;

intrinsic Hash(i :: PGGAlgState_TrancheItem) -> .
  {Hash.}
  return Hash(Id(i));
end intrinsic;

intrinsic 'eq'(i :: PGGAlgState_TrancheItem, j :: PGGAlgState_TrancheItem) -> .
  {Equality.}
  require IsIdentical(i`state, j`state): "must be from the same set of tranches";
  return Id(i) eq Id(j);
end intrinsic;

intrinsic ForgetTrancheItem(s :: PGGAlgState_Tranche_All, i :: RngIntElt)
  {Don't consider this item again.}
  Undefine(~s`tranche, i);
end intrinsic;

intrinsic ForgetTrancheItem(s :: PGGAlgState_Tranche_Index, i :: RngIntElt)
  {"}
  Undefine(~s`tranche, i);
end intrinsic;

intrinsic ForgetTrancheItem(s :: PGGAlgState_Tranche_OrbitIndex, i :: RngIntElt)
  {"}
  Undefine(~s`tranche, i);
end intrinsic;

intrinsic Group(i :: PGGAlgState_TrancheItem) -> GrpPerm
  {The group.}
  return i`subgroup;
end intrinsic;

intrinsic IsUseful(s :: PGGAlgState_ResGroups_All, i :: PGGAlgState_TrancheItem) -> BoolElt
  {"}
  Gs := s`possible_groups;
  h := CosetAction(s`overgroup, i`subgroup);
  statalg := s`algorithm`statistic;
  stat1 := GroupStat(statalg, h(Gs[1]));
  is_useful := exists{G : G in Gs[2..#Gs] | GroupStat(statalg, h(G)) ne stat1};
  if not is_useful then
    Forget(i);
  end if;
  return is_useful;
end intrinsic;

// The actual Galois group is either:
// - one of the groups in the current layer; or
// - a subgroup of one of the children of the current layer.
// So we say U is useful if either:
// - it eliminates one of the groups in the layer as a possibility; or
// - it eliminates one of the children as a possible overgroup.
//
// Consider the case where there is a single node in the layer, and it has a single child. If the statistic is the same on node and child, then we cannot conclude anything. If it is different, then the actual statistic is either that of the node, and hence rules out the child (which is a strict refinement), or is a refinement of that of the child, and hence rules out the node.
// 
// Suppose now there is a single node with several children. We partition the children into two sets, those with the same statistic as the node, and those with different statistics (which therefore are strict refinements). If the actual statistic is that of the node, then we rule out the children with different statistics. If the actual statistic is a refinement of one of the different children, then we rule out the node (and maybe some children).
// 
// More generally, if there is a node with maybe_equal=true and a child (of possibly a different node) with maybe_subgroup=true such that the statistic for the child is a strict refinement of that of the node, then we will distinguish between them: if the actual statistic agrees with the node, then it cannot agree with the child.
intrinsic IsUseful(s :: PGGAlgState_ResGroups_Maximal, i :: PGGAlgState_TrancheItem) -> BoolElt
  {"}
  h := CosetAction(s`overgroup, i`subgroup);
  statalg := s`algorithm`statistic;
  case s`algorithm`useful:
  when "Sufficient":
    is_useful := (
        #nstats ge 2 and (
          exists{nstat : nstat in nstats[2..#nstats] | nstat1 ne nstat}
          where nstat1 := nstats[1]
        )
      ) or (
        exists{nstat : nstat in nstats, mstat in mstats | (mstat ne nstat) and (mstat subset nstat)}
        where mstats := [GroupStat(m, h) : m in {m : m in PossibleChildren(n), n in s`current_layer | m`maybe_subgroup}]
      )
      where nstats := [GroupStat(n, h) : n in s`current_layer | n`maybe_equal];
  when "Necessary":
    is_useful := (
        #nstats ge 2 and (
          exists{nstat : nstat in nstats[2..#nstats] | nstat1 ne nstat}
          where nstat1 := nstats[1]
        )
      ) or (
        exists{nstat : nstat in nstats, mstat in mstats | not (nstat subset mstat)}
        where mstats := [GroupStat(m, h) : m in {m : m in PossibleChildren(n), n in s`current_layer | m`maybe_subgroup}]
      )
      where nstats := [GroupStat(n, h) : n in s`current_layer | n`maybe_equal];
  when "Generous":
    ns := [n : n in s`current_layer | n`maybe_equal] cat [m : m in PossibleChildren(n), n in s`current_layer | m`maybe_subgroup];
    assert #ns ge 2;
    stat1 := GroupStat(ns[1], h);
    is_useful := exists{n : n in ns[2..#ns] | GroupStat(n, h) ne stat1};
  when "All":
    is_useful := Index(s`overgroup, i`subgroup) ne 1;
  else
    assert false;
  end case;
  if not is_useful then
    Forget(i);
  end if;
  return is_useful;
end intrinsic;

intrinsic Information(i :: PGGAlgState_TrancheItem, s :: PGGAlgState_ResGroups_All) -> FldReElt
  {The information provided by this item.}
  Gs := s`possible_groups;
  h := CosetAction(s`overgroup, i`subgroup);
  statalg := s`algorithm`statistic;
  stats := {* GroupStat(statalg, h(G)) : G in Gs *};
  return multiplicities_to_information(Multiplicities(stats));
end intrinsic;

intrinsic Diversity(i :: PGGAlgState_TrancheItem, s :: PGGAlgState_ResGroups_All) -> RngIntElt
  {The information provided by this item.}
  Gs := s`possible_groups;
  h := CosetAction(s`overgroup, i`subgroup);
  statalg := s`algorithm`statistic;
  stats := { GroupStat(statalg, h(G)) : G in Gs };
  return #stats;
end intrinsic;

intrinsic Forget(i :: PGGAlgState_TrancheItem)
  {Don't consider this item again.}
  require i`tidx eq TrancheIndex(i`state): "state has moved to a different tranche";
  ForgetTrancheItem(i`state, i`idx);
end intrinsic;

intrinsic PGGAlg_ResGroups_All_Make(:Statistic:=false, SubgroupChoice:=false) -> PGGAlg_ResGroups_All
  {The "All" resolvent groups algorithm.}
  alg := New(PGGAlg_ResGroups_All);
  alg`statistic := Statistic cmpne false select Statistic else PGGStat_FactorDegrees_Make();
  alg`subgroup_choice := SubgroupChoice cmpne false select SubgroupChoice else PGGAlg_ResChoice_Tranche_Make();
  return alg;
end intrinsic;

intrinsic PGGAlg_ResGroups_Maximal_Make(:Statistic:=false, SubgroupChoice:=false, Descend:=false, Reprocess:=true, Reset:=true, Useful:=false, Blacklist:=false, Dedupe:=false) -> PGGAlg_ResGroups_Maximal
  {The "Maximal" resolvent groups algorithm.}
  alg := New(PGGAlg_ResGroups_Maximal);
  alg`statistic := Statistic cmpne false select Statistic else PGGStat_FactorDegrees_Make();
  alg`subgroup_choice := SubgroupChoice cmpne false select SubgroupChoice else PGGAlg_ResChoice_Tranche_Make();
  alg`descend := Descend cmpne false select Descend else "Steady";
  alg`reprocess := Reprocess;
  alg`reset := Reset;
  alg`useful := Useful cmpne false select Useful else "Generous";
  alg`blacklist := Blacklist;
  alg`dedupe := Dedupe;
  return alg;
end intrinsic;

intrinsic PGGAlg_ResGroups_RootsMaximal_Make( : Dedupe:=false) -> PGGAlg_ResGroups_RootsMaximal
  {The "RootsMaximal" resolvent groups algorithm.}
  alg := New(PGGAlg_ResGroups_RootsMaximal);
  alg`dedupe := Dedupe;
  return alg;
end intrinsic;

intrinsic Print(alg :: PGGAlg_ResGroups_All)
  {Print.}
  print "all";
  IndentPush();
  print "subgroup choice =", alg`subgroup_choice;
  printf "statistic = %o", alg`statistic;
  IndentPop();
end intrinsic;

intrinsic Print(alg :: PGGAlg_ResGroups_Maximal)
  {"}
  print "maximal";
  IndentPush();
  print "subgroup choice =", alg`subgroup_choice;
  print "statistic =", alg`statistic;
  print "descend =", alg`descend;
  print "useful =", alg`useful;
  print "reprocess =", alg`reprocess;
  print "reset =", alg`reset;
  print "blacklist =", alg`blacklist;
  printf "dedupe = %o", alg`dedupe;
  IndentPop();
end intrinsic;

intrinsic Print(alg :: PGGAlg_ResGroups_RootsMaximal)
  {"}
  printf "roots maximal";
end intrinsic;

intrinsic Subgroup(s :: PGGAlgState_ResGroups_All) -> GrpPerm
  {Selects a subgroup to form a resolvent with.}
  return Subgroup(s`choice_state);
end intrinsic;

intrinsic Subgroup(s :: PGGAlgState_ResGroups_Maximal) -> GrpPerm
  {"}
  return Subgroup(s`choice_state);
end intrinsic;

intrinsic Subgroup(s :: PGGAlgState_ResGroups_RootsMaximal) -> GrpPerm
  {"}
  return Rep(PossibleSubgroups(s)[1]);
end intrinsic;

intrinsic PGGAlg_ResEval_Global_Make() -> PGGAlg_ResEval_Global
  {The "Absolute" resolvent evaluation algorithm.}
  alg := New(PGGAlg_ResEval_Global);
  return alg;
end intrinsic;

intrinsic Print(alg :: PGGAlg_ResEval_Global)
  {Print.}
  printf "global";
end intrinsic;

intrinsic PGGAlg_GaloisGroup_ResolventMethod_Make( : GroupsAlg:=false, ResolventAlg:=false, ConjugacyAlg:=false, UseEasyResolvents:=false) -> PGGAlg_GaloisGroup_ResolventMethod
  {The resolvent method algorithm for computing Galois groups.}
  alg := New(PGGAlg_GaloisGroup_ResolventMethod);
  alg`groups_alg := GroupsAlg cmpne false select GroupsAlg else PGGAlg_ResGroups_All_Make();
  alg`resolvent_alg := ResolventAlg cmpne false select ResolventAlg else PGGAlg_ResEval_Global_Make();
  alg`conjugacy_alg := ConjugacyAlg cmpne false select ConjugacyAlg else PGGAlg_Conjugacy_Factors_Make(:Next:=PGGAlg_Conjugacy_RamTower_Make());
  alg`use_easy_resolvents := UseEasyResolvents;
  return alg;
end intrinsic;

intrinsic PGGAlg_GaloisGroup_Builtin_Make() -> PGGAlg_GaloisGroup_Builtin
  {Calls Magma's builtin GaloisGroup intrinsic, which currently computes a splitting field explicitly.}
  alg := New(PGGAlg_GaloisGroup_Builtin);
  return alg;
end intrinsic;

intrinsic PGGAlg_GaloisGroup_SinglyRamified_Make() -> PGGAlg_GaloisGroup_SinglyRamified
  {A direct algorithm for singly ramified extensions.}
  alg := New(PGGAlg_GaloisGroup_SinglyRamified);
  return alg;
end intrinsic;

intrinsic Print(alg :: PGGAlg_GaloisGroup_ResolventMethod)
  {Print.}
  print "resolvent method";
  IndentPush();
  print "conjugacy =", alg`conjugacy_alg;
  print "groups =", alg`groups_alg;
  print "resolvents =", alg`resolvent_alg;
  printf "use easy resolvents = %o", alg`use_easy_resolvents;
  IndentPop();
end intrinsic;

intrinsic Print(alg :: PGGAlg_GaloisGroup_Builtin)
  {"}
  printf "builtin";
end intrinsic;

intrinsic Print(alg :: PGGAlg_GaloisGroup_SinglyRamified)
  {"}
  printf "singly ramified";
end intrinsic;

intrinsic RamificationGroup(Alg :: PGGAlg_GaloisGroup_ResolventMethod, f :: RngUPolElt[FldPad], u :: FldRatElt) -> GrpPerm
  {The u-th ramification group of f.}
  if u ge 0 then
    not_implemented("RamificationGroup except GaloisGroup");
  end if;
  PGG_GlobalTimer_Push("conjugacy");
  conj := Conjugacy(Alg`conjugacy_alg, f);
  vprint PGG_GaloisGroup: "conjugacy =", conj;
  ok, G := IsKnown(conj);
  if ok then
    return G;
  end if;
  PGG_GlobalTimer_Swap("start resolvent");
  rst := Start(Alg`resolvent_alg, conj);
  PGG_GlobalTimer_Swap("overgroup");
  W := Overgroup(rst);
  vprint PGG_GaloisGroup: "overgroup =", W;
  PGG_GlobalTimer_Swap("start groups");
  gst := Start(Alg`groups_alg, conj, W);
  if Alg`use_easy_resolvents then
    vprint PGG_GaloisGroup: "easy resolvents...";
    PGG_GlobalTimer_Swap("easy resolvents");
    RUs := EasyResolvents(conj);
    for RU in RUs do
      if IsDone(gst) then
        break;
      end if;
      R, U := Explode(RU);
      PGG_GlobalTimer_Swap("process resolvent");
      ProcessResolvent(gst, R, U);
    end for;
  end if;
  PGG_GlobalTimer_Swap("check done");
  if not IsDone(gst) then
    vprint PGG_GaloisGroup: "main loop...";
    repeat
      PGG_GlobalTimer_Swap("subgroup");
      U := Subgroup(gst);
      vprint PGG_GaloisGroup: "subgroup index =", Index(W, U);
      vprint PGG_GaloisGroup: "orbit-relative index =", Index(Stabilizer(W, Orbits(U)), U);
      PGG_GlobalTimer_Swap("invariant");
      I := RelativeInvariant(W, U);
      vprint PGG_GaloisGroup: "invariant =", I;
      PGG_GlobalTimer_Swap("resolvent");
      R := Resolvent(rst, I, U);
      vprint PGG_GaloisGroup: "resolvent =", R;
      PGG_GlobalTimer_Swap("process resolvent");
      ProcessResolvent(gst, R, U);
      PGG_GlobalTimer_Swap("check done");
    until IsDone(gst);
  end if;
  vprint PGG_GaloisGroup: "success";
  PGG_GlobalTimer_Pop();
  return TheGroup(gst);
end intrinsic;

intrinsic GaloisGroup(alg :: PGGAlg_GaloisGroup_Builtin, f :: RngUPolElt[FldPad]) -> GrpPerm
  {The Galois group of f.}
  G := GaloisGroup(f);
  return G;
end intrinsic;

// some example polynomials to try this on:
// Example 9.* from Greve, Pauli "On ramification polygons..."
// Example 3.24 from Milstead "Computing Galois groups..." (thesis)
intrinsic GaloisGroup(alg :: PGGAlg_GaloisGroup_SinglyRamified, f :: RngUPolElt[FldPad]) -> GrpPerm
  {The Galois group of f.}
  // check f is irreducible and find the extension it defines
  d := Degree(f);
  facs, certs := factorization(f : Extensions);
  error if #facs ne 1, "only implemented for irreducible f";
  K := BaseRing(f);
  cert := certs[1];
  L := cert`Extension;
  assert Degree(L, K) eq d;
  assert cert`E * cert`F eq d;

  // special case: unramified
  if cert`E eq 1 then
    return CyclicGroup(GrpPerm, cert`F);
  elif cert`F ne 1 then
    error "f must define a singly ramified extension";
  end if;

  // special case: totally tamely ramified
  p := Prime(K);
  Qp := PrimeField(K);
  q := p^InertiaDegree(K, Qp);
  if not IsDivisibleBy(d, p) then
    // the inertia degree of the Galois closure, i.e. the degree of K(zeta_d)/K
    F := Min([F : F in [1..d] | IsDivisibleBy(q^F-1, d)]);
    S := SymmetricGroup(d);
    gen1 := S![(i mod d)+1 : i in [1..d]];
    gen2 := S![(((i-1)*q) mod d) + 1 : i in [1..d]];
    return sub<S | gen1, gen2>;
  end if;

  // check we are totally wildly ramified
  ok, m := IsPowerOf(d, p);
  error if not ok, "f must define a singly ramified extension";
  // compute the ramification polynomial and polygon
  phi := DefiningPolynomial(L);
  assert BaseRing(phi) eq K;
  assert is_eisenstein(phi);
  x := PolynomialRing(L).1;
  pi := L.1;
  assert IsWeaklyZero(Evaluate(phi, pi));
  r := Evaluate(phi, x+pi) div x;
  assert Degree(r) eq d-1;
  rp := NewtonPolygon([<i,Valuation(Coefficient(r, i))> : i in [0..d-1]] : Faces:="Lower");
  vs := ChangeUniverse(Vertices(rp), car<Z,Z>);
  assert vs[1][1] eq 0;
  assert vs[#vs][1] eq d-1;
  assert forall{v : v in vs | not IsWeaklyZero(Coefficient(r, v[1]))};
  assert forall{v : v in vs | IsPowerOf(v[1]+1, p)};
  error if #vs ne 2, "f must define a singly ramified extension";
  // now compute the galois group
  // this is an implementation of Algorithm 3.23 of Milstead's thesis.
  // we try to keep the notation and step numbers of the description
  // step 1
  slope := (vs[2][2] - vs[1][2])/(vs[2][1] - vs[1][1]);
  h := Numerator(-slope);
  e := Denominator(-slope);
  ok, d0 := IsDivisibleBy(d-1, e);
  assert ok;
  // step 2
  Fq, LtoFq:=ResidueClassField(Integers(L));
  assert #Fq eq q;
  A := Polynomial([ShiftValuation(Coefficient(r, i*e), i*h - vs[1][2]) @ LtoFq : i in [0..d0]]);
  assert Degree(A) eq d0;
  assert Coefficient(A, 0) ne 0;
  assert Coefficient(A, d0) ne 0;
  // steps 3 and 4 and 6
  FqF := SplittingField(A * (Parent(A).1^e - 1));
  zeta := PrimitiveElement(FqF);
  F := Degree(FqF, Fq);
  assert #FqF eq q^F;
  // step 5
  g, a, a2 := XGCD(e, -p^m);
  assert g eq 1;
  g, b, b2 := XGCD(h, -e);
  assert g eq 1;
  // step 7
  us := [x[1] : x in Roots(ChangeRing(A, FqF))];
  assert #us eq d0;
  // steps 8 and 9
  r := Log(zeta, us[1]^b) mod e;
  // steps 10 and 11 (V is the additive group of FqF)
  V, FqFtoV := VectorSpace(FqF, GF(p));
  generators := [V | FqFtoV(0)];
  M := sub<V | generators>;
  assert #M eq 1;
  assert Dimension(M) eq 0;
  for i in [1..d0] do
    roots := [x[1] : x in Roots(PolynomialRing(FqF).1^e - us[i]/zeta^(r*h))];
    assert #roots eq e;
    generators cat:= [V | FqFtoV(a*x) : x in roots];
    M := sub<V | generators>;
    assert #M eq p^Dimension(M);
    // if #M eq p^m then
    //   break;
    // end if;
  end for;
  assert #M eq p^m;
  assert Dimension(M) eq m;
  // step 12
  assert BaseField(M) eq GF(p);
  B := Basis(M);
  assert #B eq m;
  assert Universe(B) eq M;
  // step 13
  ok, ell := IsDivisibleBy(q^F-1, e);
  assert ok;
  ok, k := IsDivisibleBy(r*(q-1), e);
  assert ok;
  // steps 14, 15, 16, 17
  // the following line works around a bug in Magma: it refuses to compute AGL(GrpMat,1,GF(p))
  AGLmp := m eq 1 select sub<G | [G| [[M[1,1], 0],[0,1]] : M in Generators(GL(1,GF(p)))] cat [G![[1,0],[1,1]]]> where G:=GL(2,GF(p)) else AGL(GrpMat, m, GF(p));
  S := AGLmp ! ([Coordinates(M, b2) cat [0] where b2 := M ! ((zeta^j2) @ FqFtoV) where j2 := ell*h+j where j := Log(zeta, (V ! b) @@ FqFtoV) : b in B] cat [[i eq m+1 select 1 else 0 : i in [1..m+1]]]);
  T := AGLmp ! ([Coordinates(M, b2) cat [0] where b2 := M ! ((zeta^j2) @ FqFtoV) where j2 := k*h+q*j where j := Log(zeta, (V ! b) @@ FqFtoV) : b in B] cat [[i eq m+1 select 1 else 0 : i in [1..m+1]]]);
  // print S, T, GroupName(sub<AGLmp | [S, T]>);
  // step 18
  G := sub<AGLmp | [S, T] cat [AGLmp | [[i eq j select 1 else i eq m+1 and j eq a select 1 else 0 : j in [1..m+1]] : i in [1..m+1]] : a in [1..m]]>;
  // convert G to a permutation group
  Gperm := OrbitImage(G, {@ Vector([x : x in v]) : v in CartesianProduct([[x : x in GF(p)] : i in [1..m]] cat [[GF(p) ! 1]]) @});
  return Gperm;
end intrinsic;

intrinsic GaloisGroup(alg :: PGGAlg_GaloisGroup, f :: RngUPolElt[FldPad]) -> GrpPerm
  {The Galois group of f.}
  return RamificationGroup(alg, f, Q!-1);
end intrinsic;

intrinsic InertiaGroup(alg :: PGGAlg_GaloisGroup, f :: RngUPolElt[FldPad]) -> GrpPerm
  {The inertia group of f.}
  return RamificationGroup(alg, f, Q!0);
end intrinsic;

intrinsic RamificationGroup(alg :: PGGAlg_GaloisGroup, f :: RngUPolElt[FldPad], u :: FldRatElt) -> GrpPerm
  {The u-th ramification group of f.}
  if u lt 0 then
    not_implemented("GaloisGroup");
  elif u lt 1 then
    not_implemented("InertiaGroup");
  else
    not_implemented("RamificationGroup");
  end if;
end intrinsic;

function parse_algorithm(alg)

  specs := PGG_ArgSpec_ManyRecursive(procedure (set, get)

    BOOL := PGG_ArgSpec_Union([
      PGG_ArgSpec_Attr("True", [], func<args | true>),
      PGG_ArgSpec_Attr("False", [], func<args | false>)
    ]);

    CONJUGACY := set("CONJUGACY", PGG_ArgSpec_Union([
      PGG_ArgSpec_ISA(PGGAlg_Conjugacy),
      PGG_ArgSpec_Literal(false),
      PGG_ArgSpec_Attr(
        "Symmetric",
        [<get("GALOISGROUP"),"GG",false>],
        func<args | PGGAlg_Conjugacy_Symmetric_Make(:GaloisGroupAlg:=args[1])>
      ),
      PGG_ArgSpec_Attr(
        "Factors",
        [<get("CONJUGACY"),"Next",false>],
        func<args | PGGAlg_Conjugacy_Factors_Make(:Next:=args[1])>
      ),
      PGG_ArgSpec_Attr(
        "RamTower",
        [<get("CONJUGACY"),"Next",false>],
        func<args | PGGAlg_Conjugacy_RamTower_Make(:Next:=args[1])>
      )
    ]));

    STATISTIC := set("STATISTIC", PGG_ArgSpec_Union([
      PGG_ArgSpec_ISA(PGGStat),
      PGG_ArgSpec_Literal(false),
      PGG_ArgSpec_Attr("HasRoot", [], func<args | PGGStat_HasRoot_Make()>),
      PGG_ArgSpec_Attr("NumRoots", [], func<args | PGGStat_NumRoots_Make()>),
      PGG_ArgSpec_Attr("FactorDegrees", [], func<args | PGGStat_FactorDegrees_Make()>),
      PGG_ArgSpec_Attr("FactorDegrees2", [], func<args | PGGStat_FactorDegrees2_Make()>),
      PGG_ArgSpec_Attr("Degree", [], func<args | PGGStat_Degree_Make()>),
      PGG_ArgSpec_Attr("AutGroup", [], func<args | PGGStat_AutGroup_Make()>),
      PGG_ArgSpec_AttrList("Tup", get("STATISTIC"), func<args | PGGStat_Tup_Make(args)>),
      PGG_ArgSpec_Attr("Factors", [<get("STATISTIC"), "Stat", false>], func<args | PGGStat_Factors_Make(:Stat:=args[1])>)
    ]));

    // SUBGROUP_TRANCHE := PGG_ArgSpec_Union([
    //   PGG_ArgSpec_Literal(false),
    //   PGG_ArgSpec_Attr("All"),
    //   PGG_ArgSpec_Attr("Index"),
    //   PGG_ArgSpec_Attr("OrbitIndex"),
    //   PGG_ArgSpec_Attr("MostUseful")
    // ]);

    // SUBGROUP_ORDER := set("SUBGROUP_ORDER", PGG_ArgSpec_Union([
    //   PGG_ArgSpec_ISA(PGGOrder),
    //   PGG_ArgSpec_Literal(false),
    //   PGG_ArgSpec_Attr("None", [], func<args | PGGOrder_None_Make()>),
    //   PGG_ArgSpec_Attr("Random", [], func<args | PGGOrder_Random_Make()>),
    //   PGG_ArgSpec_Attr("Reverse", [<get("SUBGROUP_ORDER"), "Order">], func<args | PGGOrder_Reverse_Make(args[1])>),
    //   PGG_ArgSpec_Attr("Index", [], func<args | PGGOrder_Key_Index_Make()>),
    //   PGG_ArgSpec_Attr("OrbitIndex", [], func<args | PGGOrder_Key_OrbitIndex_Make()>)
    // ]));

    // SUBGROUP_SCORE := PGG_ArgSpec_Union([
    //   PGG_ArgSpec_Literal(false),
    //   PGG_ArgSpec_Attr("IsUseful"),
    //   PGG_ArgSpec_Attr("Diversity"),
    //   PGG_ArgSpec_Attr("Information")
    // ]);

    // SUBGROUP_CHOICE := PGG_ArgSpec_Union([
    //   PGG_ArgSpec_Literal(false),
    //   PGG_ArgSpec_Attr("First"),
    //   PGG_ArgSpec_Attr("Best")
    // ]);

    // SUBGROUP_PRIORITY_EXPRESSION := PGG_ArgSpec_AttrExpr(["Index","OrbitIndex","Diversity","Information"]);

    EXPRESSION := func<vars | PGG_ArgSpec_Recursive(function (X)
      return PGG_ArgSpec_Union([
        PGG_ArgSpec_Attr(var, [], func<args | PGG_Expression_FreeVariable(var)>)
        : var in vars
      ] cat [
        PGG_ArgSpec_Attr("le", [<X>,<X>], func<args | PGG_Expression_BinOp('le', args[1], args[2])>),
        PGG_ArgSpec_Attr("lt", [<X>,<X>], func<args | PGG_Expression_BinOp('lt', args[1], args[2])>),
        PGG_ArgSpec_Attr("ge", [<X>,<X>], func<args | PGG_Expression_BinOp('ge', args[1], args[2])>),
        PGG_ArgSpec_Attr("gt", [<X>,<X>], func<args | PGG_Expression_BinOp('gt', args[1], args[2])>),
        PGG_ArgSpec_Attr("eq", [<X>,<X>], func<args | PGG_Expression_BinOp('eq', args[1], args[2])>),
        PGG_ArgSpec_Attr("ne", [<X>,<X>], func<args | PGG_Expression_BinOp('ne', args[1], args[2])>),
        PGG_ArgSpec_AttrList("and", X, func<args | PGG_Expression_SeqOp('&and', [x : x in args])>),
        PGG_ArgSpec_AttrList("or", X, func<args | PGG_Expression_SeqOp('&or', [x : x in args])>),
        PGG_ArgSpec_Attr("-", [<X>], func<args | PGG_Expression_UnOp('-', args[1])>),
        PGG_ArgSpec_Attr("-", [<X>,<X>], func<args | PGG_Expression_BinOp('-', args[1], args[2])>),
        PGG_ArgSpec_AttrList("+", X, func<args | PGG_Expression_SeqOp('&+', [x : x in args])>),
        PGG_ArgSpec_AttrList("*", X, func<args | PGG_Expression_SeqOp('&*', [x : x in args])>),
        PGG_ArgSpec_Transform(PGG_ArgSpec_AttrInt(), func<x | PGG_Expression_Const(x)>)
      ]);
    end function)>;

    SUBGROUP_PRIORITY := set("SUBGROUP_PRIORITY", PGG_ArgSpec_Union([
      PGG_ArgSpec_ISA(PGGAlg_ResPriority),
      PGG_ArgSpec_Literal(false),
      PGG_ArgSpec_Attr(
        "Null",
        [],
        func<args | PGGAlg_ResPriority_Null_Make()>
      ),
      PGG_ArgSpec_Attr(
        "Random",
        [],
        func<args | PGGAlg_ResPriority_Random_Make()>
      ),
      PGG_ArgSpec_Attr(
        "Reverse",
        [ <get("SUBGROUP_PRIORITY"),"Priority",false> ],
        func<args | PGGAlg_ResPriority_Reverse_Make(:Priority:=args[1])>
      ),
      // PGG_ArgSpec_Attr(
      //   "Filter",
      //   [ <SUBGROUP_PRIORITY_EXPRESSION,"Cond",false>,
      //     <get("SUBGROUP_PRIORITY"),"Priority",false>
      //   ],
      //   func<args | PGGAlg_ResPriority_Null_Make(:Expression:=args[1], Priority:=args[2])>
      // ),
      PGG_ArgSpec_Transform(EXPRESSION(["Index","OrbitIndex","Diversity","Information"]), func<x | PGGAlg_ResPriority_Key_Make(x)>)
    ]));

    SUBGROUP_TRANCHE := PGG_ArgSpec_Union([
      PGG_ArgSpec_ISA(PGGAlg_Tranche),
      PGG_ArgSpec_Literal(false),
      PGG_ArgSpec_Attr(
        "All",
        [ ],
        func<args | PGGAlg_Tranche_All_Make()>
      ),
      PGG_ArgSpec_Attr(
        "Index",
        [ <X,"If",false>, <X,"Sort",false> ] where X:=EXPRESSION(["idx"]),
        func<args | PGGAlg_Tranche_Index_Make(:Filter:=args[1], SortKey:=args[2])>
      ),
      PGG_ArgSpec_Attr(
        "OrbitIndex",
        [ <X,"If",false>, <X,"Sort",false> ] where X:=EXPRESSION(["idx","oidx","ridx"]),
        func<args | PGGAlg_Tranche_OrbitIndex_Make(:Filter:=args[1], SortKey:=args[2])>
      )
    ]);

    SUBGROUP_CHOICE := PGG_ArgSpec_Union([
      PGG_ArgSpec_ISA(PGGAlg_ResChoice),
      PGG_ArgSpec_Literal(false),
      PGG_ArgSpec_Transform(
        SUBGROUP_TRANCHE,
        func<t | PGGAlg_ResChoice_Tranche_Make(:Tranche:=t)>
      ),
      PGG_ArgSpec_Attr(
        "",
        [ <SUBGROUP_TRANCHE,"Tranche",false>, <SUBGROUP_PRIORITY,"Priority",false> ],
        func<args | PGGAlg_ResChoice_Tranche_Make(:Tranche:=args[1], Priority:=args[2])>
      )
    ]);

    RESGROUPS := PGG_ArgSpec_Union([
      PGG_ArgSpec_ISA(PGGAlg_ResGroups),
      PGG_ArgSpec_Literal(false),
      PGG_ArgSpec_Attr(
        "All",
        [ <STATISTIC,"Stat",false>
        , <SUBGROUP_CHOICE,"Choice",false>
        ],
        func<args | PGGAlg_ResGroups_All_Make(:Statistic:=args[1], SubgroupChoice:=args[2])>
      ),
      PGG_ArgSpec_Attr(
        "Maximal",
        [ <STATISTIC,"Stat",false>
        , <SUBGROUP_CHOICE,"Choice",false>
        , <PGG_ArgSpec_Union([
            PGG_ArgSpec_Literal(false),
            PGG_ArgSpec_Attr("Eager"),
            PGG_ArgSpec_Attr("Steady"),
            PGG_ArgSpec_Attr("Patient"),
            PGG_ArgSpec_Attr("Ask")
          ]), "Descend", false>
        , <PGG_ArgSpec_Union([
            PGG_ArgSpec_Literal(false),
            PGG_ArgSpec_Attr("Sufficient"),
            PGG_ArgSpec_Attr("Necessary"),
            PGG_ArgSpec_Attr("Generous"),
            PGG_ArgSpec_Attr("All")
          ]), "Useful", false>
        , <BOOL, "Reprocess", true>
        , <BOOL, "Reset", true>
        , <BOOL, "Blacklist", false>
        , <BOOL, "Dedupe", true>
        ],
        func<args | PGGAlg_ResGroups_Maximal_Make(:Statistic:=args[1], SubgroupChoice:=args[2], Descend:=args[3], Useful:=args[4], Reprocess:=args[5], Reset:=args[6], Blacklist:=args[7], Dedupe:=args[8])>
      ),
      PGG_ArgSpec_Attr(
        "RootsMaximal",
        [ <BOOL,"Dedupe",false> ],
        func<args | PGGAlg_ResGroups_RootsMaximal_Make(:Dedupe:=args[1])>
      )
    ]);

    RESEVAL := PGG_ArgSpec_Union([
      PGG_ArgSpec_ISA(PGGAlg_ResEval),
      PGG_ArgSpec_Literal(false),
      PGG_ArgSpec_Attr(
        "Global",
        [],
        func<args | PGGAlg_ResEval_Global_Make()>
      )
    ]);

    GALOISGROUP := set("GALOISGROUP", PGG_ArgSpec_Union([
      PGG_ArgSpec_ISA(PGGAlg_GaloisGroup),
      PGG_ArgSpec_Literal(false),
      PGG_ArgSpec_Attr(
        "ARM",
        [ <RESGROUPS,"Groups",false>
        , <RESEVAL,"Eval",false>
        , <CONJUGACY,"Conj",false>
        , <BOOL,"UseEasyResolvents",false>
        ],
        func<args | PGGAlg_GaloisGroup_ResolventMethod_Make(:GroupsAlg:=args[1], ResolventAlg:=args[2], ConjugacyAlg:=args[3], UseEasyResolvents:=args[4])>
      ),
      PGG_ArgSpec_Attr(
        "Builtin",
        [],
        func<args | PGGAlg_GaloisGroup_Builtin_Make()>
      ),
      PGG_ArgSpec_Attr(
        "SinglyRamified",
        [],
        func<args | PGGAlg_GaloisGroup_SinglyRamified_Make()>
      )
    ]));
  end procedure);

  return PGG_Parse(specs("GALOISGROUP"), alg);
end function;

intrinsic PGG_RamificationGroup(f :: RngUPolElt[FldPad], u :: FldRatElt : Alg:=false, Time:=false) -> GrpPerm
  {The u-th Galois group of f (in the upper numbering).}
  if Time then
    PGG_StartGlobalTimer();
  end if;
  PGG_GlobalTimer_Push("parse algorithm");
  if Alg cmpeq false then
    Alg := "ARM";
  end if;
  alg := parse_algorithm(Alg);
  vprint PGG_GaloisGroup: "algorithm =", alg;
  PGG_GlobalTimer_Swap("GaloisGroup");
  if u lt 0 then
    G := GaloisGroup(alg, f);
  elif u lt 1 then
    G := InertiaGroup(alg, f);
  else
    G := RamificationGroup(alg, f, u);
  end if;
  PGG_GlobalTimer_Pop();
  if Time then
    PGG_GlobalTimer_PrintTree();
    PGG_StopGlobalTimer();
  end if;
  return G;
end intrinsic;

intrinsic PGG_RamificationGroup(f :: RngUPolElt[FldPad], u :: RngIntElt : Alg:=false, Time:=false) -> GrpPerm
  {"}
  return PGG_RamificationGroup(f, Q!u : Alg:=Alg, Time:=Time);
end intrinsic;

intrinsic PGG_GaloisGroup(f :: RngUPolElt[FldPad] : Alg:=false, Time:=false) -> GrpPerm
  {The Galois group of f.}
  return PGG_RamificationGroup(f, -1 : Alg:=Alg, Time:=Time);
end intrinsic;

intrinsic PGG_InertiaGroup(f :: RngUPolElt[FldPad] : Alg:=false, Time:=false) -> GrpPerm
  {The inertia group of f.}
  return PGG_RamificationGroup(f, 0 : Alg:=Alg, Time:=Time);
end intrinsic;