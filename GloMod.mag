import "Utils.mag": Q, not_implemented, largest_coefficient, reduce_coefficients, change_apr, maximize_apr, has_root, factorization, ramification_tower, random_primitive_element, fldpad_has_isomorphism, seq_shuffle, roots, fldpad_eltseq;

declare type PGGGloMod;

declare type PGGGloMod_Fld: PGGGloMod;
declare attributes PGGGloMod_Fld: local_field, global_field, embeddings, primes;

declare type PGGGloMod_UPol: PGGGloMod;
declare attributes PGGGloMod_UPol: local_pol, global_pol;

declare type PGGGloMod_Rational: PGGGloMod_Fld;

declare type PGGGloMod_Symmetric: PGGGloMod_Fld, PGGGloMod_UPol;

declare type PGGGloMod_Factors: PGGGloMod;
declare attributes PGGGloMod_Factors: factors;

declare type PGGGloMod_Tower: PGGGloMod;
declare attributes PGGGloMod_Tower: tower, global_pol, global_pol_root, global_field;

declare type PGGGloMod_RootOfUnity: PGGGloMod_Fld, PGGGloMod_UPol;
declare attributes PGGGloMod_RootOfUnity: primitive_root, root_powers;

declare type PGGGloMod_RootOfUniformizer: PGGGloMod_Fld, PGGGloMod_UPol;
declare attributes PGGGloMod_RootOfUniformizer: degree, global_uniformizer, unity_powers;

intrinsic Approximation(m :: PGGGloMod_Fld, x :: FldPadElt) -> FldElt
  {Takes a global approximation to x across all embeddings.}
  return Approximation(m, x, {1..#m`embeddings});
end intrinsic;

intrinsic Approximation(m :: PGGGloMod_Fld, x :: FldPadElt, idxs :: {RngIntElt}) -> FldElt
  {A global approximation to x across a set of embeddings.}
  require idxs subset {1..#m`embeddings}: "idxs out of range";
  idxs := SetToSequence(idxs);
  if #idxs eq 0 then
    return m`global_field ! 0;
  elif #idxs eq 1 then
    return Approximation(m, x, idxs[1]);
  else
    k := AbsolutePrecision(x);
    return m`global_field ! CRT([Integers(m`global_field) | x @@ m`embeddings[i] : i in idxs], [m`primes[i]^k : i in idxs]);
  end if;
end intrinsic;

intrinsic Approximation(m :: PGGGloMod_Fld, x :: FldPadElt, i :: RngIntElt) -> FldElt
  {A global approximation to x in its ith embedding.}
  require i in {1..#m`embeddings}: "i out of range";
  return x @@ m`embeddings[i];
end intrinsic;

intrinsic GlobalModel(F :: FldPad) -> PGGGloMod
  {A global model for F.}
  if IsPrimeField(F) then
    m := New(PGGGloMod_Rational);
    m`local_field := F;
    m`global_field := Q;
    m`embeddings := [map<Q -> F | x :-> x, y :-> y>];
    m`primes := [ideal<Integers(Q) | Prime(F)>];
    return m;
  else
    not_implemented("global_model: non-prime field");
  end if;
end intrinsic;

intrinsic GlobalModel(alg :: PGGAlg_ResEval_Global_Model_Symmetric, f :: RngUPolElt[FldPad], bm :: PGGGloMod : TopField:=false) -> PGGGloMod, PGGHomGrpPerm
  {Global model with the given base model, and the corresponding hom W -> W2 where Gal(f)<W and Gal(model)<W2.}
  locW := PGGConj_Symmetric_Make(f : GaloisGroupAlg:=alg`galois_group_alg, TopField:=TopField);
  gloW := PGGGrpPerm_Symmetric_Make(Degree(f));
  Whom := IdentityHomomorphism(locW, gloW);
  m := New(PGGGloMod_Symmetric);
  locpol := f;
  m`local_pol := locpol;
  PGG_GlobalTimer_Push("global polynomial");
  glopol0 := Polynomial([Approximation(bm, c) : c in Coefficients(locpol)]);
  if assigned locW`top_field then
    nembs := #bm`embeddings;
    PGG_GlobalTimer_Swap("minimize coefficients");
    locext := locW`top_field;
    assert IsWeaklyEqual(DefiningPolynomial(locext), locpol);
    // minimize the coefficients of glopol
    K := BaseRing(locpol);
    pr := Precision(K);
    glopol := glopol0;
    root := locext.1;
    locext2s := [locext : i in [1..nembs]];
    isoms := [map<locext -> locext2s[i] | x :-> x, y :-> y> : i in [1..nembs]];
    pr := Ceiling(Log(Prime(K), Max([largest_coefficient(c) : c in Coefficients(glopol)])));
    vprint PGG_GaloisGroup, 1: "pr =", pr;
    vprint PGG_GaloisGroup, 2: "glopol =", glopol;
    while true do
      pr div:= 2;
      vprint PGG_GaloisGroup, 1: "pr =", pr;
      if pr lt 2 then
        break;
      end if;
      PGG_GlobalTimer_Push("reduce coefficients");
      glopol2 := Polynomial([reduce_coefficients(c, Prime(K)^pr) : c in Coefficients(glopol)]);
      vprint PGG_GaloisGroup, 2: "glopol =", glopol2;
      locpol2s := [Polynomial([change_apr(c@e, Precision(K)) : c in Coefficients(glopol2)]) : e in bm`embeddings];
      locext2news := [ext<K | pol> : pol in locpol2s];
      PGG_GlobalTimer_Swap("isomorphic");
      isom2s := [**];
      for locext2new in locext2news do
        ok, isom2 := fldpad_has_isomorphism(locext, locext2new, K);
        if ok then
          Append(~isom2s, isom2);
        else
          break;
        end if;
      end for;
      PGG_GlobalTimer_Pop();
      if ok then
        locext2s := locext2news;
        isoms := isom2s;
        glopol := glopol2;
      else
        break;
      end if;
    end while;
    // make the embeddings
    gloext := ext<BaseRing(glopol) | glopol>;
    m`local_field := locext;
    m`global_pol := glopol;
    m`global_field := gloext;
    m`embeddings := [map<gloext -> locext | x :-> (locext2![c@e : c in Eltseq(x)]) @@ isom, y :-> gloext![c@@e : c in fldpad_eltseq(y @ isom)]> where locext2:=locext2s[i] where isom:=isoms[i] where e:=bm`embeddings[i] : i in [1..nembs]];
    m`primes := [Factorization(Integers(m`global_field) !! p)[1][1] : p in bm`primes];
  else
    vprint PGG_GaloisGroup: "WARNING: not minimizing global coefficients (if the complex precision explodes, or complex root finding fails, this might be why)";
    m`global_pol := glopol0;
  end if;
  PGG_GlobalTimer_Pop();
  return m, Whom;
end intrinsic;

intrinsic GlobalModel(alg :: PGGAlg_ResEval_Global_Model_Factors, f :: RngUPolElt[FldPad], bm :: PGGGloMod) -> PGGGloMod, PGGHomGrpPerm
  {"}
  PGG_GlobalTimer_Push("factorize");
  facs := factorization(f);
  PGG_GlobalTimer_Swap("recurse");
  data := [* <m, h> where m,h:=GlobalModel(alg`next, fac, bm) : fac in facs *];
  PGG_GlobalTimer_Pop();
  m := New(PGGGloMod_Factors);
  m`factors := [x[1] : x in data];
  dom := PGGConj_Factors_Make(f, <Domain(x[2]) : x in data>);
  hom := PGGHomGrpPerm_DirProd_Make(<x[2] : x in data> : Domain:=dom);
  return m, hom;
end intrinsic;

intrinsic GlobalModel(alg :: PGGAlg_ResEval_Global_Model_RamTower, f :: RngUPolElt[FldPad], bm :: PGGGloMod) -> PGGGloMod, PGGHomGrpPerm
  {"}
  PGG_GlobalTimer_Push("factorize");
  facs, certs := factorization(f : Extensions);
  assert #facs eq 1;
  PGG_GlobalTimer_Swap("ramification tower");
  t := ramification_tower(certs[1]`Extension, BaseRing(f));
  PGG_GlobalTimer_Swap("recurse");
  m := New(PGGGloMod_Tower);
  m`tower := [**];
  m2 := bm;
  hs := [**];
  for i in [2..#t] do
    m2, h2 := GlobalModel(alg`next, DefiningPolynomial(t[i]), m2 : TopField:=t[i]);
    Append(~m`tower, m2);
    Append(~hs, h2);
  end for;
  PGG_GlobalTimer_Swap("primitive element");
  m`global_field := m2`global_field;
  gloroot, glopol := random_primitive_element(m2`global_field, bm`global_field);
  m`global_pol := glopol;
  m`global_pol_root := gloroot;
  PGG_GlobalTimer_Pop();
  dom := PGGConj_Tower_Make(f, <Domain(h) : h in hs>);
  hom := PGGHomGrpPerm_WrProd_Make(<h : h in hs> : Domain:=dom);
  return m, hom;
end intrinsic;

intrinsic GlobalModel(alg :: PGGAlg_ResEval_Global_Model_Select, f :: RngUPolElt[FldPad], bm :: PGGGloMod : TopField:=false) -> PGGGloMod, PGGHomGrpPerm
  {"}
  PGG_GlobalTimer_Push("predicates");
  K := BaseRing(f);
  L := TopField;
  for i in [1..#alg`models] do
    if (i gt #alg`predicates)
    or EvaluateLazy(
        alg`predicates[i],
        func<n, v | case<n
          | "p": Prime(BaseRing(f))
          , "faccerts": certs where _,certs := factorization(f : Extensions)
          , "irr": L cmpne false or #v("faccerts") eq 1
          , "deg": Degree(f)
          , "unram": L cmpne false select RamificationDegree(L,K) eq 1 else forall{c : c in v("faccerts") | c`E eq 1}
          , "tame": (L cmpne false select not IsDivisibleBy(RamificationDegree(L,K), p) else forall{c : c in v("faccerts") | not IsDivisibleBy(c`E, p)}) where p:=Prime(BaseRing(f))
          , "ram": not v("Unram")
          , "wild": not v("Tame")
          , "totram": L cmpne false select InertiaDegree(L,K) eq 1 else forall{c : c in v("faccerts") | c`F eq 1}
          , "totwild": (L cmpne false select InertiaDegree(L,K) eq 1 and IsPowerOf(RamificationDegree(L,K),p) else forall{c : c in v("faccerts") | c`F eq 1 and IsPowerOf(c`E, p)}) where p:=Prime(BaseRing(f))
          , default: not_implemented()
          >
        > : Recursive)
    then
      PGG_GlobalTimer_Swap("recurse");
      m, h := GlobalModel(alg`models[i], f, bm : TopField:=TopField);
      PGG_GlobalTimer_Pop();
      return m, h;
    end if;
  end for;
  PGG_GlobalTimer_Pop();
  error "cases were not exhaustive";
end intrinsic;

intrinsic GlobalModel(alg :: PGGAlg_ResEval_Global_Model_RootOfUnity, f :: RngUPolElt[FldPad], bm :: PGGGloMod : TopField:=false) -> PGGGloMod, PGGHomGrpPerm
  {"}
  // check the inputs
  K := BaseRing(f);
  L := TopField;
  if L cmpeq false then
    not_implemented("expecting f to be irreducible");
  end if;
  if RamificationDegree(L, K) ne 1 then
    not_implemented("ramified extensions");
  end if;

  // choose n such that we are adjoining an nth root of unity
  d := Degree(L, K);
  assert InertiaDegree(L, K) eq d;
  p := Prime(K);
  q := p^AbsoluteInertiaDegree(K);
  n0 := q^d-1;
  if alg`minimize then
    n := Min([n : n in Divisors(n0) | forall{i : i in [1..d-1] | not IsDivisibleBy(q^i-1, n)}]);
  else
    n := n0;
  end if;
  // choose a factor of the nth cyclotomic polynomial over the global field
  Cn := CyclotomicPolynomial(n);
  gK := Domain(bm`embeddings[1]);
  assert forall{e : e in bm`embeddings | Domain(e) eq gK and Codomain(e) eq K};
  C := Factorization(ChangeRing(Cn, gK))[1][1];
  d2 := Degree(C);
  ok, s := IsDivisibleBy(d2, d);
  assert ok;
  // extend by this factor, so z is a primitive nth root of unity
  gL<z> := ext<gK | C>;
  assert Evaluate(C, z) eq 0;
  assert Degree(gL, gK) eq d2;
  // make the intermediate field which embeds into the local base field
  if s eq 1 then
    gM := gK;
  else
    gM<w> := sub<gL | &+[z^(q^i) : i in [0..d-1]]>;
  end if;
  assert Degree(gM, gK) eq s;
  // choose a factor of C over M
  C2 := Factorization(ChangeRing(C, gM))[1][1];
  assert Degree(C2) eq d;
  // choose primes of L above the primes of K
  p0s := [Factorization(Integers(gL) !! p)[1][1] : p in bm`primes];
  // find the i such that z->z^i are automorphisms
  auts := {@ i : i in [0..n-1 by q-1] | Evaluate(C,z^i) eq 0 @};
  assert #auts eq d2;
  assert forall{i : i in [0..d-1] | ((q^i) mod n) in auts};
  // put these into orbits under z->z^q, corresponding to the local Galois group (each orbit corresponds to an embedding of gM into K)
  auts_todo := {i : i in auts};
  orbits := [];
  for j in [1..s] do
    orbit := [];
    i := Min(auts_todo);
    for k in [1..d] do
      assert i in auts_todo;
      Exclude(~auts_todo, i);
      Append(~orbit, i);
      i := (q*i) mod n;
    end for;
    Append(~orbits, orbit);
  end for;
  // put the automorphisms into orbit order
  auts2 := {@ i : i in orbit, orbit in orbits @};
  vprint PGG_GaloisGroup, 2: "auts =", auts2;
  // embed gM into K
  if s eq 1 then
    Membs := bm`embeddings;
  else
    Membs := [];
    for e in bm`embeddings do
      pol := Polynomial([K| c@e : c in Coefficients(MinimalPolynomial(w, gK))]);
      ok, root := has_root(pol);
      assert ok;
      root := maximize_apr(root);
      Append(~Membs, map<gM -> K
        | x :-> &+[(cs[i] @ e) * root^(i-1) : i in [1..#cs]] where cs:=Eltseq(x)
      >);
    end for;
  end if;
  // make automorphisms of gL corresponding to the orbits
  gLauts := [hom<gL -> gL | z^o[1]> : o in orbits];
  // make primes of gL corresponding to embeddings
  ps := [ideal<Integers(gL) | [gen @ aut : gen in Generators(p0)]> : aut in gLauts, p0 in p0s];
  // make representative embeddings of gL to L
  Lembs0 := [];
  for i in [1..#bm`embeddings] do
    e := bm`embeddings[i];
    e0 := Membs[i];
    C3 := Polynomial([K| maximize_apr(c @ e0) : c in Coefficients(C2)]);
    L2 := ext<K | C3>;
    ok, isom := fldpad_has_isomorphism(L, L2, K);
    assert ok;
    Append(~Lembs0, map<gL -> L
      | x :-> (&+[L2| (L2.1)^(i-1) * (cs[i]@e) : i in [1..#cs]])@@isom where cs:=Eltseq(x)
      , y :-> &+[gL| (gL.1)^(i-1) * (cs[i]@@e) : i in [1..#cs]] where cs:=fldpad_eltseq(y@isom)
    >);
  end for;
  // make all embeddings
  Lembs := [map<gL -> L | x :-> x @ aut @ e, y :-> y @@ e @@ aut> : aut in gLauts, e in Lembs0];

  // create the model
  m := New(PGGGloMod_RootOfUnity);
  m`embeddings := Lembs;
  m`primes := ps;
  m`local_field := L;
  m`global_field := gL;
  // m`local_pol := C2;
  m`global_pol := C;
  m`primitive_root := n;
  m`root_powers := auts2;

  // create the corresponding groups
  // W is cyclic of order d
  W := PGGConj_Unramified_Make(f : TopField:=L);
  // W2wr = S_d wr S_s
  W2wr := PGGGrpPerm_WrProd_Make(<PGGGrpPerm_Symmetric_Make(s), PGGGrpPerm_Symmetric_Make(d)>);
  // W2 is the subgroup of W2wr corresponding to the global Galois group (identifying (i->z^i) with the index of i in auts2)
  W2 := PGGGrpPerm_RawSubgroup_Make(W2wr, sub<Group(W2wr) | [[Index(auts2, (i*j) mod n) : j in auts2] : i in auts2]>);
  // the diagonal embedding of W into W2
  Whom := PGGHomGrpPerm_WrDiagonal_Make(W, W2);
  assert #Group(W2) eq d2;
  assert IsAbelian(Group(W2));
  vprint PGG_GaloisGroup: "W2 =", GroupName(Group(W2));
  return m, Whom;
end intrinsic;

intrinsic GlobalModel(alg :: PGGAlg_ResEval_Global_Model_RootOfUniformizer, f :: RngUPolElt[FldPad], bm :: PGGGloMod : TopField:=false) -> PGGGloMod, PGGHomGrpPerm
  {"}

  // check the inputs
  if TopField cmpeq false then
    not_implemented("f must be known irreducible");
  end if;
  L := TopField;
  K := BaseRing(f);
  d := Degree(f);
  p := Prime(K);
  assert Degree(L, K) eq d;
  if (InertiaDegree(L, K) ne 1) or IsDivisibleBy(d, p) then
    not_implemented("expecting a totally tame extension");
  end if;

  // get the global base field
  gK := Domain(bm`embeddings[1]);
  assert forall{e : e in bm`embeddings | Domain(e) eq gK};
  assert forall{e : e in bm`embeddings | Codomain(e) eq K};

  // find Aut(gK(zeta_d)/gK) in terms of i s.t. zeta -> zeta^i
  C := Factorization(ChangeRing(CyclotomicPolynomial(d), gK))[1][1];
  gM<z> := ext<gK | C>;
  zauts := {@ i : i in [1..d-1] | Evaluate(C, z^i) eq 0 @};
  vprint PGG_GaloisGroup, 1: "zauts =", zauts;
  assert 1 in zauts;
  assert IsDivisibleBy(EulerPhi(d), #zauts);

  // the global field
  piK := Coefficient(DefiningPolynomial(L, K), 0);
  assert AbsolutePrecision(piK) ge 2;
  assert Valuation(piK) eq 1;
  gpiK0 := Approximation(bm, piK);
  gpiK := reduce_coefficients(gpiK0, p^2);
  gL := ext<gK | Polynomial([case<i | 0:gpiK, d:1, default: 0> : i in [0..d]])>;

  // extend each embedding
  Lembs := [];
  for e in bm`embeddings do
    L2 := ext<K | Polynomial([case<i | 0:e(gpiK), d:1, default: 0> : i in [0..d]])>;
    ok, isom := fldpad_has_isomorphism(L, L2, K);
    assert ok;
    Append(~Lembs, map<gL -> L
      | x :-> (&+[L2| (cs[i]@e) * (L2.1)^(i-1) : i in [1..#cs]])@@isom where cs:=Eltseq(x)
      , y :-> &+[gL| (cs[i]@@e) * (gL.1)^(i-1) : i in [1..#cs]] where cs:=fldpad_eltseq(y@isom)>);
  end for;

  // extend each prime
  ps := [Factorization(Integers(gL) !! p)[1][1] : p in bm`primes];

  // make the model
  m := New(PGGGloMod_RootOfUniformizer);
  m`embeddings := Lembs;
  m`primes := ps;
  m`local_field := L;
  m`global_field := gL;
  m`global_pol := DefiningPolynomial(gL);
  m`global_uniformizer := -gpiK;
  m`degree := d;
  m`unity_powers := zauts;

  // the Galois groups
  Sd := PGGGrpPerm_Symmetric_Make(d);
  gW := PGGGrpPerm_RawSubgroup_Make(Sd, sub<Group(Sd) | [[(((k-1)*j+i) mod d)+1 : k in [1..d]] : j in zauts, i in [0..d-1]]>);
  assert #Group(gW) eq d*#zauts;
  W := PGGConj_TotRam_Make(f : TopField:=L);
  Whom := PGGHomGrpPerm_Id_Make(W, gW);

  return m, Whom;
end intrinsic;

intrinsic ComplexEmbeddings(m :: PGGGloMod_Rational, embs :: [Map]) -> []
  {The complex embeddings of m extending embs.}
  return embs;
end intrinsic;

intrinsic ComplexEmbeddings(m :: PGGGloMod_Symmetric, embs :: [Map]) -> []
  {"}
  rss := ComplexRoots(m, embs);
  return [map<m`global_field -> C | x :-> &+[(cs[j] @ e) * r^(j-1) : j in [1..#cs]] where cs:=Eltseq(x)> where C:=Codomain(e) where e:=embs[i] : r in rss[i], i in [1..#embs]];
end intrinsic;

intrinsic ComplexEmbeddings(m :: PGGGloMod_RootOfUnity, embs :: [Map]) -> []
  {"}
  rss := ComplexRoots(m, embs);
  return [map<m`global_field -> C | x :-> &+[(cs[j] @ e) * r^(j-1) : j in [1..#cs]] where cs:=Eltseq(x)> where C:=Codomain(e) where e:=embs[i] : r in rss[i], i in [1..#embs]];
end intrinsic;

intrinsic ComplexEmbeddings(m :: PGGGloMod_RootOfUniformizer, embs :: [Map]) -> []
  {"}
  rss := ComplexRoots(m, embs);
  return [map<m`global_field -> C | x :-> &+[(cs[j] @ e) * r^(j-1) : j in [1..#cs]] where cs:=Eltseq(x)> where C:=Codomain(e) where e:=embs[i] : r in rss[i], i in [1..#embs]];
end intrinsic;

intrinsic ComplexRoots(m :: PGGGloMod_Symmetric, embs :: [Map]) -> []
  {The complex roots of the polynomial model.}
  return [[r[1] : r in Roots(Polynomial([c@e : c in Coefficients(m`global_pol)]))] : e in embs];
end intrinsic;

intrinsic ComplexRoots(m :: PGGGloMod_RootOfUnity, embs :: [Map]) -> []
  {"}
  rs := [Roots(Polynomial([c@e : c in Coefficients(m`global_pol)]))[1][1] : e in embs];
  assert forall{r : r in rs | Abs(Abs(r)-1) lt 1e-10};
  assert forall{r : r in rs | Abs(r^m`primitive_root-1) lt 1e-10};
  return [[r^i : i in m`root_powers] : r in rs];
end intrinsic;

intrinsic ComplexRoots(m :: PGGGloMod_RootOfUniformizer, embs :: [Map]) -> []
  {"}
  // rs := [Roots(Polynomial([c@e : c in Coefficients(m`global_pol)]))[1][1] : e in embs];
  rs := [(m`global_uniformizer @ e)^(1/m`degree) : e in embs];
  if m`degree eq 1 then
    return [[r] : r in rs];
  else
    return [[j eq 0 select r else r * z^j : j in [0..m`degree-1]] where z:=((C!-1)^(1/m`degree))^2 where C:=Codomain(e) where e:=embs[i] where r:=rs[i] : i in [1..#embs]];
  end if;
end intrinsic;

intrinsic ComplexRoots(m :: PGGGloMod_Factors, embs :: [Map]) -> []
  {"}
  rsss := [ComplexRoots(fac, embs) : fac in m`factors];
  return [&cat[rss[i] : rss in rsss] : i in [1..#embs]];
end intrinsic;

intrinsic ComplexRoots(m :: PGGGloMod_Tower, embs :: [Map]) -> []
  {"}
  es := embs;
  for m2 in m`tower do
    es := ComplexEmbeddings(m2, es);
  end for;
  d := #m`tower eq 0 select 1 else Degree(m`tower[#m`tower]`global_field, BaseRing(m`tower[1]`global_pol));
  assert #es eq #embs * d;
  // todo: also find complex roots of the global_pol, which should be more accurate but unordered, and pair them up
  return [[e(m`global_pol_root) : e in es[1+d*(i-1)..d*i]] : i in [1..#embs]];
end intrinsic;

