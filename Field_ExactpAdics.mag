declare type PGGFldExact[PGGFldExactElt]: PGGFld;
declare attributes PGGFldExact: actual, strategy, base_field;
declare type PGGFldExactElt: PGGFldElt;
declare attributes PGGFldExactElt: actual, strategy;

intrinsic PGGFldExact_Make(K :: FldPadExact) -> PGGFldExact
  {Converts K to our representation.}
  F := New(PGGFldExact);
  F`actual := K;
  return F;
end intrinsic;

intrinsic PGGFldExact_Make(p :: RngIntElt) -> PGGFldExact
  {The exact p-adic field.}
  return PGGFldExact_Make(ExactpAdicField(p));
end intrinsic;

intrinsic PGGFldExact_Make(K :: FldPadExact, F :: PGGFldExact) -> PGGFldExact
  {The p-adic field K as an extension of F.}
  t := [];
  L := K;
  while true do
    if L eq Actual(F) then
      break;
    elif IsPrimeField(L) then
      error "K is not an extension of F";
    else
      Append(~t, L);
      L := BaseField(L);
    end if;
  end while;
  E := F;
  for L in Reverse(t) do
    E0 := E;
    E := PGGFldExact_Make(L);
    E`base_field := E0;
  end for;
  return E;
end intrinsic;

intrinsic Actual(K :: PGGFldExact) -> FldPadExact
  {The actual field.}
  return K`actual;
end intrinsic;

intrinsic Actual(x :: PGGFldExactElt) -> FldPadExactElt
  {The actual element.}
  return x`actual;
end intrinsic;

intrinsic Print(F :: PGGFldExact, lvl :: MonStgElt)
  {Print.}
  Print(Actual(F), lvl);
end intrinsic;

intrinsic Print(x :: PGGFldExactElt, lvl :: MonStgElt)
  {"}
  Print(Actual(x), lvl);
end intrinsic;

intrinsic IsCoercible(F :: PGGFldExact, X) -> BoolElt, .
  {True if X is coercible to an element of F.}
  ok, Y := IsCoercible(Actual(F), X);
  if ok then
    x := New(PGGFldExactElt);
    x`actual := Y;
    x`parent := F;
    return true, x;
  elif assigned Y then
    return false, Y;
  else
    return false, "not coercible to the actual field";
  end if;
end intrinsic;

intrinsic IsCoercible(F :: PGGFldExact, X :: PGGFldExactElt) -> BoolElt, .
  {"}
  if Parent(X) eq F then
    return true, X;
  else
    return IsCoercible(F, Actual(X));
  end if;
end intrinsic;

intrinsic 'eq'(E :: PGGFldExact, F :: PGGFldExact) -> BoolElt, .
  {Equality.}
  return Actual(E) eq Actual(F);
end intrinsic;

intrinsic Prime(F :: PGGFldExact) -> RngIntElt
  {The p in p-adic.}
  return Prime(Actual(F));
end intrinsic;

intrinsic PrecisionStrategy(F :: PGGFldExact) -> .
  {The precision strategy to use with F.}
  return assigned F`strategy select F`strategy else assigned F`base_field select PrecisionStrategy(F`base_field) else "default";
end intrinsic;

intrinsic PrecisionStrategy(x :: PGGFldExactElt) -> .
  {The precision strategy to use with x.}
  return assigned x`strategy select x`strategy else PrecisionStrategy(Parent(x));
end intrinsic;