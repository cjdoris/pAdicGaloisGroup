import "Utils.mag": has_root, roots, factorization, extension, not_implemented, is_subpartition_of;

declare type PGGStat;
declare type PGGStat_EqSimple: PGGStat;
declare type PGGStat_HasRoot: PGGStat_EqSimple;
declare type PGGStat_NumRoots: PGGStat_EqSimple;
declare type PGGStat_FactorDegrees: PGGStat_EqSimple;
declare type PGGStat_Degree: PGGStat_EqSimple;
declare type PGGStat_Order: PGGStat_EqSimple;
declare type PGGStat_AutGroup: PGGStat_EqSimple;
declare attributes PGGStat_AutGroup: conjugacy_classes;
declare type PGGStat_Tup: PGGStat_EqSimple;
declare attributes PGGStat_Tup: stats;
declare type PGGStat_Factors: PGGStat_EqSimple;
declare attributes PGGStat_Factors: stat;
declare type PGGStat_Factors2: PGGStat;
declare attributes PGGStat_Factors2: strict, stat1, stat2;

declare type PGGStatVal;
declare attributes PGGStatVal: stat, value, hash, hashable;

intrinsic MakeValue(S :: PGGStat, value) -> PGGStatVal
  {A value for the statistic S.}
  x := New(PGGStatVal);
  x`stat := S;
  x`value := value;
  return x;
end intrinsic;

intrinsic Hash(v :: PGGStatVal) -> .
  {Hash of v.}
  if not assigned v`hash then
    v`hash := Hash(Hashable(v));
  end if;
  return v`hash;
end intrinsic;

intrinsic Hashable(v :: PGGStatVal) -> .
  {Hashable value for v.}
  if not assigned v`hashable then
    v`hashable := _Hashable(v`stat, v);
  end if;
  return v`hashable;
end intrinsic;

intrinsic 'eq'(S1 :: PGGStat, S2 :: PGGStat) -> BoolElt
  {Equality.}
  return IsIdentical(S1, S2);
end intrinsic;

intrinsic 'eq'(v1 :: PGGStatVal, v2 :: PGGStatVal) -> BoolElt
  {Equality.}
  require v1`stat eq v2`stat: "must be values of the same statistic";
  return 'eq'(v1`stat, v1, v2);
end intrinsic;

intrinsic 'subset'(v1 :: PGGStatVal, v2 :: PGGStatVal) -> BoolElt
  {True if v1 is possibly a statistic for a subgroup of the group v2 is a subset for.}
  require v1`stat eq v2`stat: "must be values of the same statistic";
  return 'subset'(v1`stat, v1, v2);
end intrinsic;

intrinsic Print(v :: PGGStatVal)
  {Prints.}
  _Print(v`stat, v);
end intrinsic;

intrinsic PGGStat_HasRoot_Make() -> PGGStat_HasRoot
  {Makes a new PGGStat.}
  return New(PGGStat_HasRoot);
end intrinsic;

intrinsic PGGStat_NumRoots_Make() -> PGGStat_NumRoots
  {Makes a new PGGStat.}
  return New(PGGStat_NumRoots);
end intrinsic;

intrinsic PGGStat_FactorDegrees_Make() -> PGGStat_FactorDegrees
  {Makes a new PGGStat.}
  return New(PGGStat_FactorDegrees);
end intrinsic;

intrinsic PGGStat_AutGroup_Make() -> PGGStat_AutGroup
  {"}
  return New(PGGStat_AutGroup);
end intrinsic;

intrinsic PGGStat_Degree_Make() -> PGGStat_Degree
  {Makes a new PGGStat.}
  return New(PGGStat_Degree);
end intrinsic;

intrinsic PGGStat_Order_Make() -> PGGStat_Order
  {"}
  return New(PGGStat_Order);
end intrinsic;

intrinsic PGGStat_Factors_Make(:Stat:=false) -> PGGStat_Factors
  {"}
  S := New(PGGStat_Factors);
  S`stat := Stat cmpne false select Stat else PGGStat_Degree_Make();
  return S;
end intrinsic;

intrinsic PGGStat_Factors2_Make(:Stat1:=false,Stat2:=false,Strict:=false) -> PGGStat_Factors2
  {"}
  S := New(PGGStat_Factors2);
  S`stat2 := Stat2 cmpne false select Stat2 else PGGStat_Degree_Make();
  S`stat1 := Stat1 cmpne false select Stat1 else PGGStat_Degree_Make();
  S`strict := Strict;
  return S;
end intrinsic;

intrinsic PGGStat_Tup_Make(args) -> PGGStat_Tup
  {Makes a new PGGStat.}
  S := New(PGGStat_Tup);
  S`stats := args;
  return S;
end intrinsic;

intrinsic Print(S :: PGGStat_HasRoot)
  {Print.}
  printf "has root";
end intrinsic;

intrinsic Print(S :: PGGStat_NumRoots)
  {"}
  printf "number of roots";
end intrinsic;

intrinsic Print(S :: PGGStat_FactorDegrees)
  {"}
  printf "degrees of factors";
end intrinsic;

intrinsic Print(S :: PGGStat_AutGroup)
  {"}
  printf "automorphism group";
end intrinsic;

intrinsic Print(S :: PGGStat_Degree)
  {"}
  printf "degree";
end intrinsic;

intrinsic Print(S :: PGGStat_Factors)
  {"}
  printf "factors -> ";
  Print(S`stat);
end intrinsic;

intrinsic Print(S :: PGGStat_Factors2)
  {"}
  print "factors of factors";
  IndentPush();
  printf "stat2 = "; Print(S`stat2);
  print "";
  printf "stat1 = "; Print(S`stat1);
  print "";
  printf "strict = %o", S`strict;
  IndentPop();
end intrinsic;

intrinsic Print(S :: PGGStat_Tup)
  {"}
  if #S`stats eq 0 then
    printf "tuple (empty)";
  else
    print "tuple";
    IndentPush();
    for i in [1..#S`stats] do
      Print(S`stats[i]);
      if i lt #S`stats then
        print "";
      end if;
    end for;
    IndentPop();
  end if;
end intrinsic;

intrinsic ConjugacyClasses(S :: PGGStat_AutGroup, d :: RngIntElt) -> PGGSetSubgrpcls
  {The conjugacy classes of Sym(d).}
  if not assigned S`conjugacy_classes then
    S`conjugacy_classes := AssociativeArray();
  end if;
  if not IsDefined(S`conjugacy_classes, d) then
    S`conjugacy_classes[d] := PGG_SubgroupClasses(SymmetricGroup(d));
  end if;
  return S`conjugacy_classes[d];
end intrinsic;

intrinsic GroupStat(S :: PGGStat_HasRoot, G :: GrpPerm) -> PGGStatVal
  {The value of the statistic on the group.}
  return MakeValue(S, exists{o : o in Orbits(G) | #o eq 1});
end intrinsic;

intrinsic GroupStat(S :: PGGStat_NumRoots, G :: GrpPerm) -> PGGStatVal
  {"}
  return MakeValue(S, #[o : o in Orbits(G) | #o eq 1]);
end intrinsic;

intrinsic GroupStat(S :: PGGStat_FactorDegrees, G :: GrpPerm) -> PGGStatVal
  {"}
  return MakeValue(S, {* #o : o in Orbits(G) *});
end intrinsic;

intrinsic GroupStat(S :: PGGStat_Degree, G :: GrpPerm) -> PGGStatVal
  {"}
  return MakeValue(S, Degree(G));
end intrinsic;

intrinsic GroupStat(S :: PGGStat_Order, G :: GrpPerm) -> PGGStatVal
  {"}
  return MakeValue(S, #G);
end intrinsic;

intrinsic GroupStat(S :: PGGStat_AutGroup, G :: GrpPerm) -> PGGStatVal
  {"}
  assert IsTransitive(G);
  stab := Stabilizer(G, 1);
  norm := Normalizer(G, stab);
  aut := CosetImage(norm, stab);
  return MakeValue(S, ConjugacyClasses(S, Degree(aut)) ! aut);
end intrinsic;

intrinsic GroupStat(S :: PGGStat_Tup, G :: GrpPerm) -> PGGStatVal
  {"}
  return MakeValue(S, <GroupStat(S2, G) : S2 in S`stats>);
end intrinsic;

intrinsic GroupStat(S :: PGGStat_Factors, G :: GrpPerm) -> PGGStatVal
  {"}
  return MakeValue(S, {* GroupStat(S`stat, OrbitImage(G, o)) : o in Orbits(G) *});
end intrinsic;

intrinsic GroupStat(S :: PGGStat_Factors2, G :: GrpPerm) -> PGGStatVal
  {"}
  return MakeValue(S,
    < [GroupStat(S`stat1, OrbitImage(G,o)) : o in os]
    , [ [ {* GroupStat(S`stat2, OrbitImage(Go,o2)) : o2 in Orbits(Go) *} 
          where Go := OrbitImage(So,o) 
          : o in os
        ]
        where So := Stabilizer(G,Rep(o))
        : o in os 
        ]
    >
    where os := [o : o in Orbits(G)]
  );
end intrinsic;

intrinsic ResolventStat(S :: PGGStat_HasRoot, R :: RngUPolElt[FldPad]) -> PGGStatVal
  {The value of the statistic on the resolvent.}
  return MakeValue(S, has_root(R));
end intrinsic;

intrinsic ResolventStat(S :: PGGStat_NumRoots, R :: RngUPolElt[FldPad]) -> PGGStatVal
  {"}
  return MakeValue(S, #roots(R));
end intrinsic;

intrinsic ResolventStat(S :: PGGStat_FactorDegrees, R :: RngUPolElt[FldPad]) -> PGGStatVal
  {"}
  return MakeValue(S, {* Degree(fac) : fac in factorization(R) *});
end intrinsic;

intrinsic ResolventStat(S :: PGGStat_Degree, R :: RngUPolElt[FldPad]) -> PGGStatVal
  {"}
  return MakeValue(S, Degree(R));
end intrinsic;

intrinsic ResolventStat(S :: PGGStat_AutGroup, R :: RngUPolElt[FldPad]) -> PGGStatVal
  {"}
  K := BaseRing(R);
  L := extension(R);
  aut := AutomorphismGroup(L, K);
  return MakeValue(S, ConjugacyClasses(S, Degree(aut)) ! aut);
end intrinsic;

intrinsic ResolventStat(S :: PGGStat_Tup, R :: RngUPolElt[FldPad]) -> PGGStatVal
  {"}
  return MakeValue(S, <ResolventStat(S2, R) : S2 in S`stats>);
end intrinsic;

intrinsic ResolventStat(S :: PGGStat_Factors, R :: RngUPolElt[FldPad]) -> PGGStatVal
  {"}
  return MakeValue(S, {* ResolventStat(S`stat, fac) : fac in factorization(R) *});
end intrinsic;

intrinsic ResolventStat(S :: PGGStat_Factors2, R :: RngUPolElt[FldPad]) -> PGGStatVal
  {"}
  return MakeValue(S,
    < [ ResolventStat(S`stat1, fac) : fac in facs ]
    , [ [ {* ResolventStat(S`stat2, fac2) : fac2 in factorization(ChangeRing(fac, L)) *}
          : fac in facs
        ]
        where L := certs[i]`Extension
        : i in [1..#facs]
      ]
    >
    where facs, certs := factorization(R : Extensions)
  );
end intrinsic;

intrinsic 'eq'(S :: PGGStat, v1, v2) -> BoolElt
  {Equality.}
  not_implemented("equality:", Type(S));
end intrinsic;

intrinsic 'eq'(S :: PGGStat_EqSimple, v1, v2) -> BoolElt
  {Equality.}
  return v1`value eq v2`value;
end intrinsic;

intrinsic 'eq'(S :: PGGStat_AutGroup, v1, v2) -> BoolElt
  {"}
  return Degree(Rep(v1`value)) eq Degree(Rep(v2`value)) and v1`value eq v2`value;
end intrinsic;

procedure assoc_append(~A, k, x)
  if IsDefined(A, k) then
    Append(~A[k], x);
  else
    A[k] := [x];
  end if;
end procedure;

function is_conjugate2(G, X, xs, ys)
  H := G;
  for i in [1..#xs] do
    ok, g := IsConjugate(H, X, xs[i], ys[i]);
    if ok then
      for j in [i..#xs] do
        xs[j] := xs[j]^g;
      end for;
      assert xs[i] eq ys[i];
      H := Stabilizer(H, X, xs[i]);
    else
      return false;
    end if;
  end for;
  return true;
end function;

intrinsic 'eq'(S :: PGGStat_Factors2, v1, v2) -> BoolElt
  {"}
  if Hash(v1) ne Hash(v2) then
    return false;
  elif Hashable(v1) ne Hashable(v2) then
    return false;
  elif S`strict then
    xs1, yss1 := Explode(v1`value);
    xs2, yss2 := Explode(v2`value);
    n := #xs1;
    assert n eq #yss1;
    assert n eq #xs2;
    assert n eq #yss2;
    A1 := AssociativeArray();
    B1 := AssociativeArray();
    A2 := AssociativeArray();
    B2 := AssociativeArray();
    for i in [1..n] do
      assoc_append(~A1, xs1[i], [i,n+1]);
      assoc_append(~A2, xs2[i], [i,n+1]);
      for j in [1..n] do
        assoc_append(~B1, yss1[i][j], [i,j]);
        assoc_append(~B2, yss2[i][j], [i,j]);
      end for;
    end for;
    S := DirectProduct(SymmetricGroup(n), SymmetricGroup(1));
    as := SetToSequence(Keys(A1));
    bs := SetToSequence(Keys(B1));
    X := {[i,j] : i,j in [1..n+1]};
    GX := GSet(S, X, map<car<X, S> -> X | p :-> [p[1][1]^p[2], p[1][2]^p[2]] >);
    ok := is_conjugate2(S, GX, [SequenceToSet(B1[b]) : b in bs] cat [SequenceToSet(A1[a]) : a in as], [SequenceToSet(B2[b]) : b in bs] cat [SequenceToSet(A2[a]) : a in as]);
    if not ok then
      vprint PGG_GaloisGroup: "***** Factors2", v1, v2;
    end if;
    return ok;
  else
    return true;
  end if;
end intrinsic;

intrinsic 'subset'(S :: PGGStat, v1, v2) -> BoolElt
  {True if v1 is a refinement of v2.}
  not_implemented("subset: ", Type(S));
end intrinsic;

intrinsic 'subset'(S :: PGGStat_HasRoot, v1, v2) -> BoolElt
  {"}
  return (not v2`value) or (v1`value);
end intrinsic;

intrinsic 'subset'(S :: PGGStat_NumRoots, v1, v2) -> BoolElt
  {"}
  return v1`value ge v2`value;
end intrinsic;

intrinsic 'subset'(S :: PGGStat_FactorDegrees, v1, v2) -> BoolElt
  {"}
  return is_subpartition_of(v1`value, v2`value);
end intrinsic;

intrinsic 'subset'(S :: PGGStat_Degree, v1, v2) -> BoolElt
  {"}
  return v1`degree eq v2`degree;
end intrinsic;

// Is it true that if H<G then N_G(Stab_G(1))/Stab_G(1) < N_H(Stab_H(1))/Stab_H(1)?
// AG < AH <=> NG/SG < NH/SH = NH/(SG meet NH) ~ (NH SG)/SG <=> NG < NH SG ?
// It is true for all transitive groups of degree up to 15.
// 
// SG = {s in G : s(1)=1}
// SH = {s in H : s(1)=1} = SG meet H
// NG = {n in G : s in SG => s^n in SG} = {n in G : s in G, s(1)=1 => (s^n)(1)=1 i.e. s(n(1))=n(1)}
// 
// intrinsic 'subset'(S :: PGGStat_AutGroup, v1, v2) -> BoolElt
//   {"}
// end intrinsic;

intrinsic _Hashable(S :: PGGStat, v) -> .
  {Hash.}
  return v`value;
end intrinsic;

intrinsic _Hashable(S :: PGGStat_AutGroup, v) -> .
  {"}
  return <Degree(Rep(v`value)), v`value>;
end intrinsic;

intrinsic _Hashable(S :: PGGStat_Factors2, v) -> .
  {"}
  xs, yss := Explode(v`value);
  n := #xs;
  return 
    < {* x : x in xs *}
    , {* <xs[i], {* y : y in yss[i] *}> : i in [1..n] *}
    , {* <xs[i], {* ys[i] : ys in yss *}> : i in [1..n] *}
    >;
end intrinsic;

intrinsic _Print(S :: PGGStat, v)
  {"}
  printf "%o", v`value;
end intrinsic;

intrinsic _Print(S :: PGGStat_AutGroup, v)
  {"}
  printf "%o", GroupName(Rep(v`value));
end intrinsic;

